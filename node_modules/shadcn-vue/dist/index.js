#!/usr/bin/env node
import { BASE_COLORS, DEFAULT_COMPONENTS, DEFAULT_TAILWIND_CONFIG, DEFAULT_TAILWIND_CSS, DEFAULT_UTILS, _createSourceFile, _getQuoteChar, clearRegistryCache, fetchRegistry, fetchTree, findCommonRoot, findPackageRoot, getConfig, getItemTargetPath, getPackageInfo, getProjectConfig, getProjectInfo, getProjectTailwindVersionFromConfig, getRegistryBaseColor, getRegistryBaseColors, getRegistryIcons, getRegistryIndex, getRegistryItem, getRegistryParentMap, getRegistryStyles, getRegistryTypeAliasMap, getTSConfig, getWorkspaceConfig, handleError, highlighter, isUrl, logger, rawConfigSchema, registryGetTheme, registryItemSchema, registryResolveItemsTree, registrySchema, resolveConfigPaths, resolveRegistryItems, resolveTree, spinner, updateTailwindConfig } from "./registry-ByrmygPr.js";
import { Command } from "commander";
import * as path$1 from "pathe";
import path, { basename, dirname } from "pathe";
import prompts from "prompts";
import { z } from "zod";
import { existsSync, promises } from "node:fs";
import fs from "fs-extra";
import { glob } from "tinyglobby";
import consola from "consola";
import { tmpdir } from "node:os";
import { Project, ScriptKind, SyntaxKind } from "ts-morph";
import postcss from "postcss";
import AtRule from "postcss/lib/at-rule";
import { addDependency } from "nypm";
import { transform } from "vue-metamorph";
import { transform as transform$1 } from "@unovue/detypes";
import * as fs$1 from "node:fs/promises";
import { diffLines } from "diff";
import { randomBytes } from "node:crypto";

//#region src/utils/errors.ts
const MISSING_DIR_OR_EMPTY_PROJECT = "1";
const MISSING_CONFIG = "3";
const TAILWIND_NOT_CONFIGURED = "5";
const IMPORT_ALIAS_MISSING = "6";
const UNSUPPORTED_FRAMEWORK = "7";
const BUILD_MISSING_REGISTRY_FILE = "13";

//#endregion
//#region src/preflights/preflight-init.ts
async function preFlightInit(options) {
	const errors = {};
	if (!fs.existsSync(options.cwd) || !fs.existsSync(path.resolve(options.cwd, "package.json"))) {
		errors[MISSING_DIR_OR_EMPTY_PROJECT] = true;
		return {
			errors,
			projectInfo: null
		};
	}
	const projectSpinner = spinner(`Preflight checks.`, { silent: options.silent }).start();
	if (fs.existsSync(path.resolve(options.cwd, "components.json")) && !options.force) {
		projectSpinner?.fail();
		logger.break();
		logger.error(`A ${highlighter.info("components.json")} file already exists at ${highlighter.info(options.cwd)}.\nTo start over, remove the ${highlighter.info("components.json")} file and run ${highlighter.info("init")} again.`);
		logger.break();
		process.exit(1);
	}
	projectSpinner?.succeed();
	const frameworkSpinner = spinner(`Verifying framework.`, { silent: options.silent }).start();
	const projectInfo = await getProjectInfo(options.cwd);
	if (!projectInfo || projectInfo?.framework.name === "manual") {
		errors[UNSUPPORTED_FRAMEWORK] = true;
		frameworkSpinner?.fail();
		logger.break();
		if (projectInfo?.framework.links.installation) logger.error(`We could not detect a supported framework at ${highlighter.info(options.cwd)}.\nVisit ${highlighter.info(projectInfo?.framework.links.installation)} to manually configure your project.\nOnce configured, you can use the cli to add components.`);
		logger.break();
		process.exit(1);
	}
	frameworkSpinner?.succeed(`Verifying framework. Found ${highlighter.info(projectInfo.framework.label)}.`);
	let tailwindSpinnerMessage = "Validating Tailwind CSS.";
	if (projectInfo.tailwindVersion === "v4") tailwindSpinnerMessage = `Validating Tailwind CSS config. Found ${highlighter.info("v4")}.`;
	const tailwindSpinner = spinner(tailwindSpinnerMessage, { silent: options.silent }).start();
	if (projectInfo.tailwindVersion === "v3" && (!projectInfo?.tailwindConfigFile || !projectInfo?.tailwindCssFile)) {
		errors[TAILWIND_NOT_CONFIGURED] = true;
		tailwindSpinner?.fail();
	} else if (projectInfo.tailwindVersion === "v4" && !projectInfo?.tailwindCssFile) {
		errors[TAILWIND_NOT_CONFIGURED] = true;
		tailwindSpinner?.fail();
	} else if (!projectInfo.tailwindVersion) {
		errors[TAILWIND_NOT_CONFIGURED] = true;
		tailwindSpinner?.fail();
	} else tailwindSpinner?.succeed();
	const tsConfigSpinner = spinner(`Validating import alias.`, { silent: options.silent }).start();
	if (!projectInfo?.aliasPrefix) {
		errors[IMPORT_ALIAS_MISSING] = true;
		tsConfigSpinner?.fail();
	} else tsConfigSpinner?.succeed();
	if (Object.keys(errors).length > 0) {
		if (errors[TAILWIND_NOT_CONFIGURED]) {
			logger.break();
			logger.error(`No Tailwind CSS configuration found at ${highlighter.info(options.cwd)}.`);
			logger.error(`It is likely you do not have Tailwind CSS installed or have an invalid configuration.`);
			logger.error(`Install Tailwind CSS then try again.`);
			if (projectInfo?.framework.links.tailwind) logger.error(`Visit ${highlighter.info(projectInfo?.framework.links.tailwind)} to get started.`);
		}
		if (errors[IMPORT_ALIAS_MISSING]) {
			logger.break();
			logger.error(`No import alias found in your tsconfig.json file.`);
			if (projectInfo?.framework.links.installation) logger.error(`Visit ${highlighter.info(projectInfo?.framework.links.installation)} to learn how to set an import alias.`);
		}
		logger.break();
		process.exit(1);
	}
	return {
		errors,
		projectInfo
	};
}

//#endregion
//#region src/utils/updaters/update-css.ts
async function updateCss(css, config, options) {
	if (!config.resolvedPaths.tailwindCss || !css || Object.keys(css).length === 0) return;
	options = {
		silent: false,
		...options
	};
	const cssFilepath = config.resolvedPaths.tailwindCss;
	const cssFilepathRelative = path.relative(config.resolvedPaths.cwd, cssFilepath);
	const cssSpinner = spinner(`Updating ${highlighter.info(cssFilepathRelative)}`, { silent: options.silent }).start();
	const raw = await promises.readFile(cssFilepath, "utf8");
	const output = await transformCss(raw, css);
	await promises.writeFile(cssFilepath, output, "utf8");
	cssSpinner.succeed();
}
async function transformCss(input, css) {
	const plugins = [updateCssPlugin(css)];
	const result = await postcss(plugins).process(input, { from: void 0 });
	let output = result.css;
	output = output.replace(/\/\* ---break--- \*\//g, "");
	output = output.replace(/(\n\s*\n)+/g, "\n\n");
	output = output.trimEnd();
	return output;
}
function updateCssPlugin(css) {
	return {
		postcssPlugin: "update-css",
		Once(root) {
			for (const [selector, properties] of Object.entries(css)) if (selector.startsWith("@")) {
				const atRuleMatch = selector.match(/@([a-z-]+)\s*(.*)/i);
				if (!atRuleMatch) continue;
				const [, name$1, params] = atRuleMatch;
				if (name$1 === "keyframes") {
					let themeInline = root.nodes?.find((node) => node.type === "atrule" && node.name === "theme" && node.params === "inline");
					if (!themeInline) {
						themeInline = postcss.atRule({
							name: "theme",
							params: "inline",
							raws: {
								semicolon: true,
								between: " ",
								before: "\n"
							}
						});
						root.append(themeInline);
						root.insertBefore(themeInline, postcss.comment({ text: "---break---" }));
					}
					const keyframesRule = postcss.atRule({
						name: "keyframes",
						params,
						raws: {
							semicolon: true,
							between: " ",
							before: "\n  "
						}
					});
					themeInline.append(keyframesRule);
					if (typeof properties === "object") for (const [step, stepProps] of Object.entries(properties)) processRule(keyframesRule, step, stepProps);
				} else if (name$1 === "utility") {
					const utilityAtRule = root.nodes?.find((node) => node.type === "atrule" && node.name === name$1 && node.params === params);
					if (!utilityAtRule) {
						const atRule = postcss.atRule({
							name: name$1,
							params,
							raws: {
								semicolon: true,
								between: " ",
								before: "\n"
							}
						});
						root.append(atRule);
						root.insertBefore(atRule, postcss.comment({ text: "---break---" }));
						if (typeof properties === "object") {
							for (const [prop, value] of Object.entries(properties)) if (typeof value === "string") {
								const decl = postcss.decl({
									prop,
									value,
									raws: {
										semicolon: true,
										before: "\n    "
									}
								});
								atRule.append(decl);
							} else if (typeof value === "object") processRule(atRule, prop, value);
						}
					} else if (typeof properties === "object") {
						for (const [prop, value] of Object.entries(properties)) if (typeof value === "string") {
							const existingDecl = utilityAtRule.nodes?.find((node) => node.type === "decl" && node.prop === prop);
							const decl = postcss.decl({
								prop,
								value,
								raws: {
									semicolon: true,
									before: "\n    "
								}
							});
							existingDecl ? existingDecl.replaceWith(decl) : utilityAtRule.append(decl);
						} else if (typeof value === "object") processRule(utilityAtRule, prop, value);
					}
				} else processAtRule(root, name$1, params, properties);
			} else processRule(root, selector, properties);
		}
	};
}
function processAtRule(root, name$1, params, properties) {
	let atRule = root.nodes?.find((node) => node.type === "atrule" && node.name === name$1 && node.params === params);
	if (!atRule) {
		atRule = postcss.atRule({
			name: name$1,
			params,
			raws: {
				semicolon: true,
				between: " ",
				before: "\n"
			}
		});
		root.append(atRule);
		root.insertBefore(atRule, postcss.comment({ text: "---break---" }));
	}
	if (typeof properties === "object") for (const [childSelector, childProps] of Object.entries(properties)) if (childSelector.startsWith("@")) {
		const nestedMatch = childSelector.match(/@([a-z-]+)\s*(.*)/i);
		if (nestedMatch) {
			const [, nestedName, nestedParams] = nestedMatch;
			processAtRule(atRule, nestedName, nestedParams, childProps);
		}
	} else processRule(atRule, childSelector, childProps);
	else if (typeof properties === "string") try {
		const parsed = postcss.parse(`.temp{${properties}}`);
		const tempRule = parsed.first;
		if (tempRule && tempRule.nodes) {
			const rule = postcss.rule({
				selector: "temp",
				raws: {
					semicolon: true,
					between: " ",
					before: "\n  "
				}
			});
			tempRule.nodes.forEach((node) => {
				if (node.type === "decl") {
					const clone = node.clone();
					clone.raws.before = "\n    ";
					rule.append(clone);
				}
			});
			if (rule.nodes?.length) atRule.append(rule);
		}
	} catch (error) {
		console.error("Error parsing at-rule content:", properties, error);
		throw error;
	}
}
function processRule(parent, selector, properties) {
	let rule = parent.nodes?.find((node) => node.type === "rule" && node.selector === selector);
	if (!rule) {
		rule = postcss.rule({
			selector,
			raws: {
				semicolon: true,
				between: " ",
				before: "\n  "
			}
		});
		parent.append(rule);
	}
	if (typeof properties === "object") {
		for (const [prop, value] of Object.entries(properties)) if (typeof value === "string") {
			const decl = postcss.decl({
				prop,
				value,
				raws: {
					semicolon: true,
					before: "\n    "
				}
			});
			const existingDecl = rule.nodes?.find((node) => node.type === "decl" && node.prop === prop);
			existingDecl ? existingDecl.replaceWith(decl) : rule.append(decl);
		} else if (typeof value === "object") {
			const nestedSelector = prop.startsWith("&") ? selector.replace(/^([^:]+)/, `$1${prop.substring(1)}`) : prop;
			processRule(parent, nestedSelector, value);
		}
	} else if (typeof properties === "string") try {
		const parsed = postcss.parse(`.temp{${properties}}`);
		const tempRule = parsed.first;
		if (tempRule && tempRule.nodes) tempRule.nodes.forEach((node) => {
			if (node.type === "decl") {
				const clone = node.clone();
				clone.raws.before = "\n    ";
				rule?.append(clone);
			}
		});
	} catch (error) {
		console.error("Error parsing rule content:", selector, properties, error);
		throw error;
	}
}

//#endregion
//#region src/utils/updaters/update-css-vars.ts
async function updateCssVars(cssVars, config, options) {
	if (!config.resolvedPaths.tailwindCss || !Object.keys(cssVars ?? {}).length) return;
	options = {
		cleanupDefaultNextStyles: false,
		silent: false,
		tailwindVersion: "v3",
		overwriteCssVars: false,
		initIndex: true,
		...options
	};
	const cssFilepath = config.resolvedPaths.tailwindCss;
	const cssFilepathRelative = path.relative(config.resolvedPaths.cwd, cssFilepath);
	const cssVarsSpinner = spinner(`Updating CSS variables in ${highlighter.info(cssFilepathRelative)}`, { silent: options.silent }).start();
	const raw = await promises.readFile(cssFilepath, "utf8");
	const output = await transformCssVars$1(raw, cssVars ?? {}, config, {
		cleanupDefaultNextStyles: options.cleanupDefaultNextStyles,
		tailwindVersion: options.tailwindVersion,
		tailwindConfig: options.tailwindConfig,
		overwriteCssVars: options.overwriteCssVars,
		initIndex: options.initIndex
	});
	await promises.writeFile(cssFilepath, output, "utf8");
	cssVarsSpinner.succeed();
}
async function transformCssVars$1(input, cssVars, config, options = {
	cleanupDefaultNextStyles: false,
	tailwindVersion: "v3",
	tailwindConfig: void 0,
	overwriteCssVars: false,
	initIndex: true
}) {
	options = {
		cleanupDefaultNextStyles: false,
		tailwindVersion: "v3",
		tailwindConfig: void 0,
		overwriteCssVars: false,
		initIndex: true,
		...options
	};
	let plugins = [updateCssVarsPlugin(cssVars)];
	if (options.cleanupDefaultNextStyles) plugins.push(cleanupDefaultNextStylesPlugin());
	if (options.tailwindVersion === "v4") {
		plugins = [];
		if (config.resolvedPaths?.cwd) {
			const packageInfo = getPackageInfo(config.resolvedPaths.cwd);
			if (!packageInfo?.dependencies?.["tailwindcss-animate"] && !packageInfo?.devDependencies?.["tailwindcss-animate"] && options.initIndex) plugins.push(addCustomImport({ params: "tw-animate-css" }));
		}
		plugins.push(addCustomVariant({ params: "dark (&:is(.dark *))" }));
		if (options.cleanupDefaultNextStyles) plugins.push(cleanupDefaultNextStylesPlugin());
		plugins.push(updateCssVarsPluginV4(cssVars, { overwriteCssVars: options.overwriteCssVars }));
		plugins.push(updateThemePlugin(cssVars));
		if (options.tailwindConfig) {
			plugins.push(updateTailwindConfigPlugin(options.tailwindConfig));
			plugins.push(updateTailwindConfigAnimationPlugin(options.tailwindConfig));
			plugins.push(updateTailwindConfigKeyframesPlugin(options.tailwindConfig));
		}
	}
	if (config.tailwind.cssVariables && options.initIndex) plugins.push(updateBaseLayerPlugin({ tailwindVersion: options.tailwindVersion }));
	const result = await postcss(plugins).process(input, { from: void 0 });
	let output = result.css;
	output = output.replace(/\/\* ---break--- \*\//g, "");
	if (options.tailwindVersion === "v4") output = output.replace(/(\n\s*\n)+/g, "\n\n");
	return output;
}
function updateBaseLayerPlugin({ tailwindVersion }) {
	return {
		postcssPlugin: "update-base-layer",
		Once(root) {
			const requiredRules = [{
				selector: "*",
				apply: tailwindVersion === "v4" ? "border-border outline-ring/50" : "border-border"
			}, {
				selector: "body",
				apply: "bg-background text-foreground"
			}];
			let baseLayer = root.nodes.find((node) => node.type === "atrule" && node.name === "layer" && node.params === "base" && requiredRules.every(({ selector, apply }) => node.nodes?.some((rule) => rule.type === "rule" && rule.selector === selector && rule.nodes.some((applyRule) => applyRule.type === "atrule" && applyRule.name === "apply" && applyRule.params === apply))));
			if (!baseLayer) {
				baseLayer = postcss.atRule({
					name: "layer",
					params: "base",
					raws: {
						semicolon: true,
						between: " ",
						before: "\n"
					}
				});
				root.append(baseLayer);
				root.insertBefore(baseLayer, postcss.comment({ text: "---break---" }));
			}
			requiredRules.forEach(({ selector, apply }) => {
				const existingRule = baseLayer?.nodes?.find((node) => node.type === "rule" && node.selector === selector);
				if (!existingRule) baseLayer?.append(postcss.rule({
					selector,
					nodes: [postcss.atRule({
						name: "apply",
						params: apply,
						raws: {
							semicolon: true,
							before: "\n    "
						}
					})],
					raws: {
						semicolon: true,
						between: " ",
						before: "\n  "
					}
				}));
			});
		}
	};
}
function updateCssVarsPlugin(cssVars) {
	return {
		postcssPlugin: "update-css-vars",
		Once(root) {
			let baseLayer = root.nodes.find((node) => node.type === "atrule" && node.name === "layer" && node.params === "base");
			if (!(baseLayer instanceof AtRule)) {
				baseLayer = postcss.atRule({
					name: "layer",
					params: "base",
					nodes: [],
					raws: {
						semicolon: true,
						before: "\n",
						between: " "
					}
				});
				root.append(baseLayer);
				root.insertBefore(baseLayer, postcss.comment({ text: "---break---" }));
			}
			if (baseLayer !== void 0) Object.entries(cssVars).forEach(([key, vars]) => {
				const selector = key === "light" ? ":root" : `.${key}`;
				addOrUpdateVars(baseLayer, selector, vars);
			});
		}
	};
}
function removeConflictVars(root) {
	const rootRule = root.nodes.find((node) => node.type === "rule" && node.selector === ":root");
	if (rootRule) {
		const propsToRemove = ["--background", "--foreground"];
		rootRule.nodes.filter((node) => node.type === "decl" && propsToRemove.includes(node.prop)).forEach((node) => node.remove());
		if (rootRule.nodes.length === 0) rootRule.remove();
	}
}
function cleanupDefaultNextStylesPlugin() {
	return {
		postcssPlugin: "cleanup-default-next-styles",
		Once(root) {
			const bodyRule = root.nodes.find((node) => node.type === "rule" && node.selector === "body");
			if (bodyRule) {
				bodyRule.nodes.find((node) => node.type === "decl" && node.prop === "color" && ["rgb(var(--foreground-rgb))", "var(--foreground)"].includes(node.value))?.remove();
				bodyRule.nodes.find((node) => {
					return node.type === "decl" && node.prop === "background" && (node.value.startsWith("linear-gradient") || node.value === "var(--background)");
				})?.remove();
				bodyRule.nodes.find((node) => node.type === "decl" && node.prop === "font-family" && node.value === "Arial, Helvetica, sans-serif")?.remove();
				if (bodyRule.nodes.length === 0) bodyRule.remove();
			}
			removeConflictVars(root);
			const darkRootRule = root.nodes.find((node) => node.type === "atrule" && node.params === "(prefers-color-scheme: dark)");
			if (darkRootRule) {
				removeConflictVars(darkRootRule);
				if (darkRootRule.nodes.length === 0) darkRootRule.remove();
			}
		}
	};
}
function addOrUpdateVars(baseLayer, selector, vars) {
	let ruleNode = baseLayer.nodes?.find((node) => node.type === "rule" && node.selector === selector);
	if (!ruleNode) {
		if (Object.keys(vars).length > 0) {
			ruleNode = postcss.rule({
				selector,
				raws: {
					between: " ",
					before: "\n  "
				}
			});
			baseLayer.append(ruleNode);
		}
	}
	Object.entries(vars).forEach(([key, value]) => {
		const prop = `--${key.replace(/^--/, "")}`;
		const newDecl = postcss.decl({
			prop,
			value,
			raws: { semicolon: true }
		});
		const existingDecl = ruleNode?.nodes.find((node) => node.type === "decl" && node.prop === prop);
		existingDecl ? existingDecl.replaceWith(newDecl) : ruleNode?.append(newDecl);
	});
}
function updateCssVarsPluginV4(cssVars, options) {
	return {
		postcssPlugin: "update-css-vars-v4",
		Once(root) {
			Object.entries(cssVars).forEach(([key, vars]) => {
				let selector = key === "light" ? ":root" : `.${key}`;
				if (key === "theme") {
					selector = "@theme";
					const themeNode = upsertThemeNode(root);
					Object.entries(vars).forEach(([key$1, value]) => {
						const prop = `--${key$1.replace(/^--/, "")}`;
						const newDecl = postcss.decl({
							prop,
							value,
							raws: { semicolon: true }
						});
						const existingDecl = themeNode?.nodes?.find((node) => node.type === "decl" && node.prop === prop);
						if (options.overwriteCssVars) if (existingDecl) existingDecl.replaceWith(newDecl);
						else themeNode?.append(newDecl);
						else if (!existingDecl) themeNode?.append(newDecl);
					});
					return;
				}
				let ruleNode = root.nodes?.find((node) => node.type === "rule" && node.selector === selector);
				if (!ruleNode && Object.keys(vars).length > 0) {
					ruleNode = postcss.rule({
						selector,
						nodes: [],
						raws: {
							semicolon: true,
							between: " ",
							before: "\n"
						}
					});
					root.append(ruleNode);
					root.insertBefore(ruleNode, postcss.comment({ text: "---break---" }));
				}
				Object.entries(vars).forEach(([key$1, value]) => {
					let prop = `--${key$1.replace(/^--/, "")}`;
					if (prop === "--sidebar-background") prop = "--sidebar";
					if (isLocalHSLValue(value)) value = `hsl(${value})`;
					const newDecl = postcss.decl({
						prop,
						value,
						raws: { semicolon: true }
					});
					const existingDecl = ruleNode?.nodes.find((node) => node.type === "decl" && node.prop === prop);
					if (options.overwriteCssVars) if (existingDecl) existingDecl.replaceWith(newDecl);
					else ruleNode?.append(newDecl);
					else if (!existingDecl) ruleNode?.append(newDecl);
				});
			});
		}
	};
}
function updateThemePlugin(cssVars) {
	return {
		postcssPlugin: "update-theme",
		Once(root) {
			const variables = Array.from(new Set(Object.keys(cssVars).flatMap((key) => Object.keys(cssVars[key] || {}))));
			if (!variables.length) return;
			const themeNode = upsertThemeNode(root);
			const themeVarNodes = themeNode.nodes?.filter((node) => node.type === "decl" && node.prop.startsWith("--"));
			for (const variable of variables) {
				const value = Object.values(cssVars).find((vars) => vars[variable])?.[variable];
				if (!value) continue;
				if (variable === "radius") {
					const radiusVariables = {
						sm: "calc(var(--radius) - 4px)",
						md: "calc(var(--radius) - 2px)",
						lg: "var(--radius)",
						xl: "calc(var(--radius) + 4px)"
					};
					for (const [key, value$1] of Object.entries(radiusVariables)) {
						const cssVarNode$1 = postcss.decl({
							prop: `--radius-${key}`,
							value: value$1,
							raws: { semicolon: true }
						});
						if (themeNode?.nodes?.find((node) => node.type === "decl" && node.prop === cssVarNode$1.prop)) continue;
						themeNode?.append(cssVarNode$1);
					}
					continue;
				}
				let prop = isLocalHSLValue(value) || isColorValue(value) ? `--color-${variable.replace(/^--/, "")}` : `--${variable.replace(/^--/, "")}`;
				if (prop === "--color-sidebar-background") prop = "--color-sidebar";
				let propValue = `var(--${variable})`;
				if (prop === "--color-sidebar") propValue = "var(--sidebar)";
				const cssVarNode = postcss.decl({
					prop,
					value: propValue,
					raws: { semicolon: true }
				});
				const existingDecl = themeNode?.nodes?.find((node) => node.type === "decl" && node.prop === cssVarNode.prop);
				if (!existingDecl) if (themeVarNodes?.length) themeNode?.insertAfter(themeVarNodes[themeVarNodes.length - 1], cssVarNode);
				else themeNode?.append(cssVarNode);
			}
		}
	};
}
function upsertThemeNode(root) {
	let themeNode = root.nodes.find((node) => node.type === "atrule" && node.name === "theme" && node.params === "inline");
	if (!themeNode) {
		themeNode = postcss.atRule({
			name: "theme",
			params: "inline",
			nodes: [],
			raws: {
				semicolon: true,
				between: " ",
				before: "\n"
			}
		});
		root.append(themeNode);
		root.insertBefore(themeNode, postcss.comment({ text: "---break---" }));
	}
	return themeNode;
}
function addCustomVariant({ params }) {
	return {
		postcssPlugin: "add-custom-variant",
		Once(root) {
			const customVariant = root.nodes.find((node) => node.type === "atrule" && node.name === "custom-variant");
			if (!customVariant) {
				const importNodes = root.nodes.filter((node) => node.type === "atrule" && node.name === "import");
				const variantNode = postcss.atRule({
					name: "custom-variant",
					params,
					raws: {
						semicolon: true,
						before: "\n"
					}
				});
				if (importNodes.length > 0) {
					const lastImport = importNodes[importNodes.length - 1];
					root.insertAfter(lastImport, variantNode);
				} else root.insertAfter(root.nodes[0], variantNode);
				root.insertBefore(variantNode, postcss.comment({ text: "---break---" }));
			}
		}
	};
}
function addCustomImport({ params }) {
	return {
		postcssPlugin: "add-custom-import",
		Once(root) {
			const importNodes = root.nodes.filter((node) => node.type === "atrule" && node.name === "import");
			const customVariantNode = root.nodes.find((node) => node.type === "atrule" && node.name === "custom-variant");
			const hasImport = importNodes.some((node) => node.params.replace(/["']/g, "") === params);
			if (!hasImport) {
				const importNode = postcss.atRule({
					name: "import",
					params: `"${params}"`,
					raws: {
						semicolon: true,
						before: "\n"
					}
				});
				if (importNodes.length > 0) {
					const lastImport = importNodes[importNodes.length - 1];
					root.insertAfter(lastImport, importNode);
				} else if (customVariantNode) {
					root.insertBefore(customVariantNode, importNode);
					root.insertBefore(customVariantNode, postcss.comment({ text: "---break---" }));
				} else {
					root.prepend(importNode);
					root.insertAfter(importNode, postcss.comment({ text: "---break---" }));
				}
			}
		}
	};
}
function updateTailwindConfigPlugin(tailwindConfig) {
	return {
		postcssPlugin: "update-tailwind-config",
		Once(root) {
			if (!tailwindConfig?.plugins) return;
			const quoteType = getQuoteType(root);
			const quote = quoteType === "single" ? "'" : "\"";
			const pluginNodes = root.nodes.filter((node) => node.type === "atrule" && node.name === "plugin");
			const lastPluginNode = pluginNodes[pluginNodes.length - 1] || root.nodes[0];
			for (const plugin of tailwindConfig.plugins) {
				const pluginName = plugin.replace(/^require\(["']|["']\)$/g, "");
				if (pluginNodes.some((node) => {
					return node.params.replace(/["']/g, "") === pluginName;
				})) continue;
				const pluginNode = postcss.atRule({
					name: "plugin",
					params: `${quote}${pluginName}${quote}`,
					raws: {
						semicolon: true,
						before: "\n"
					}
				});
				root.insertAfter(lastPluginNode, pluginNode);
				root.insertBefore(pluginNode, postcss.comment({ text: "---break---" }));
			}
		}
	};
}
function updateTailwindConfigKeyframesPlugin(tailwindConfig) {
	return {
		postcssPlugin: "update-tailwind-config-keyframes",
		Once(root) {
			if (!tailwindConfig?.theme?.extend?.keyframes) return;
			const themeNode = upsertThemeNode(root);
			const existingKeyFrameNodes = themeNode.nodes?.filter((node) => node.type === "atrule" && node.name === "keyframes");
			const keyframeValueSchema = z.record(z.string(), z.record(z.string(), z.string()));
			for (const [keyframeName, keyframeValue] of Object.entries(tailwindConfig.theme.extend.keyframes)) {
				if (typeof keyframeName !== "string") continue;
				const parsedKeyframeValue = keyframeValueSchema.safeParse(keyframeValue);
				if (!parsedKeyframeValue.success) continue;
				if (existingKeyFrameNodes?.find((node) => node.type === "atrule" && node.name === "keyframes" && node.params === keyframeName)) continue;
				const keyframeNode = postcss.atRule({
					name: "keyframes",
					params: keyframeName,
					nodes: [],
					raws: {
						semicolon: true,
						between: " ",
						before: "\n  "
					}
				});
				for (const [key, values] of Object.entries(parsedKeyframeValue.data)) {
					const rule = postcss.rule({
						selector: key,
						nodes: Object.entries(values).map(([key$1, value]) => postcss.decl({
							prop: key$1,
							value,
							raws: {
								semicolon: true,
								before: "\n      ",
								between: ": "
							}
						})),
						raws: {
							semicolon: true,
							between: " ",
							before: "\n    "
						}
					});
					keyframeNode.append(rule);
				}
				themeNode.append(keyframeNode);
				themeNode.insertBefore(keyframeNode, postcss.comment({ text: "---break---" }));
			}
		}
	};
}
function updateTailwindConfigAnimationPlugin(tailwindConfig) {
	return {
		postcssPlugin: "update-tailwind-config-animation",
		Once(root) {
			if (!tailwindConfig?.theme?.extend?.animation) return;
			const themeNode = upsertThemeNode(root);
			const existingAnimationNodes = themeNode.nodes?.filter((node) => node.type === "decl" && node.prop.startsWith("--animate-"));
			const parsedAnimationValue = z.record(z.string(), z.string()).safeParse(tailwindConfig.theme.extend.animation);
			if (!parsedAnimationValue.success) return;
			for (const [key, value] of Object.entries(parsedAnimationValue.data)) {
				const prop = `--animate-${key}`;
				if (existingAnimationNodes?.find((node) => node.prop === prop)) continue;
				const animationNode = postcss.decl({
					prop,
					value,
					raws: {
						semicolon: true,
						between: ": ",
						before: "\n  "
					}
				});
				themeNode.append(animationNode);
			}
		}
	};
}
function getQuoteType(root) {
	const firstNode = root.nodes[0];
	const raw = firstNode.toString();
	if (raw.includes("'")) return "single";
	return "double";
}
function isLocalHSLValue(value) {
	if (value.startsWith("hsl") || value.startsWith("rgb") || value.startsWith("#") || value.startsWith("oklch")) return false;
	const chunks = value.split(" ");
	return chunks.length === 3 && chunks.slice(1, 3).every((chunk) => chunk.includes("%"));
}
function isColorValue(value) {
	return value.startsWith("hsl") || value.startsWith("rgb") || value.startsWith("#") || value.startsWith("oklch");
}

//#endregion
//#region src/utils/updaters/update-dependencies.ts
async function updateDependencies(dependencies$1, config, options) {
	dependencies$1 = Array.from(new Set(dependencies$1));
	if (!dependencies$1?.length) return;
	options = {
		silent: false,
		...options
	};
	const dependenciesSpinner = spinner(`Installing dependencies.`, { silent: options.silent })?.start();
	dependenciesSpinner?.start();
	await addDependency(dependencies$1, {
		cwd: config.resolvedPaths.cwd,
		silent: true,
		dev: options?.dev
	});
	dependenciesSpinner?.succeed();
}

//#endregion
//#region src/utils/transformers/transform-css-vars.ts
function transformCssVars(opts) {
	return {
		type: "codemod",
		name: "add prefix to tailwind classes",
		transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST } }) {
			let transformCount = 0;
			const { baseColor, config } = opts;
			if (config.tailwind?.cssVariables || !baseColor?.inlineColors) return transformCount;
			for (const scriptAST of scriptASTs) traverseScriptAST(scriptAST, { visitLiteral(path$2) {
				if (path$2.parent.value.type !== "ImportDeclaration" && typeof path$2.node.value === "string") {
					path$2.node.value = applyColorMapping(path$2.node.value.replace(/"/g, ""), baseColor.inlineColors);
					transformCount++;
				}
				return this.traverse(path$2);
			} });
			if (sfcAST) traverseTemplateAST(sfcAST, {
				enterNode(node) {
					if (node.type === "Literal" && typeof node.value === "string") {
						if (!["BinaryExpression", "Property"].includes(node.parent?.type ?? "")) {
							node.value = applyColorMapping(node.value.replace(/"/g, ""), baseColor.inlineColors);
							transformCount++;
						}
					} else if (node.type === "VLiteral" && typeof node.value === "string") {
						if (node.parent.key.name === "class") {
							node.value = `"${applyColorMapping(node.value.replace(/"/g, ""), baseColor.inlineColors)}"`;
							transformCount++;
						}
					}
				},
				leaveNode() {}
			});
			return transformCount;
		}
	};
}
function splitClassName(className) {
	if (!className.includes("/") && !className.includes(":")) return [
		null,
		className,
		null
	];
	const parts = [];
	const [rest, alpha] = className.split("/");
	if (!rest.includes(":")) return [
		null,
		rest,
		alpha
	];
	const split = rest.split(":");
	const name$1 = split.pop();
	const variant = split.join(":");
	parts.push(variant ?? null, name$1 ?? null, alpha ?? null);
	return parts;
}
const PREFIXES = [
	"bg-",
	"text-",
	"border-",
	"ring-offset-",
	"ring-"
];
function applyColorMapping(input, mapping) {
	if (input.includes(" border ")) input = input.replace(" border ", " border border-border ");
	const classNames = input.split(" ");
	const lightMode = new Set();
	const darkMode = new Set();
	for (const className of classNames) {
		const [variant, value, modifier] = splitClassName(className);
		const prefix = PREFIXES.find((prefix$1) => value?.startsWith(prefix$1));
		if (!prefix) {
			if (!lightMode.has(className)) lightMode.add(className);
			continue;
		}
		const needle = value?.replace(prefix, "");
		if (needle && needle in mapping.light) {
			lightMode.add([variant, `${prefix}${mapping.light[needle]}`].filter(Boolean).join(":") + (modifier ? `/${modifier}` : ""));
			darkMode.add([
				"dark",
				variant,
				`${prefix}${mapping.dark[needle]}`
			].filter(Boolean).join(":") + (modifier ? `/${modifier}` : ""));
			continue;
		}
		if (!lightMode.has(className)) lightMode.add(className);
	}
	return [...Array.from(lightMode), ...Array.from(darkMode)].join(" ").trim();
}

//#endregion
//#region src/utils/transformers/transform-import.ts
function transformImport(opts) {
	return {
		type: "codemod",
		name: "modify import based on user config",
		transform({ scriptASTs, utils: { traverseScriptAST } }) {
			const transformCount = 0;
			const { config, isRemote } = opts;
			const utilsImport = "@/lib/utils";
			for (const scriptAST of scriptASTs) traverseScriptAST(scriptAST, { visitImportDeclaration(path$2) {
				if (typeof path$2.node.source.value === "string") {
					const sourcePath = path$2.node.source.value;
					const updatedImport = updateImportAliases(sourcePath, config, isRemote);
					path$2.node.source.value = updatedImport;
					if (updatedImport === utilsImport) {
						const namedImports = path$2.node.specifiers?.map((node) => node.local?.name ?? "") ?? [];
						const cnImport = namedImports.find((i) => i === "cn");
						if (cnImport) path$2.node.source.value = updatedImport === utilsImport ? sourcePath.replace(utilsImport, config.aliases.utils) : config.aliases.utils;
					}
				}
				return this.traverse(path$2);
			} });
			return transformCount;
		}
	};
}
function updateImportAliases(moduleSpecifier, config, isRemote = false) {
	if (!moduleSpecifier.startsWith("@/") && !isRemote) return moduleSpecifier;
	if (isRemote && moduleSpecifier.startsWith("@/")) moduleSpecifier = moduleSpecifier.replace(/^@\//, `@/registry/new-york/`);
	if (!moduleSpecifier.startsWith("@/registry/")) {
		const alias = config.aliases.components.split("/")[0];
		return moduleSpecifier.replace(/^@\//, `${alias}/`);
	}
	if (moduleSpecifier.match(/^@\/registry\/(.+)\/ui/)) return moduleSpecifier.replace(/^@\/registry\/(.+)\/ui/, config.aliases.ui ?? `${config.aliases.components}/ui`);
	if (config.aliases.components && moduleSpecifier.match(/^@\/registry\/(.+)\/components/)) return moduleSpecifier.replace(/^@\/registry\/(.+)\/components/, config.aliases.components);
	if (config.aliases.lib && moduleSpecifier.match(/^@\/registry\/(.+)\/lib/)) return moduleSpecifier.replace(/^@\/registry\/(.+)\/lib/, config.aliases.lib);
	if (config.aliases.composables && moduleSpecifier.match(/^@\/registry\/(.+)\/composables/)) return moduleSpecifier.replace(/^@\/registry\/(.+)\/composables/, config.aliases.composables);
	return moduleSpecifier.replace(/^@\/registry\/[^/]+/, config.aliases.components);
}

//#endregion
//#region src/utils/transformers/transform-sfc.ts
async function transformSFC(opts) {
	if (opts.config?.typescript) return opts.raw;
	return await transformByDetype(opts.raw, opts.filename).then((res) => res);
}
async function transformByDetype(content, filename) {
	return await transform$1(content, filename, {
		removeTsComments: true,
		prettierOptions: { proseWrap: "never" }
	});
}

//#endregion
//#region src/utils/transformers/transform-tw-prefix.ts
async function transformTwPrefix(opts) {
	const tailwindVersion = await getProjectTailwindVersionFromConfig(opts.config);
	return {
		type: "codemod",
		name: "add prefix to tailwind classes",
		transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST, astHelpers } }) {
			let transformCount = 0;
			const { config } = opts;
			if (!config.tailwind?.prefix) return transformCount;
			function isVariantProperty(node) {
				if (node.type === "Property") {
					if (node.key?.type === "Identifier") {
						const keyName = node.key.name;
						return [
							"variant",
							"size",
							"color",
							"type",
							"state"
						].includes(keyName);
					}
					if (node.key?.type === "Literal" && typeof node.key.value === "string") {
						const keyName = node.key.value;
						return [
							"variant",
							"size",
							"color",
							"type",
							"state"
						].includes(keyName);
					}
				}
				return false;
			}
			function traverseExpression(expression) {
				if (expression.type === "CallExpression" && expression.callee?.type === "Identifier" && expression.callee.name === "cn") expression.arguments.forEach((arg) => {
					if (arg.type === "Literal" && typeof arg.value === "string") {
						arg.value = applyPrefix(arg.value, config.tailwind.prefix, tailwindVersion);
						transformCount++;
					} else if (arg.type === "ConditionalExpression") {
						if (arg.consequent?.type === "Literal" && typeof arg.consequent.value === "string") {
							arg.consequent.value = applyPrefix(arg.consequent.value, config.tailwind.prefix, tailwindVersion);
							transformCount++;
						}
						if (arg.alternate?.type === "Literal" && typeof arg.alternate.value === "string") {
							arg.alternate.value = applyPrefix(arg.alternate.value, config.tailwind.prefix, tailwindVersion);
							transformCount++;
						}
					} else if (arg.type === "BinaryExpression") {
						if (arg.right?.type === "Literal" && typeof arg.right.value === "string") {
							arg.right.value = applyPrefix(arg.right.value, config.tailwind.prefix, tailwindVersion);
							transformCount++;
						}
					} else if (arg.type === "ObjectExpression") arg.properties.forEach((prop) => {
						if (prop.type === "Property" && prop.value?.type === "Literal" && typeof prop.value.value === "string") {
							if (!isVariantProperty(prop)) {
								prop.value.value = applyPrefix(prop.value.value, config.tailwind.prefix, tailwindVersion);
								transformCount++;
							}
						}
					});
					else {
						const literals = astHelpers.findAll(arg, { type: "Literal" });
						literals.forEach((literal) => {
							if (typeof literal.value === "string") {
								let shouldTransform = true;
								let parent = literal.parent;
								while (parent) {
									if (isVariantProperty(parent)) {
										shouldTransform = false;
										break;
									}
									parent = parent.parent;
								}
								if (shouldTransform) {
									literal.value = applyPrefix(literal.value, config.tailwind.prefix, tailwindVersion);
									transformCount++;
								}
							}
						});
					}
				});
				else if (expression.type === "ConditionalExpression") {
					if (expression.consequent) traverseExpression(expression.consequent);
					if (expression.alternate) traverseExpression(expression.alternate);
				} else if (expression.type === "BinaryExpression") {
					if (expression.left) traverseExpression(expression.left);
					if (expression.right) traverseExpression(expression.right);
				}
			}
			for (const scriptAST of scriptASTs) traverseScriptAST(scriptAST, { visitCallExpression(path$2) {
				if (path$2.node.callee.type === "Identifier" && path$2.node.callee.name === "cva") {
					const args = path$2.node.arguments;
					if (args[0]?.type === "Literal" && typeof args[0].value === "string") {
						args[0].value = applyPrefix(args[0].value, config.tailwind.prefix, tailwindVersion);
						transformCount++;
					}
					if (args[1]?.type === "ObjectExpression") {
						const variantsProperty = args[1].properties.find((prop) => prop.type === "Property" && prop.key.type === "Identifier" && prop.key.name === "variants");
						if (variantsProperty && variantsProperty.type === "Property" && variantsProperty.value.type === "ObjectExpression") {
							const allProperties = astHelpers.findAll(variantsProperty.value, { type: "Property" });
							allProperties.forEach((prop) => {
								if (prop.value?.type === "Literal" && typeof prop.value.value === "string") {
									prop.value.value = applyPrefix(prop.value.value, config.tailwind.prefix, tailwindVersion);
									transformCount++;
								}
							});
						}
					}
				}
				if (path$2.node.callee.type === "Identifier" && path$2.node.callee.name === "cn") path$2.node.arguments.forEach((arg) => {
					if (arg.type === "Literal" && typeof arg.value === "string") {
						arg.value = applyPrefix(arg.value, config.tailwind.prefix, tailwindVersion);
						transformCount++;
					} else if (arg.type === "ConditionalExpression") {
						if (arg.consequent?.type === "Literal" && typeof arg.consequent.value === "string") {
							arg.consequent.value = applyPrefix(arg.consequent.value, config.tailwind.prefix, tailwindVersion);
							transformCount++;
						}
						if (arg.alternate?.type === "Literal" && typeof arg.alternate.value === "string") {
							arg.alternate.value = applyPrefix(arg.alternate.value, config.tailwind.prefix, tailwindVersion);
							transformCount++;
						}
					} else if (arg.type === "BinaryExpression") {
						if (arg.right?.type === "Literal" && typeof arg.right.value === "string") {
							arg.right.value = applyPrefix(arg.right.value, config.tailwind.prefix, tailwindVersion);
							transformCount++;
						}
					} else if (arg.type === "ObjectExpression") arg.properties.forEach((prop) => {
						if (prop.type === "Property" && prop.value?.type === "Literal" && typeof prop.value.value === "string") {
							if (!isVariantProperty(prop)) {
								prop.value.value = applyPrefix(prop.value.value, config.tailwind.prefix, tailwindVersion);
								transformCount++;
							}
						}
					});
					else {
						const literals = astHelpers.findAll(arg, { type: "Literal" });
						literals.forEach((literal) => {
							if (typeof literal.value === "string") {
								let shouldTransform = true;
								let parent = literal.parent;
								while (parent) {
									if (isVariantProperty(parent)) {
										shouldTransform = false;
										break;
									}
									parent = parent.parent;
								}
								if (shouldTransform) {
									literal.value = applyPrefix(literal.value, config.tailwind.prefix, tailwindVersion);
									transformCount++;
								}
							}
						});
					}
				});
				return this.traverse(path$2);
			} });
			if (sfcAST) traverseTemplateAST(sfcAST, {
				enterNode(node) {
					if (node.type === "VAttribute" && node.key.type === "VDirectiveKey") {
						if (node.key.argument?.type === "VIdentifier") {
							const argName = node.key.argument.name;
							if ([
								"class",
								"className",
								"classes",
								"classNames"
							].includes(argName)) {
								if (node.value?.type === "VExpressionContainer" && node.value.expression) traverseExpression(node.value.expression);
							}
						}
					} else if (node.type === "VLiteral" && typeof node.value === "string") {
						if (node.parent?.type === "VAttribute" && node.parent.key?.type === "VIdentifier" && [
							"class",
							"className",
							"classes",
							"classNames"
						].includes(node.parent.key.name)) {
							const cleanValue = node.value.replace(/"/g, "");
							const prefixedValue = applyPrefix(cleanValue, config.tailwind.prefix, tailwindVersion);
							node.value = `"${prefixedValue}"`;
							transformCount++;
						}
					}
				},
				leaveNode() {}
			});
			return transformCount;
		}
	};
}
function applyPrefix(input, prefix = "", tailwindVersion) {
	if (tailwindVersion === "v3") return input.split(" ").map((className) => {
		const [variant, value, modifier] = splitClassName(className);
		if (variant) return modifier ? `${variant}:${prefix}${value}/${modifier}` : `${variant}:${prefix}${value}`;
		else return modifier ? `${prefix}${value}/${modifier}` : `${prefix}${value}`;
	}).join(" ");
	return input.split(" ").map((className) => className.indexOf(`${prefix}:`) === 0 ? className : `${prefix}:${className.trim()}`).join(" ");
}

//#endregion
//#region src/utils/icon-libraries.ts
const ICON_LIBRARIES = {
	lucide: {
		name: "lucide-vue-next",
		package: "lucide-vue-next",
		import: "lucide-vue-next"
	},
	radix: {
		name: "@radix-icons/vue",
		package: "@radix-icons/vue",
		import: "@radix-icons/vue"
	}
};

//#endregion
//#region src/utils/transformers/transform-icons.ts
const SOURCE_LIBRARY = "lucide";
function transformIcons(opts, registryIcons) {
	return {
		type: "codemod",
		name: "modify import of icon library on user config",
		transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST } }) {
			let transformCount = 0;
			const { config } = opts;
			if (!config.iconLibrary || !(config.iconLibrary in ICON_LIBRARIES)) return transformCount;
			const sourceLibrary = SOURCE_LIBRARY;
			const targetLibrary = config.iconLibrary;
			if (sourceLibrary === targetLibrary) return transformCount;
			const targetedIconsMap = new Map();
			for (const scriptAST of scriptASTs) {
				traverseScriptAST(scriptAST, { visitImportDeclaration(path$2) {
					if (![ICON_LIBRARIES.radix.import, ICON_LIBRARIES.lucide.import].includes(`${path$2.node.source.value}`)) return this.traverse(path$2);
					for (const specifier of path$2.node.specifiers ?? []) if (specifier.type === "ImportSpecifier") {
						const iconName = specifier.imported.name;
						const targetedIcon = registryIcons[iconName]?.[targetLibrary];
						if (!targetedIcon || targetedIconsMap.has(targetedIcon)) continue;
						targetedIconsMap.set(iconName, targetedIcon);
						specifier.imported.name = targetedIcon;
					}
					if (targetedIconsMap.size > 0) path$2.node.source.value = ICON_LIBRARIES[targetLibrary].import;
					return this.traverse(path$2);
				} });
				if (sfcAST) traverseTemplateAST(sfcAST, { enterNode(node) {
					if (node.type === "VElement" && targetedIconsMap.has(node.rawName)) {
						node.rawName = targetedIconsMap.get(node.rawName) ?? "";
						transformCount++;
					}
				} });
			}
			return transformCount;
		}
	};
}

//#endregion
//#region src/utils/transformers/index.ts
async function transform$2(opts) {
	const source = await transformSFC(opts);
	const registryIcons = await getRegistryIcons();
	return transform(source, opts.filename, [
		transformImport(opts),
		transformCssVars(opts),
		await transformTwPrefix(opts),
		transformIcons(opts, registryIcons)
	]).code;
}

//#endregion
//#region src/utils/updaters/update-files.ts
async function updateFiles(files$1, config, options) {
	if (!files$1?.length) return {
		filesCreated: [],
		filesUpdated: [],
		filesSkipped: []
	};
	options = {
		overwrite: false,
		force: false,
		silent: false,
		isRemote: false,
		...options
	};
	const filesCreatedSpinner = spinner(`Updating files.`, { silent: options.silent })?.start();
	const [projectInfo, baseColor] = await Promise.all([getProjectInfo(config.resolvedPaths.cwd), getRegistryBaseColor(config.tailwind.baseColor)]);
	let filesCreated = [];
	let filesUpdated = [];
	let filesSkipped = [];
	const folderSkipped = new Map();
	let tempRoot = "";
	if (!config.typescript) {
		for (const file of files$1) {
			if (!file.content) continue;
			const dirName = path.dirname(file.path);
			tempRoot = path.join(tmpdir(), "shadcn-vue");
			const tempDir = path.join(tempRoot, "registry", config.style, dirName);
			const tempPath = path.join(tempRoot, "registry", config.style, file.path);
			await promises.mkdir(tempDir, { recursive: true });
			await promises.writeFile(tempPath, file.content, "utf-8");
		}
		await promises.cp(path.join(process.cwd(), "node_modules"), tempRoot, {
			recursive: true,
			filter: (src) => !src.includes("/.bin/")
		});
		await promises.writeFile(path.join(tempRoot, "tsconfig.json"), `{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    },
  },
  "include": ["**/*.vue", "**/*.ts"],
  "exclude": ["node_modules"]
}`, "utf8");
	}
	for (const file of files$1) {
		if (!file.content) continue;
		let filePath = resolveFilePath(file, config, {
			framework: projectInfo?.framework.name,
			commonRoot: findCommonRoot$1(files$1.map((f) => f.path), file.path)
		});
		if (!filePath) continue;
		const fileName = basename(file.path);
		const targetDir = path.dirname(filePath);
		if (!config.typescript) filePath = filePath.replace(/\.ts?$/, (match) => ".js");
		const existingFile = existsSync(filePath);
		const content = await transform$2({
			filename: path.join(tempRoot, "registry", config.style, file.path),
			raw: file.content,
			config,
			baseColor,
			isRemote: options.isRemote
		});
		if (existingFile) {
			const existingFileContent = await promises.readFile(filePath, "utf-8");
			const [normalizedExisting, normalizedNew] = await Promise.all([getNormalizedFileContent(existingFileContent), getNormalizedFileContent(content)]);
			if (normalizedExisting === normalizedNew) {
				filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath));
				continue;
			}
		}
		if (file.type === "registry:ui") {
			const folderName = basename(dirname(filePath));
			const existingFolder = existsSync(dirname(filePath));
			if (!existingFolder) folderSkipped.set(folderName, false);
			if (!folderSkipped.has(folderName) && !options.overwrite) {
				filesCreatedSpinner.stop();
				const { overwrite } = await prompts({
					type: "confirm",
					name: "overwrite",
					message: `The folder ${highlighter.info(folderName)} already exists. Would you like to overwrite?`,
					initial: false
				});
				folderSkipped.set(folderName, !overwrite);
				filesCreatedSpinner?.start();
			}
			if (folderSkipped.get(folderName) === true) {
				filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath));
				continue;
			}
		} else if (existingFile && !options.overwrite) {
			filesCreatedSpinner.stop();
			if (options.rootSpinner) options.rootSpinner.stop();
			const { overwrite } = await prompts({
				type: "confirm",
				name: "overwrite",
				message: `The file ${highlighter.info(fileName)} already exists. Would you like to overwrite?`,
				initial: false
			});
			if (!overwrite) {
				filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath));
				if (options.rootSpinner) options.rootSpinner.start();
				continue;
			}
			filesCreatedSpinner?.start();
			if (options.rootSpinner) options.rootSpinner.start();
		}
		if (!existsSync(targetDir)) await promises.mkdir(targetDir, { recursive: true });
		await promises.writeFile(filePath, content, "utf-8");
		existingFile ? filesUpdated.push(path.relative(config.resolvedPaths.cwd, filePath)) : filesCreated.push(path.relative(config.resolvedPaths.cwd, filePath));
	}
	const allFiles = [
		...filesCreated,
		...filesUpdated,
		...filesSkipped
	];
	const updatedFiles = await resolveImports(allFiles, config);
	filesUpdated.push(...updatedFiles);
	filesUpdated = filesUpdated.filter((file) => !filesCreated.includes(file));
	const hasUpdatedFiles = filesCreated.length || filesUpdated.length;
	if (!hasUpdatedFiles && !filesSkipped.length) filesCreatedSpinner?.info("No files updated.");
	filesCreated = Array.from(new Set(filesCreated));
	filesUpdated = Array.from(new Set(filesUpdated));
	filesSkipped = Array.from(new Set(filesSkipped));
	if (filesCreated.length) {
		filesCreatedSpinner?.succeed(`Created ${filesCreated.length} ${filesCreated.length === 1 ? "file" : "files"}:`);
		if (!options.silent) for (const file of filesCreated) logger.log(`  - ${file}`);
	} else filesCreatedSpinner?.stop();
	if (filesUpdated.length) {
		spinner(`Updated ${filesUpdated.length} ${filesUpdated.length === 1 ? "file" : "files"}:`, { silent: options.silent })?.info();
		if (!options.silent) for (const file of filesUpdated) logger.log(`  - ${file}`);
	}
	if (filesSkipped.length) {
		spinner(`Skipped ${filesSkipped.length} ${filesSkipped.length === 1 ? "file" : "files"}: (files might be identical, use --overwrite to overwrite)`, { silent: options.silent })?.info();
		if (!options.silent) for (const file of filesSkipped) logger.log(`  - ${file}`);
	}
	if (!options.silent) logger.break();
	return {
		filesCreated,
		filesUpdated,
		filesSkipped
	};
}
function resolveFilePath(file, config, options) {
	if (file.target) {
		if (file.target.startsWith("~/")) return path.join(config.resolvedPaths.cwd, file.target.replace("~/", ""));
		let target = file.target;
		if (file.type === "registry:page") {
			target = resolvePageTarget(target, options.framework);
			if (!target) return "";
		}
		return path.join(config.resolvedPaths.cwd, target.replace("src/", ""));
	}
	const targetDir = resolveFileTargetDirectory(file, config);
	const relativePath = resolveNestedFilePath(file.path, targetDir);
	return path.join(targetDir, relativePath);
}
function resolveFileTargetDirectory(file, config) {
	if (file.type === "registry:ui") return config.resolvedPaths.ui;
	if (file.type === "registry:lib") return config.resolvedPaths.lib;
	if (file.type === "registry:block" || file.type === "registry:component") return config.resolvedPaths.components;
	if (file.type === "registry:hook" || file.type === "registry:composable") return config.resolvedPaths.composables;
	return config.resolvedPaths.components;
}
function findCommonRoot$1(paths, needle) {
	const normalizedPaths = paths.map((p) => p.replace(/^\//, ""));
	const normalizedNeedle = needle.replace(/^\//, "");
	const needleDir = normalizedNeedle.split("/").slice(0, -1).join("/");
	if (!needleDir) return "";
	const needleSegments = needleDir.split("/");
	for (let i = needleSegments.length; i > 0; i--) {
		const testPath = needleSegments.slice(0, i).join("/");
		const hasRelatedPaths = normalizedPaths.some((path$2) => path$2 !== normalizedNeedle && path$2.startsWith(`${testPath}/`));
		if (hasRelatedPaths) return `/${testPath}`;
	}
	return `/${needleDir}`;
}
function resolveNestedFilePath(filePath, targetDir) {
	const normalizedFilePath = filePath.replace(/^\/|\/$/g, "");
	const normalizedTargetDir = targetDir.replace(/^\/|\/$/g, "");
	const fileSegments = normalizedFilePath.split("/");
	const targetSegments = normalizedTargetDir.split("/");
	const lastTargetSegment = targetSegments[targetSegments.length - 1];
	const commonDirIndex = fileSegments.findIndex((segment) => segment === lastTargetSegment);
	if (commonDirIndex === -1) return fileSegments[fileSegments.length - 1];
	return fileSegments.slice(commonDirIndex + 1).join("/");
}
async function getNormalizedFileContent(content) {
	return content.replace(/\r\n/g, "\n").trim();
}
function resolvePageTarget(target, framework) {
	if (!framework) return "";
	if (framework === "nuxt") return target;
	if (framework === "laravel") {
		let result = target.replace(/^app\//, "resources/js/pages/");
		result = result.replace(/\/page(\.[jt]sx?)$/, "$1");
		return result;
	}
	return "";
}
async function resolveImports(filePaths, config) {
	const projectInfo = await getProjectInfo(config.resolvedPaths.cwd);
	const tsConfig = await getTSConfig(config.resolvedPaths.cwd, projectInfo?.typescript ? "tsconfig.json" : "jsconfig.json");
	const updatedFiles = [];
	if (!projectInfo || tsConfig === null) return [];
	for (const filepath of filePaths) {
		const resolvedPath = path.resolve(config.resolvedPaths.cwd, filepath);
		if (!existsSync(resolvedPath)) continue;
		const content = await promises.readFile(resolvedPath, "utf-8");
		try {
			const importResolverTransformer = (opts) => ({
				name: "import-resolver",
				transform(node) {
					if (node.type === "ImportDeclaration" && node.source?.value) {
						const moduleSpecifier = node.source.value;
						if (projectInfo?.aliasPrefix && !moduleSpecifier.startsWith(`${projectInfo.aliasPrefix}/`)) return;
						const probableImportFilePath = resolveImportSync(moduleSpecifier, tsConfig);
						if (!probableImportFilePath) return;
						const resolvedImportFilePath = resolveModuleByProbablePath(probableImportFilePath, filePaths, config);
						if (!resolvedImportFilePath) return;
						const newImport = toAliasedImport(resolvedImportFilePath, config, projectInfo);
						if (!newImport || newImport === moduleSpecifier) return;
						node.source.value = newImport;
						node.source.raw = `'${newImport}'`;
					}
				}
			});
			const result = transform(content, resolvedPath, [importResolverTransformer({})]);
			if (result.code !== content) {
				await promises.writeFile(resolvedPath, result.code, "utf-8");
				updatedFiles.push(filepath);
			}
		} catch (error) {
			console.warn(`Failed to transform imports in ${filepath}:`, error);
		}
	}
	return updatedFiles;
}
function resolveImportSync(moduleSpecifier, tsConfig) {
	if (!tsConfig?.compilerOptions?.paths) return null;
	const { baseUrl = "", paths } = tsConfig.compilerOptions;
	for (const [alias, pathList] of Object.entries(paths)) if (typeof alias === "string" && Array.isArray(pathList)) {
		const aliasPattern = alias.replace("/*", "");
		if (moduleSpecifier.startsWith(aliasPattern)) {
			const relativePath = moduleSpecifier.replace(aliasPattern, "");
			const basePath = pathList[0]?.replace("/*", "") || "";
			return path.resolve(baseUrl, basePath, relativePath);
		}
	}
	return null;
}
/**
* Given an absolute "probable" import path (no ext),
* plus an array of absolute file paths you already know about,
* return 0N matches (best match first), and also check disk for any missing ones.
*/
function resolveModuleByProbablePath(probableImportFilePath, files$1, config, extensions = [
	".vue",
	".ts",
	".js",
	".css"
]) {
	const cwd = path.normalize(config.resolvedPaths.cwd);
	const relativeFiles = files$1.map((f) => f.split(path.sep).join(path.posix.sep));
	const fileSet = new Set(relativeFiles);
	const extInPath = path.extname(probableImportFilePath);
	const hasExt = extInPath !== "";
	const absBase = hasExt ? probableImportFilePath.slice(0, -extInPath.length) : probableImportFilePath;
	const relBaseRaw = path.relative(cwd, absBase);
	const relBase = relBaseRaw.split(path.sep).join(path.posix.sep);
	const tryExts = hasExt ? [extInPath] : extensions;
	const candidates = new Set();
	for (const e of tryExts) {
		const absCand = absBase + e;
		const relCand = path.posix.normalize(path.relative(cwd, absCand));
		if (fileSet.has(relCand) || existsSync(absCand)) candidates.add(relCand);
		const absIdx = path.join(absBase, `index${e}`);
		const relIdx = path.posix.normalize(path.relative(cwd, absIdx));
		if (fileSet.has(relIdx) || existsSync(absIdx)) candidates.add(relIdx);
	}
	const name$1 = path.basename(absBase);
	for (const f of relativeFiles) if (tryExts.some((e) => f.endsWith(`/${name$1}${e}`))) candidates.add(f);
	if (candidates.size === 0) return null;
	const sorted = Array.from(candidates).sort((a, b) => {
		const aExt = path.posix.extname(a);
		const bExt = path.posix.extname(b);
		const ord = tryExts.indexOf(aExt) - tryExts.indexOf(bExt);
		if (ord !== 0) return ord;
		const aStrong = relBase && a.startsWith(relBase) ? -1 : 1;
		const bStrong = relBase && b.startsWith(relBase) ? -1 : 1;
		return aStrong - bStrong;
	});
	return sorted[0];
}
function toAliasedImport(filePath, config, projectInfo) {
	const abs = path.normalize(path.join(config.resolvedPaths.cwd, filePath));
	const matches = Object.entries(config.resolvedPaths).filter(([, root]) => root && abs.startsWith(path.normalize(root + path.sep))).sort((a, b) => b[1].length - a[1].length);
	if (matches.length === 0) return null;
	const [aliasKey, rootDir] = matches[0];
	let rel = path.relative(rootDir, abs);
	rel = rel.split(path.sep).join("/");
	const ext = path.posix.extname(rel);
	const codeExts = [
		".ts",
		".vue",
		".js"
	];
	const keepExt = codeExts.includes(ext) ? "" : ext;
	let noExt = rel.slice(0, rel.length - ext.length);
	if (noExt.endsWith("/index")) noExt = noExt.slice(0, -6);
	const aliasBase = aliasKey === "cwd" ? projectInfo.aliasPrefix : config.aliases[aliasKey];
	if (!aliasBase) return null;
	let suffix = noExt === "" ? "" : `/${noExt}`;
	suffix = suffix.replace("/src", "");
	return `${aliasBase}${suffix}${keepExt}`;
}

//#endregion
//#region src/utils/add-components.ts
async function addComponents(components, config, options) {
	options = {
		overwrite: false,
		silent: false,
		isNewProject: false,
		style: "index",
		...options
	};
	const workspaceConfig = await getWorkspaceConfig(config);
	if (workspaceConfig && workspaceConfig.ui && workspaceConfig.ui.resolvedPaths.cwd !== config.resolvedPaths.cwd) return await addWorkspaceComponents(components, config, workspaceConfig, {
		...options,
		isRemote: components?.length === 1 && !!components[0].match(/\/chat\/b\//)
	});
	return await addProjectComponents(components, config, options);
}
async function addProjectComponents(components, config, options) {
	const registrySpinner = spinner(`Checking registry.`, { silent: options.silent })?.start();
	const tree = await registryResolveItemsTree(components, config);
	if (!tree) {
		registrySpinner?.fail();
		return handleError(new Error("Failed to fetch components from registry."));
	}
	registrySpinner?.succeed();
	const tailwindVersion = await getProjectTailwindVersionFromConfig(config);
	await updateTailwindConfig(tree.tailwind?.config, config, {
		silent: options.silent,
		tailwindVersion
	});
	const overwriteCssVars = await shouldOverwriteCssVars(components, config);
	await updateCssVars(tree.cssVars, config, {
		cleanupDefaultNextStyles: options.isNewProject,
		silent: options.silent,
		tailwindVersion,
		tailwindConfig: tree.tailwind?.config,
		overwriteCssVars,
		initIndex: options.style ? options.style === "index" : false
	});
	await updateCss(tree.css, config, { silent: options.silent });
	await updateDependencies(tree.dependencies, config, { silent: options.silent });
	await updateFiles(tree.files, config, {
		overwrite: options.overwrite,
		silent: options.silent
	});
	if (tree.docs) logger.info(tree.docs);
}
async function addWorkspaceComponents(components, config, workspaceConfig, options) {
	const registrySpinner = spinner(`Checking registry.`, { silent: options.silent })?.start();
	let registryItems = await resolveRegistryItems(components, config);
	let result = await fetchRegistry(registryItems);
	const payload = z.array(registryItemSchema).parse(result);
	if (!payload) {
		registrySpinner?.fail();
		return handleError(new Error("Failed to fetch components from registry."));
	}
	registrySpinner?.succeed();
	const registryParentMap = getRegistryParentMap(payload);
	const registryTypeAliasMap = getRegistryTypeAliasMap();
	const filesCreated = [];
	const filesUpdated = [];
	const filesSkipped = [];
	const rootSpinner = spinner(`Installing components.`)?.start();
	for (const component of payload) {
		const alias = registryTypeAliasMap.get(component.type);
		const registryParent = registryParentMap.get(component.name);
		if (!alias) continue;
		let targetConfig = component.type === "registry:ui" || registryParent?.type === "registry:ui" ? workspaceConfig.ui : config;
		const tailwindVersion = await getProjectTailwindVersionFromConfig(targetConfig);
		const workspaceRoot = findCommonRoot(config.resolvedPaths.cwd, targetConfig.resolvedPaths.ui);
		const packageRoot = await findPackageRoot(workspaceRoot, targetConfig.resolvedPaths.cwd) ?? targetConfig.resolvedPaths.cwd;
		if (component.tailwind?.config) {
			await updateTailwindConfig(component.tailwind?.config, targetConfig, {
				silent: true,
				tailwindVersion
			});
			filesUpdated.push(path.relative(workspaceRoot, targetConfig.resolvedPaths.tailwindConfig));
		}
		if (component.cssVars) {
			const overwriteCssVars = await shouldOverwriteCssVars(components, config);
			await updateCssVars(component.cssVars, targetConfig, {
				silent: true,
				tailwindVersion,
				tailwindConfig: component.tailwind?.config,
				overwriteCssVars
			});
			filesUpdated.push(path.relative(workspaceRoot, targetConfig.resolvedPaths.tailwindCss));
		}
		if (component.css) {
			await updateCss(component.css, targetConfig, { silent: true });
			filesUpdated.push(path.relative(workspaceRoot, targetConfig.resolvedPaths.tailwindCss));
		}
		await Promise.allSettled([component.dependencies && component.dependencies.length ? updateDependencies(component.dependencies, targetConfig, { silent: true }) : Promise.resolve(), component.devDependencies && component.devDependencies.length ? updateDependencies(component.devDependencies, targetConfig, {
			silent: true,
			dev: true
		}) : Promise.resolve()]);
		const files$1 = await updateFiles(component.files, targetConfig, {
			overwrite: options.overwrite,
			silent: true,
			rootSpinner,
			isRemote: options.isRemote
		});
		filesCreated.push(...files$1.filesCreated.map((file) => path.relative(workspaceRoot, path.join(packageRoot, file))));
		filesUpdated.push(...files$1.filesUpdated.map((file) => path.relative(workspaceRoot, path.join(packageRoot, file))));
		filesSkipped.push(...files$1.filesSkipped.map((file) => path.relative(workspaceRoot, path.join(packageRoot, file))));
	}
	rootSpinner?.succeed();
	filesCreated.sort();
	filesUpdated.sort();
	filesSkipped.sort();
	const hasUpdatedFiles = filesCreated.length || filesUpdated.length;
	if (!hasUpdatedFiles && !filesSkipped.length) spinner(`No files updated.`, { silent: options.silent })?.info();
	if (filesCreated.length) {
		spinner(`Created ${filesCreated.length} ${filesCreated.length === 1 ? "file" : "files"}:`, { silent: options.silent })?.succeed();
		for (const file of filesCreated) logger.log(`  - ${file}`);
	}
	if (filesUpdated.length) {
		spinner(`Updated ${filesUpdated.length} ${filesUpdated.length === 1 ? "file" : "files"}:`, { silent: options.silent })?.info();
		for (const file of filesUpdated) logger.log(`  - ${file}`);
	}
	if (filesSkipped.length) {
		spinner(`Skipped ${filesSkipped.length} ${filesUpdated.length === 1 ? "file" : "files"}: (use --overwrite to overwrite)`, { silent: options.silent })?.info();
		for (const file of filesSkipped) logger.log(`  - ${file}`);
	}
}
async function shouldOverwriteCssVars(components, config) {
	const registryItems = await resolveRegistryItems(components, config);
	const result = await fetchRegistry(registryItems);
	const payload = z.array(registryItemSchema).parse(result);
	return payload.some((component) => component.type === "registry:theme" || component.type === "registry:style");
}

//#endregion
//#region src/utils/updaters/update-tailwind-content.ts
async function updateTailwindContent(content, config, options) {
	if (!content) return;
	options = {
		silent: false,
		...options
	};
	const tailwindFileRelativePath = path.relative(config.resolvedPaths.cwd, config.resolvedPaths.tailwindConfig);
	const tailwindSpinner = spinner(`Updating ${highlighter.info(tailwindFileRelativePath)}`, { silent: options.silent }).start();
	const raw = await promises.readFile(config.resolvedPaths.tailwindConfig, "utf8");
	const output = await transformTailwindContent(raw, content, config);
	await promises.writeFile(config.resolvedPaths.tailwindConfig, output, "utf8");
	tailwindSpinner?.succeed();
}
async function transformTailwindContent(input, content, config) {
	const sourceFile = await _createSourceFile(input, config);
	const configObject = sourceFile.getDescendantsOfKind(SyntaxKind.ObjectLiteralExpression).find((node) => node.getProperties().some((property) => property.isKind(SyntaxKind.PropertyAssignment) && property.getName() === "content"));
	if (!configObject) return input;
	addTailwindConfigContent(configObject, content);
	return sourceFile.getFullText();
}
async function addTailwindConfigContent(configObject, content) {
	const quoteChar = _getQuoteChar(configObject);
	const existingProperty = configObject.getProperty("content");
	if (!existingProperty) {
		const newProperty = {
			name: "content",
			initializer: `[${quoteChar}${content.join(`${quoteChar}, ${quoteChar}`)}${quoteChar}]`
		};
		configObject.addPropertyAssignment(newProperty);
		return configObject;
	}
	if (existingProperty.isKind(SyntaxKind.PropertyAssignment)) {
		const initializer = existingProperty.getInitializer();
		if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) for (const contentItem of content) {
			const newValue = `${quoteChar}${contentItem}${quoteChar}`;
			if (initializer.getElements().map((element) => element.getText()).includes(newValue)) continue;
			initializer.addElement(newValue);
		}
		return configObject;
	}
	return configObject;
}

//#endregion
//#region src/commands/init.ts
const initOptionsSchema = z.object({
	cwd: z.string(),
	components: z.array(z.string()).optional(),
	yes: z.boolean(),
	defaults: z.boolean(),
	force: z.boolean(),
	silent: z.boolean(),
	isNewProject: z.boolean(),
	srcDir: z.boolean().optional(),
	cssVariables: z.boolean(),
	baseColor: z.string().optional().refine((val) => {
		if (val) return BASE_COLORS.find((color) => color.name === val);
		return true;
	}, { message: `Invalid base color. Please use '${BASE_COLORS.map((color) => color.name).join("', '")}'` }),
	style: z.string()
});
const init = new Command().name("init").description("initialize your project and install dependencies").argument("[components...]", "the components to add or a url to the component.").option("-y, --yes", "skip confirmation prompt.", true).option("-d, --defaults,", "use default configuration.", false).option("-f, --force", "force overwrite of existing configuration.", false).option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).option("-s, --silent", "mute output.", false).option("--css-variables", "use css variables for theming.", true).option("--no-css-variables", "do not use css variables for theming.").action(async (components, opts) => {
	try {
		const options = initOptionsSchema.parse({
			cwd: path.resolve(opts.cwd),
			isNewProject: false,
			components,
			style: "index",
			...opts
		});
		if (components.length > 0 && isUrl(components[0])) {
			const item = await getRegistryItem(components[0], "");
			if (item?.type === "registry:style") {
				options.baseColor = "neutral";
				options.style = item.extends ?? "index";
			}
		}
		await runInit(options);
		logger.log(`${highlighter.success("Success!")} Project initialization completed.\nYou may now add components.`);
		logger.break();
	} catch (error) {
		logger.break();
		handleError(error);
	}
});
async function runInit(options) {
	let projectInfo;
	if (!options.skipPreflight) {
		const preflight = await preFlightInit(options);
		if (preflight.errors[MISSING_DIR_OR_EMPTY_PROJECT]) process.exit(1);
		projectInfo = preflight.projectInfo;
	} else projectInfo = await getProjectInfo(options.cwd);
	const projectConfig = await getProjectConfig(options.cwd, projectInfo);
	const config = projectConfig ? await promptForMinimalConfig(projectConfig, options) : await promptForConfig(await getConfig(options.cwd));
	if (!options.yes) {
		const { proceed } = await prompts({
			type: "confirm",
			name: "proceed",
			message: `Write configuration to ${highlighter.info("components.json")}. Proceed?`,
			initial: true
		});
		if (!proceed) process.exit(0);
	}
	const componentSpinner = spinner(`Writing components.json.`).start();
	const targetPath = path.resolve(options.cwd, "components.json");
	await promises.writeFile(targetPath, JSON.stringify(config, null, 2), "utf8");
	componentSpinner.succeed();
	const fullConfig = await resolveConfigPaths(options.cwd, config);
	const components = [...options.style === "none" ? [] : [options.style], ...options.components ?? []];
	await addComponents(components, fullConfig, {
		overwrite: true,
		silent: options.silent,
		style: options.style,
		isNewProject: options.isNewProject || projectInfo?.framework.name === "nuxt"
	});
	if (options.isNewProject && options.srcDir) await updateTailwindContent(["./src/**/*.{js,ts,jsx,tsx,mdx}"], fullConfig, { silent: options.silent });
	return fullConfig;
}
async function promptForConfig(defaultConfig = null) {
	const [styles, baseColors] = await Promise.all([getRegistryStyles(), getRegistryBaseColors()]);
	logger.info("");
	const options = await prompts([
		{
			type: "toggle",
			name: "typescript",
			message: `Would you like to use ${highlighter.info("TypeScript")} (recommended)?`,
			initial: defaultConfig?.typescript ?? true,
			active: "yes",
			inactive: "no"
		},
		{
			type: "select",
			name: "style",
			message: `Which ${highlighter.info("style")} would you like to use?`,
			choices: styles.map((style) => ({
				title: style.name === "new-york" ? "New York (Recommended)" : style.label,
				value: style.name
			}))
		},
		{
			type: "select",
			name: "tailwindBaseColor",
			message: `Which color would you like to use as the ${highlighter.info("base color")}?`,
			choices: baseColors.map((color) => ({
				title: color.label,
				value: color.name
			}))
		},
		{
			type: "text",
			name: "tailwindCss",
			message: `Where is your ${highlighter.info("global CSS")} file?`,
			initial: defaultConfig?.tailwind.css ?? DEFAULT_TAILWIND_CSS
		},
		{
			type: "toggle",
			name: "tailwindCssVariables",
			message: `Would you like to use ${highlighter.info("CSS variables")} for theming?`,
			initial: defaultConfig?.tailwind.cssVariables ?? true,
			active: "yes",
			inactive: "no"
		},
		{
			type: "text",
			name: "tailwindPrefix",
			message: `Are you using a custom ${highlighter.info("tailwind prefix eg. tw-")}? (Leave blank if not)`,
			initial: ""
		},
		{
			type: "text",
			name: "tailwindConfig",
			message: `Where is your ${highlighter.info("tailwind.config.js")} located?`,
			initial: defaultConfig?.tailwind.config ?? DEFAULT_TAILWIND_CONFIG
		},
		{
			type: "text",
			name: "components",
			message: `Configure the import alias for ${highlighter.info("components")}:`,
			initial: defaultConfig?.aliases.components ?? DEFAULT_COMPONENTS
		},
		{
			type: "text",
			name: "utils",
			message: `Configure the import alias for ${highlighter.info("utils")}:`,
			initial: defaultConfig?.aliases.utils ?? DEFAULT_UTILS
		}
	]);
	return rawConfigSchema.parse({
		$schema: "https://shadcn-vue.com/schema.json",
		style: options.style,
		tailwind: {
			config: options.tailwindConfig,
			css: options.tailwindCss,
			baseColor: options.tailwindBaseColor,
			cssVariables: options.tailwindCssVariables,
			prefix: options.tailwindPrefix
		},
		typescript: options.typescript,
		aliases: {
			utils: options.utils,
			components: options.components,
			lib: options.components.replace(/\/components$/, "/lib"),
			composables: options.components.replace(/\/components$/, "/composables")
		}
	});
}
async function promptForMinimalConfig(defaultConfig, opts) {
	let style = defaultConfig.style;
	let baseColor = defaultConfig.tailwind.baseColor;
	let cssVariables = defaultConfig.tailwind.cssVariables;
	if (!opts.defaults) {
		const [styles, baseColors, tailwindVersion] = await Promise.all([
			getRegistryStyles(),
			getRegistryBaseColors(),
			getProjectTailwindVersionFromConfig(defaultConfig)
		]);
		const options = await prompts([{
			type: tailwindVersion === "v4" ? null : "select",
			name: "style",
			message: `Which ${highlighter.info("style")} would you like to use?`,
			choices: styles.map((style$1) => ({
				title: style$1.name === "new-york" ? "New York (Recommended)" : style$1.label,
				value: style$1.name
			})),
			initial: 0
		}, {
			type: opts.baseColor ? null : "select",
			name: "tailwindBaseColor",
			message: `Which color would you like to use as the ${highlighter.info("base color")}?`,
			choices: baseColors.map((color) => ({
				title: color.label,
				value: color.name
			}))
		}]);
		style = options.style ?? "new-york";
		baseColor = options.tailwindBaseColor ?? baseColor;
		cssVariables = opts.cssVariables;
	}
	return rawConfigSchema.parse({
		$schema: defaultConfig?.$schema,
		style,
		tailwind: {
			...defaultConfig?.tailwind,
			baseColor,
			cssVariables
		},
		typescript: defaultConfig.typescript,
		aliases: defaultConfig?.aliases,
		iconLibrary: defaultConfig?.iconLibrary
	});
}

//#endregion
//#region src/preflights/preflight-add.ts
async function preFlightAdd(options) {
	const errors = {};
	if (!fs.existsSync(options.cwd) || !fs.existsSync(path.resolve(options.cwd, "package.json"))) {
		errors[MISSING_DIR_OR_EMPTY_PROJECT] = true;
		return {
			errors,
			config: null
		};
	}
	if (!fs.existsSync(path.resolve(options.cwd, "components.json"))) {
		errors[MISSING_CONFIG] = true;
		return {
			errors,
			config: null
		};
	}
	try {
		const config = await getConfig(options.cwd);
		return {
			errors,
			config
		};
	} catch (error) {
		logger.break();
		logger.error(`An invalid ${highlighter.info("components.json")} file was found at ${highlighter.info(options.cwd)}.\nBefore you can add components, you must create a valid ${highlighter.info("components.json")} file by running the ${highlighter.info("init")} command.`);
		logger.error(`Learn more at ${highlighter.info("https://shadcn-vue.com/docs/components-json")}.`);
		logger.break();
		process.exit(1);
	}
}

//#endregion
//#region src/commands/add.ts
const DEPRECATED_COMPONENTS = [{
	name: "toast",
	deprecatedBy: "sonner",
	message: "The toast component is deprecated. Use the sonner component instead."
}, {
	name: "toaster",
	deprecatedBy: "sonner",
	message: "The toaster component is deprecated. Use the sonner component instead."
}];
const addOptionsSchema = z.object({
	components: z.array(z.string()).optional(),
	yes: z.boolean(),
	overwrite: z.boolean(),
	cwd: z.string(),
	all: z.boolean(),
	path: z.string().optional(),
	silent: z.boolean(),
	srcDir: z.boolean().optional(),
	cssVariables: z.boolean()
});
const add = new Command().name("add").description("add a component to your project").argument("[components...]", "the components to add or a url to the component.").option("-y, --yes", "skip confirmation prompt.", false).option("-o, --overwrite", "overwrite existing files.", false).option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).option("-a, --all", "add all available components", false).option("-p, --path <path>", "the path to add the component to.").option("-s, --silent", "mute output.", false).option("--css-variables", "use css variables for theming.", true).option("--no-css-variables", "do not use css variables for theming.").action(async (components, opts) => {
	try {
		const options = addOptionsSchema.parse({
			components,
			cwd: path.resolve(opts.cwd),
			...opts
		});
		let itemType;
		if (components.length > 0 && isUrl(components[0])) {
			const item = await getRegistryItem(components[0], "");
			itemType = item?.type;
		}
		if (!options.yes && (itemType === "registry:style" || itemType === "registry:theme")) {
			logger.break();
			const { confirm } = await prompts({
				type: "confirm",
				name: "confirm",
				message: highlighter.warn(`You are about to install a new ${itemType.replace("registry:", "")}. \nExisting CSS variables and components will be overwritten. Continue?`)
			});
			if (!confirm) {
				logger.break();
				logger.log(`Installation cancelled.`);
				logger.break();
				process.exit(1);
			}
		}
		if (!options.components?.length) options.components = await promptForRegistryComponents(options);
		const projectInfo = await getProjectInfo(options.cwd);
		if (projectInfo?.tailwindVersion === "v4") {
			const deprecatedComponents = DEPRECATED_COMPONENTS.filter((component) => options.components?.includes(component.name));
			if (deprecatedComponents?.length) {
				logger.break();
				deprecatedComponents.forEach((component) => {
					logger.warn(highlighter.warn(component.message));
				});
				logger.break();
				process.exit(1);
			}
		}
		let { errors, config } = await preFlightAdd(options);
		if (errors[MISSING_CONFIG]) {
			const { proceed } = await prompts({
				type: "confirm",
				name: "proceed",
				message: `You need to create a ${highlighter.info("components.json")} file to add components. Proceed?`,
				initial: true
			});
			if (!proceed) {
				logger.break();
				process.exit(1);
			}
			config = await runInit({
				cwd: options.cwd,
				yes: true,
				force: true,
				defaults: false,
				skipPreflight: false,
				silent: true,
				isNewProject: false,
				srcDir: options.srcDir,
				cssVariables: options.cssVariables,
				style: "index"
			});
		}
		if (!config) throw new Error(`Failed to read config at ${highlighter.info(options.cwd)}.`);
		await addComponents(options.components, config, options);
	} catch (error) {
		logger.break();
		handleError(error);
	}
});
async function promptForRegistryComponents(options) {
	const registryIndex = await getRegistryIndex();
	if (!registryIndex) {
		logger.break();
		handleError(new Error("Failed to fetch registry index."));
		return [];
	}
	if (options.all) return registryIndex.map((entry) => entry.name).filter((component) => !DEPRECATED_COMPONENTS.some((c) => c.name === component));
	if (options.components?.length) return options.components;
	const { components } = await prompts({
		type: "multiselect",
		name: "components",
		message: "Which components would you like to add?",
		hint: "Space to select. A to toggle all. Enter to submit.",
		instructions: false,
		choices: registryIndex.filter((entry) => entry.type === "registry:ui" && !DEPRECATED_COMPONENTS.some((component) => component.name === entry.name)).map((entry) => ({
			title: entry.name,
			value: entry.name,
			selected: options.all ? true : options.components?.includes(entry.name)
		}))
	});
	if (!components?.length) {
		logger.warn("No components selected. Exiting.");
		logger.info("");
		process.exit(1);
	}
	const result = z.array(z.string()).safeParse(components);
	if (!result.success) {
		logger.error("");
		handleError(new Error("Something went wrong. Please try again."));
		return [];
	}
	return result.data;
}

//#endregion
//#region src/preflights/preflight-build.ts
async function preFlightBuild(options) {
	const errors = {};
	const resolvePaths = {
		cwd: options.cwd,
		registryFile: path.resolve(options.cwd, options.registryFile),
		outputDir: path.resolve(options.cwd, options.outputDir)
	};
	if (!fs.existsSync(resolvePaths.registryFile)) errors[BUILD_MISSING_REGISTRY_FILE] = true;
	await fs.mkdir(resolvePaths.outputDir, { recursive: true });
	if (Object.keys(errors).length > 0) {
		if (errors[BUILD_MISSING_REGISTRY_FILE]) {
			logger.break();
			logger.error(`The path ${highlighter.info(resolvePaths.registryFile)} does not exist.`);
		}
		logger.break();
		process.exit(1);
	}
	return {
		errors,
		resolvePaths
	};
}

//#endregion
//#region src/commands/build.ts
const buildOptionsSchema = z.object({
	cwd: z.string(),
	registryFile: z.string(),
	outputDir: z.string()
});
const build = new Command().name("build").description("build components for a shadcn registry").argument("[registry]", "path to registry.json file", "./registry.json").option("-o, --output <path>", "destination directory for json files", "./public/r").option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).action(async (registry, opts) => {
	try {
		const options = buildOptionsSchema.parse({
			cwd: path$1.resolve(opts.cwd),
			registryFile: registry,
			outputDir: opts.output
		});
		const { resolvePaths } = await preFlightBuild(options);
		const content = await fs$1.readFile(resolvePaths.registryFile, "utf-8");
		const result = registrySchema.safeParse(JSON.parse(content));
		if (!result.success) {
			logger.error(`Invalid registry file found at ${highlighter.info(resolvePaths.registryFile)}.`);
			process.exit(1);
		}
		const buildSpinner = spinner("Building registry...");
		for (const registryItem of result.data.items) {
			if (!registryItem.files) continue;
			buildSpinner.start(`Building ${registryItem.name}...`);
			registryItem.$schema = "https://shadcn-vue.com/schema/registry-item.json";
			for (const file of registryItem.files) file.content = await fs$1.readFile(path$1.resolve(resolvePaths.cwd, file.path), "utf-8");
			const result$1 = registryItemSchema.safeParse(registryItem);
			if (!result$1.success) {
				logger.error(`Invalid registry item found for ${highlighter.info(registryItem.name)}.`);
				continue;
			}
			await fs$1.writeFile(path$1.resolve(resolvePaths.outputDir, `${result$1.data.name}.json`), JSON.stringify(result$1.data, null, 2));
		}
		buildSpinner.succeed("Building registry.");
	} catch (error) {
		logger.break();
		handleError(error);
	}
});

//#endregion
//#region src/commands/diff.ts
const updateOptionsSchema = z.object({
	component: z.string().optional(),
	yes: z.boolean(),
	cwd: z.string(),
	path: z.string().optional()
});
const diff = new Command().name("diff").description("check for updates against the registry").argument("[component]", "the component name").option("-y, --yes", "skip confirmation prompt.", false).option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).action(async (name$1, opts) => {
	try {
		const options = updateOptionsSchema.parse({
			component: name$1,
			...opts
		});
		const cwd = path.resolve(options.cwd);
		if (!existsSync(cwd)) {
			logger.error(`The path ${cwd} does not exist. Please try again.`);
			process.exit(1);
		}
		const config = await getConfig(cwd);
		if (!config) {
			logger.warn(`Configuration is missing. Please run ${highlighter.success(`init`)} to create a components.json file.`);
			process.exit(1);
		}
		const registryIndex = await getRegistryIndex();
		if (!registryIndex) {
			handleError(new Error("Failed to fetch registry index."));
			process.exit(1);
		}
		if (!options.component) {
			const targetDir = config.resolvedPaths.components;
			const projectComponents = registryIndex.filter((item) => {
				for (const file of item.files ?? []) {
					const filePath = path.resolve(targetDir, typeof file === "string" ? file : file.path);
					if (existsSync(filePath)) return true;
				}
				return false;
			});
			const componentsWithUpdates = [];
			for (const component$1 of projectComponents) {
				const changes$1 = await diffComponent(component$1, config);
				if (changes$1.length) componentsWithUpdates.push({
					name: component$1.name,
					changes: changes$1
				});
			}
			if (!componentsWithUpdates.length) {
				logger.info("No updates found.");
				process.exit(0);
			}
			logger.info("The following components have updates available:");
			for (const component$1 of componentsWithUpdates) {
				logger.info(`- ${component$1.name}`);
				for (const change of component$1.changes) logger.info(`  - ${change.filePath}`);
			}
			logger.break();
			logger.info(`Run ${highlighter.success(`diff <component>`)} to see the changes.`);
			process.exit(0);
		}
		const component = registryIndex.find((item) => item.name === options.component);
		if (!component) {
			logger.error(`The component ${highlighter.success(options.component)} does not exist.`);
			process.exit(1);
		}
		const changes = await diffComponent(component, config);
		if (!changes.length) {
			logger.info(`No updates found for ${options.component}.`);
			process.exit(0);
		}
		for (const change of changes) {
			logger.info(`- ${change.filePath}`);
			await printDiff(change.patch);
			logger.info("");
		}
	} catch (error) {
		handleError(error);
	}
});
async function diffComponent(component, config) {
	const payload = await fetchTree(config.style, [component]);
	const baseColor = await getRegistryBaseColor(config.tailwind.baseColor);
	if (!payload) return [];
	const changes = [];
	for (const item of payload) {
		const targetDir = await getItemTargetPath(config, item);
		if (!targetDir) continue;
		for (const file of item.files ?? []) {
			const filePath = path.resolve(targetDir, typeof file === "string" ? file : file.path);
			if (!existsSync(filePath)) continue;
			const fileContent = await promises.readFile(filePath, "utf8");
			if (typeof file === "string" || !file.content) continue;
			const registryContent = await transform$2({
				filename: file.path,
				raw: file.content,
				config,
				baseColor
			});
			const patch = diffLines(registryContent, fileContent);
			if (patch.length > 1) changes.push({
				filePath,
				patch
			});
		}
	}
	return changes;
}
async function printDiff(diff$1) {
	diff$1.forEach((part) => {
		if (part) {
			if (part.added) return process.stdout.write(highlighter.success(part.value));
			if (part.removed) return process.stdout.write(highlighter.error(part.value));
			return process.stdout.write(part.value);
		}
	});
}

//#endregion
//#region src/commands/info.ts
const info = new Command().name("info").description("get information about your project").option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).action(async (opts) => {
	logger.info("> project info");
	consola.log(await getProjectInfo(opts.cwd));
	logger.break();
	logger.info("> components.json");
	consola.log(await getConfig(opts.cwd));
});

//#endregion
//#region src/migrations/migrate-icons.ts
async function migrateIcons(config) {
	if (!config.resolvedPaths.ui) throw new Error("We could not find a valid `ui` path in your `components.json` file. Please ensure you have a valid `ui` path in your `components.json` file.");
	const uiPath = config.resolvedPaths.ui;
	const [files$1, registryIcons] = await Promise.all([glob("**/*.{js,ts,jsx,tsx}", { cwd: uiPath }), getRegistryIcons()]);
	if (Object.keys(registryIcons).length === 0) throw new Error("Something went wrong fetching the registry icons.");
	const libraryChoices = Object.entries(ICON_LIBRARIES).map(([name$1, iconLibrary]) => ({
		title: iconLibrary.name,
		value: name$1
	}));
	const migrateOptions = await prompts([{
		type: "select",
		name: "sourceLibrary",
		message: `Which icon library would you like to ${highlighter.info("migrate from")}?`,
		choices: libraryChoices
	}, {
		type: "select",
		name: "targetLibrary",
		message: `Which icon library would you like to ${highlighter.info("migrate to")}?`,
		choices: libraryChoices
	}]);
	if (migrateOptions.sourceLibrary === migrateOptions.targetLibrary) throw new Error("You cannot migrate to the same icon library. Please choose a different icon library.");
	if (!(migrateOptions.sourceLibrary in ICON_LIBRARIES && migrateOptions.targetLibrary in ICON_LIBRARIES)) throw new Error("Invalid icon library. Please choose a valid icon library.");
	const sourceLibrary = ICON_LIBRARIES[migrateOptions.sourceLibrary];
	const targetLibrary = ICON_LIBRARIES[migrateOptions.targetLibrary];
	const { confirm } = await prompts({
		type: "confirm",
		name: "confirm",
		initial: true,
		message: `We will migrate ${highlighter.info(files$1.length)} files in ${highlighter.info(`./${path.relative(config.resolvedPaths.cwd, uiPath)}`)} from ${highlighter.info(sourceLibrary.name)} to ${highlighter.info(targetLibrary.name)}. Continue?`
	});
	if (!confirm) {
		logger.info("Migration cancelled.");
		process.exit(0);
	}
	if (targetLibrary.package) await updateDependencies([targetLibrary.package], config, { silent: false });
	const migrationSpinner = spinner(`Migrating icons...`)?.start();
	await Promise.all(files$1.map(async (file) => {
		migrationSpinner.text = `Migrating ${file}...`;
		const filePath = path.join(uiPath, file);
		const fileContent = await promises.readFile(filePath, "utf-8");
		const content = await migrateIconsFile(fileContent, migrateOptions.sourceLibrary, migrateOptions.targetLibrary, registryIcons);
		await promises.writeFile(filePath, content);
	}));
	migrationSpinner.succeed("Migration complete.");
}
async function migrateIconsFile(content, sourceLibrary, targetLibrary, iconsMapping) {
	const sourceLibraryImport = ICON_LIBRARIES[sourceLibrary]?.import;
	const targetLibraryImport = ICON_LIBRARIES[targetLibrary]?.import;
	const dir = await promises.mkdtemp(path.join(tmpdir(), "shadcn-"));
	const project = new Project({ compilerOptions: {} });
	const tempFile = path.join(dir, `shadcn-icons-${randomBytes(4).toString("hex")}.tsx`);
	const sourceFile = project.createSourceFile(tempFile, content, { scriptKind: ScriptKind.TSX });
	const targetedIcons = [];
	for (const importDeclaration of sourceFile.getImportDeclarations() ?? []) {
		if (importDeclaration.getModuleSpecifier()?.getText() !== `"${sourceLibraryImport}"`) continue;
		for (const specifier of importDeclaration.getNamedImports() ?? []) {
			const iconName = specifier.getName();
			const targetedIcon = Object.values(iconsMapping).find((icon) => icon[sourceLibrary] === iconName)?.[targetLibrary];
			if (!targetedIcon || targetedIcons.includes(targetedIcon)) continue;
			targetedIcons.push(targetedIcon);
			specifier.remove();
			sourceFile.getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement).filter((node) => node.getTagNameNode()?.getText() === iconName).forEach((node) => node.getTagNameNode()?.replaceWithText(targetedIcon));
		}
		if (importDeclaration.getNamedImports()?.length === 0) importDeclaration.remove();
	}
	if (targetedIcons.length > 0) sourceFile.addImportDeclaration({
		moduleSpecifier: targetLibraryImport,
		namedImports: targetedIcons.map((icon) => ({ name: icon }))
	});
	return await sourceFile.getText();
}

//#endregion
//#region src/preflights/preflight-migrate.ts
async function preFlightMigrate(options) {
	const errors = {};
	if (!fs.existsSync(options.cwd) || !fs.existsSync(path.resolve(options.cwd, "package.json"))) {
		errors[MISSING_DIR_OR_EMPTY_PROJECT] = true;
		return {
			errors,
			config: null
		};
	}
	if (!fs.existsSync(path.resolve(options.cwd, "components.json"))) {
		errors[MISSING_CONFIG] = true;
		return {
			errors,
			config: null
		};
	}
	try {
		const config = await getConfig(options.cwd);
		return {
			errors,
			config
		};
	} catch (error) {
		logger.break();
		logger.error(`An invalid ${highlighter.info("components.json")} file was found at ${highlighter.info(options.cwd)}.\nBefore you can run a migration, you must create a valid ${highlighter.info("components.json")} file by running the ${highlighter.info("init")} command.`);
		logger.error(`Learn more at ${highlighter.info("https://shadcn-vue.com/docs/components-json")}.`);
		logger.break();
		process.exit(1);
	}
}

//#endregion
//#region src/commands/migrate.ts
const migrations = [{
	name: "icons",
	description: "migrate your ui components to a different icon library."
}];
const migrateOptionsSchema = z.object({
	cwd: z.string(),
	list: z.boolean(),
	migration: z.string().refine((value) => value && migrations.some((migration) => migration.name === value), { message: "You must specify a valid migration. Run `shadcn migrate --list` to see available migrations." }).optional()
});
const migrate = new Command().name("migrate").description("run a migration.").argument("[migration]", "the migration to run.").option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).option("-l, --list", "list all migrations.", false).action(async (migration, opts) => {
	try {
		const options = migrateOptionsSchema.parse({
			cwd: path.resolve(opts.cwd),
			migration,
			list: opts.list
		});
		if (options.list || !options.migration) {
			consola.info("Available migrations:");
			for (const migration$1 of migrations) consola.info(`- ${migration$1.name}: ${migration$1.description}`);
			return;
		}
		if (!options.migration) throw new Error("You must specify a migration. Run `shadcn migrate --list` to see available migrations.");
		const { errors, config } = await preFlightMigrate(options);
		if (errors[MISSING_DIR_OR_EMPTY_PROJECT] || errors[MISSING_CONFIG]) throw new Error("No `components.json` file found. Ensure you are at the root of your project.");
		if (!config) throw new Error("Something went wrong reading your `components.json` file. Please ensure you have a valid `components.json` file.");
		if (options.migration === "icons") await migrateIcons(config);
	} catch (error) {
		handleError(error);
	}
});

//#endregion
//#region package.json
var name = "shadcn-vue";
var type = "module";
var version = "2.2.0";
var description = "Add components to your apps.";
var publishConfig = { "access": "public" };
var license = "MIT";
var repository = {
	"type": "git",
	"url": "https://github.com/unovue/shadcn-vue.git",
	"directory": "packages/cli"
};
var keywords = [
	"components",
	"ui",
	"vue",
	"nuxt",
	"tailwind",
	"radix-ui",
	"radix-vue",
	"reka-ui",
	"shadcn",
	"shadcn-vue"
];
var exports = {
	".": {
		"types": "./dist/index.d.ts",
		"default": "./dist/index.js"
	},
	"./registry": {
		"types": "./dist/registry/index.d.ts",
		"default": "./dist/registry/index.js"
	}
};
var bin = "./dist/index.js";
var files = ["dist"];
var scripts = {
	"dev": "tsdown --watch",
	"build": "tsdown",
	"typecheck": "tsc --noEmit",
	"clean": "node ./scripts/rimraf.js",
	"lint": "eslint .",
	"lint:fix": "eslint --fix .",
	"start:dev": "REGISTRY_URL=http://localhost:5173/r node dist/index.js",
	"start": "node dist/index.js",
	"release": "changeset version",
	"pub:beta": "pnpm build && pnpm publish --no-git-checks --access public --tag beta",
	"pub:next": "pnpm build && pnpm publish --no-git-checks --access public --tag next",
	"pub:release": "pnpm build && pnpm publish  --no-git-checks --access public",
	"test": "vitest run",
	"test:update": "vitest run -u",
	"test:ui": "vitest --ui"
};
var dependencies = {
	"@unovue/detypes": "^0.8.5",
	"@vue/compiler-sfc": "^3.5",
	"commander": "^14.0.0",
	"consola": "^3.4.2",
	"cosmiconfig": "^9.0.0",
	"deepmerge": "^4.3.1",
	"diff": "^8.0.2",
	"fs-extra": "^11.3.0",
	"get-tsconfig": "^4.10.1",
	"magic-string": "^0.30.17",
	"nypm": "^0.6.0",
	"ofetch": "^1.4.1",
	"ora": "^8.2.0",
	"pathe": "^2.0.3",
	"postcss": "^8.5.3",
	"prompts": "^2.4.2",
	"reka-ui": "catalog:",
	"stringify-object": "^5.0.0",
	"tailwindcss": "^4.1.7",
	"tinyexec": "^1.0.1",
	"tinyglobby": "catalog:",
	"ts-morph": "^26.0.0",
	"undici": "^7.10.0",
	"vue-metamorph": "^3.3.3",
	"zod": "catalog:"
};
var devDependencies = {
	"@types/diff": "^8.0.0",
	"@types/fs-extra": "^11.0.4",
	"@types/node": "^22.15.21",
	"@types/prompts": "^2.4.9",
	"@types/stringify-object": "^4.0.5",
	"msw": "^2.8.4",
	"tsdown": "^0.12.3",
	"type-fest": "^4.41.0",
	"typescript": "catalog:"
};
var package_default = {
	name,
	type,
	version,
	description,
	publishConfig,
	license,
	repository,
	keywords,
	exports,
	bin,
	files,
	scripts,
	dependencies,
	devDependencies
};

//#endregion
//#region src/index.ts
process.on("SIGINT", () => process.exit(0));
process.on("SIGTERM", () => process.exit(0));
async function main() {
	const program = new Command().name("shadcn-vue").description("add components and dependencies to your project").version(package_default.version || "1.0.0", "-v, --version", "display the version number");
	program.addCommand(init).addCommand(add).addCommand(diff).addCommand(migrate).addCommand(info).addCommand(build);
	program.parse();
}
main();

//#endregion
export { BASE_COLORS, clearRegistryCache, fetchRegistry, fetchTree, getItemTargetPath, getRegistryBaseColor, getRegistryBaseColors, getRegistryIcons, getRegistryIndex, getRegistryItem, getRegistryParentMap, getRegistryStyles, getRegistryTypeAliasMap, isUrl, registryGetTheme, registryResolveItemsTree, resolveRegistryItems, resolveTree };
//# sourceMappingURL=index.js.map