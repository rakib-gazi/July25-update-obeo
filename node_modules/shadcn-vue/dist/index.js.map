{"version":3,"file":"index.js","names":["options: z.infer<typeof initOptionsSchema>","errors: Record<string, boolean>","css: z.infer<typeof registryItemCssSchema> | undefined","config: Config","options: {\n    silent?: boolean\n  }","input: string","css: z.infer<typeof registryItemCssSchema>","root: Root","name","root: Root | AtRule","name: string","params: string","properties: any","parent: Root | AtRule","selector: string","cssVars: z.infer<typeof registryItemCssVarsSchema> | undefined","config: Config","options: {\n    cleanupDefaultNextStyles?: boolean\n    overwriteCssVars?: boolean\n    initIndex?: boolean\n    silent?: boolean\n    tailwindVersion?: TailwindVersion\n    tailwindConfig?: z.infer<typeof registryItemTailwindSchema>['config']\n  }","transformCssVars","input: string","cssVars: z.infer<typeof registryItemCssVarsSchema>","options: {\n    cleanupDefaultNextStyles?: boolean\n    tailwindVersion?: TailwindVersion\n    tailwindConfig?: z.infer<typeof registryItemTailwindSchema>['config']\n    overwriteCssVars?: boolean\n    initIndex?: boolean\n  }","root: Root","root: Rule | Root","baseLayer: AtRule","selector: string","vars: Record<string, string>","options: {\n    overwriteCssVars?: boolean\n  }","key","value","cssVarNode","tailwindConfig: z.infer<typeof registryItemTailwindSchema>['config']","value: string","dependencies: RegistryItem['dependencies']","config: Config","options: {\n    silent?: boolean\n    dev?: boolean\n  }","dependencies","opts: TransformOpts","path","className: string","parts: (string | null)[]","name","input: string","mapping: z.infer<typeof registryBaseColorSchema>['inlineColors']","prefix","opts: TransformOpts","path","moduleSpecifier: string","config: TransformOpts['config']","isRemote: boolean","opts: TransformOpts","content: string","filename: string","opts: TransformOpts","node: any","expression: any","arg: any","prop: any","literal: any","path","input: string","prefix: string","tailwindVersion: TailwindVersion","opts: TransformOpts","registryIcons: Record<string, Record<string, string>>","targetedIconsMap: Map<string, string>","path","transform","opts: TransformOpts","files: RegistryItem['files']","config: Config","options: {\n    overwrite?: boolean\n    force?: boolean\n    silent?: boolean\n    rootSpinner?: ReturnType<typeof spinner>\n    isRemote?: boolean\n  }","files","filesCreated: string[]","filesUpdated: string[]","filesSkipped: string[]","file: z.infer<typeof registryItemFileSchema>","options: {\n    commonRoot?: string\n    framework?: ProjectInfo['framework']['name']\n  }","findCommonRoot","paths: string[]","needle: string","path","filePath: string","targetDir: string","content: string","target: string","framework?: ProjectInfo['framework']['name']","filePaths: string[]","opts: any","node: any","moduleSpecifier: string","tsConfig: any","probableImportFilePath: string","files: string[]","extensions: string[]","name","projectInfo: ProjectInfo","components: string[]","config: Config","options: {\n    overwrite?: boolean\n    silent?: boolean\n    isNewProject?: boolean\n    style?: string\n  }","config: z.infer<typeof configSchema>","workspaceConfig: z.infer<typeof workspaceConfigSchema>","options: {\n    overwrite?: boolean\n    silent?: boolean\n    isNewProject?: boolean\n    isRemote?: boolean\n    style?: string\n  }","filesCreated: string[]","filesUpdated: string[]","filesSkipped: string[]","files","components: z.infer<typeof registryItemSchema>['name'][]","content: string[]","config: Config","options: {\n    silent?: boolean\n  }","input: string","configObject: ObjectLiteralExpression","options: z.infer<typeof initOptionsSchema> & {\n    skipPreflight?: boolean\n  }","defaultConfig: Config | null","defaultConfig: Config","opts: z.infer<typeof initOptionsSchema>","style","options: z.infer<typeof addOptionsSchema>","errors: Record<string, boolean>","itemType: z.infer<typeof registryItemTypeSchema> | undefined","options: z.infer<typeof addOptionsSchema>","options: z.infer<typeof buildOptionsSchema>","errors: Record<string, boolean>","registry: string","result","name","component","changes","component: z.infer<typeof registryIndexSchema>[number]","config: Config","diff: Change[]","config: Config","files","name","content: string","sourceLibrary: keyof typeof ICON_LIBRARIES","targetLibrary: keyof typeof ICON_LIBRARIES","iconsMapping: z.infer<typeof iconsSchema>","targetedIcons: string[]","options: z.infer<typeof migrateOptionsSchema>","errors: Record<string, boolean>","migration","packageJson"],"sources":["../src/utils/errors.ts","../src/preflights/preflight-init.ts","../src/utils/updaters/update-css.ts","../src/utils/updaters/update-css-vars.ts","../src/utils/updaters/update-dependencies.ts","../src/utils/transformers/transform-css-vars.ts","../src/utils/transformers/transform-import.ts","../src/utils/transformers/transform-sfc.ts","../src/utils/transformers/transform-tw-prefix.ts","../src/utils/icon-libraries.ts","../src/utils/transformers/transform-icons.ts","../src/utils/transformers/index.ts","../src/utils/updaters/update-files.ts","../src/utils/add-components.ts","../src/utils/updaters/update-tailwind-content.ts","../src/commands/init.ts","../src/preflights/preflight-add.ts","../src/commands/add.ts","../src/preflights/preflight-build.ts","../src/commands/build.ts","../src/commands/diff.ts","../src/commands/info.ts","../src/migrations/migrate-icons.ts","../src/preflights/preflight-migrate.ts","../src/commands/migrate.ts","../package.json","../src/index.ts"],"sourcesContent":["export const MISSING_DIR_OR_EMPTY_PROJECT = '1'\nexport const EXISTING_CONFIG = '2'\nexport const MISSING_CONFIG = '3'\nexport const FAILED_CONFIG_READ = '4'\nexport const TAILWIND_NOT_CONFIGURED = '5'\nexport const IMPORT_ALIAS_MISSING = '6'\nexport const UNSUPPORTED_FRAMEWORK = '7'\nexport const COMPONENT_URL_NOT_FOUND = '8'\nexport const COMPONENT_URL_UNAUTHORIZED = '9'\nexport const COMPONENT_URL_FORBIDDEN = '10'\nexport const COMPONENT_URL_BAD_REQUEST = '11'\nexport const COMPONENT_URL_INTERNAL_SERVER_ERROR = '12'\nexport const BUILD_MISSING_REGISTRY_FILE = '13'\n","import type { z } from 'zod'\nimport type { initOptionsSchema } from '@/src/commands/init'\nimport fs from 'fs-extra'\nimport path from 'pathe'\nimport * as ERRORS from '@/src/utils/errors'\nimport { getProjectInfo } from '@/src/utils/get-project-info'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\nimport { spinner } from '@/src/utils/spinner'\n\nexport async function preFlightInit(\n  options: z.infer<typeof initOptionsSchema>,\n) {\n  const errors: Record<string, boolean> = {}\n\n  // Ensure target directory exists.\n  // Check for empty project. We assume if no package.json exists, the project is empty.\n  if (\n    !fs.existsSync(options.cwd)\n    || !fs.existsSync(path.resolve(options.cwd, 'package.json'))\n  ) {\n    errors[ERRORS.MISSING_DIR_OR_EMPTY_PROJECT] = true\n    return {\n      errors,\n      projectInfo: null,\n    }\n  }\n\n  const projectSpinner = spinner(`Preflight checks.`, {\n    silent: options.silent,\n  }).start()\n\n  if (\n    fs.existsSync(path.resolve(options.cwd, 'components.json'))\n    && !options.force\n  ) {\n    projectSpinner?.fail()\n    logger.break()\n    logger.error(\n      `A ${highlighter.info(\n        'components.json',\n      )} file already exists at ${highlighter.info(\n        options.cwd,\n      )}.\\nTo start over, remove the ${highlighter.info(\n        'components.json',\n      )} file and run ${highlighter.info('init')} again.`,\n    )\n    logger.break()\n    process.exit(1)\n  }\n\n  projectSpinner?.succeed()\n\n  const frameworkSpinner = spinner(`Verifying framework.`, {\n    silent: options.silent,\n  }).start()\n  const projectInfo = await getProjectInfo(options.cwd)\n  if (!projectInfo || projectInfo?.framework.name === 'manual') {\n    errors[ERRORS.UNSUPPORTED_FRAMEWORK] = true\n    frameworkSpinner?.fail()\n    logger.break()\n    if (projectInfo?.framework.links.installation) {\n      logger.error(\n        `We could not detect a supported framework at ${highlighter.info(\n          options.cwd,\n        )}.\\n`\n        + `Visit ${highlighter.info(\n          projectInfo?.framework.links.installation,\n        )} to manually configure your project.\\nOnce configured, you can use the cli to add components.`,\n      )\n    }\n    logger.break()\n    process.exit(1)\n  }\n  frameworkSpinner?.succeed(\n    `Verifying framework. Found ${highlighter.info(\n      projectInfo.framework.label,\n    )}.`,\n  )\n\n  let tailwindSpinnerMessage = 'Validating Tailwind CSS.'\n\n  if (projectInfo.tailwindVersion === 'v4') {\n    tailwindSpinnerMessage = `Validating Tailwind CSS config. Found ${highlighter.info(\n      'v4',\n    )}.`\n  }\n\n  const tailwindSpinner = spinner(tailwindSpinnerMessage, {\n    silent: options.silent,\n  }).start()\n  if (\n    projectInfo.tailwindVersion === 'v3'\n    && (!projectInfo?.tailwindConfigFile || !projectInfo?.tailwindCssFile)\n  ) {\n    errors[ERRORS.TAILWIND_NOT_CONFIGURED] = true\n    tailwindSpinner?.fail()\n  }\n  else if (\n    projectInfo.tailwindVersion === 'v4'\n    && !projectInfo?.tailwindCssFile\n  ) {\n    errors[ERRORS.TAILWIND_NOT_CONFIGURED] = true\n    tailwindSpinner?.fail()\n  }\n  else if (!projectInfo.tailwindVersion) {\n    errors[ERRORS.TAILWIND_NOT_CONFIGURED] = true\n    tailwindSpinner?.fail()\n  }\n  else {\n    tailwindSpinner?.succeed()\n  }\n\n  const tsConfigSpinner = spinner(`Validating import alias.`, {\n    silent: options.silent,\n  }).start()\n  if (!projectInfo?.aliasPrefix) {\n    errors[ERRORS.IMPORT_ALIAS_MISSING] = true\n    tsConfigSpinner?.fail()\n  }\n  else {\n    tsConfigSpinner?.succeed()\n  }\n\n  if (Object.keys(errors).length > 0) {\n    if (errors[ERRORS.TAILWIND_NOT_CONFIGURED]) {\n      logger.break()\n      logger.error(\n        `No Tailwind CSS configuration found at ${highlighter.info(\n          options.cwd,\n        )}.`,\n      )\n      logger.error(\n        `It is likely you do not have Tailwind CSS installed or have an invalid configuration.`,\n      )\n      logger.error(`Install Tailwind CSS then try again.`)\n      if (projectInfo?.framework.links.tailwind) {\n        logger.error(\n          `Visit ${highlighter.info(\n            projectInfo?.framework.links.tailwind,\n          )} to get started.`,\n        )\n      }\n    }\n\n    if (errors[ERRORS.IMPORT_ALIAS_MISSING]) {\n      logger.break()\n      logger.error(`No import alias found in your tsconfig.json file.`)\n      if (projectInfo?.framework.links.installation) {\n        logger.error(\n          `Visit ${highlighter.info(\n            projectInfo?.framework.links.installation,\n          )} to learn how to set an import alias.`,\n        )\n      }\n    }\n\n    logger.break()\n    process.exit(1)\n  }\n\n  return {\n    errors,\n    projectInfo,\n  }\n}\n","import type AtRule from 'postcss/lib/at-rule'\nimport type Declaration from 'postcss/lib/declaration'\nimport type Root from 'postcss/lib/root'\nimport type Rule from 'postcss/lib/rule'\nimport type { z } from 'zod'\nimport type { registryItemCssSchema } from '@/src/registry/schema'\nimport type { Config } from '@/src/utils/get-config'\nimport { promises as fs } from 'node:fs'\nimport path from 'pathe'\nimport postcss from 'postcss'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { spinner } from '@/src/utils/spinner'\n\nexport async function updateCss(\n  css: z.infer<typeof registryItemCssSchema> | undefined,\n  config: Config,\n  options: {\n    silent?: boolean\n  },\n) {\n  if (\n    !config.resolvedPaths.tailwindCss\n    || !css\n    || Object.keys(css).length === 0\n  ) {\n    return\n  }\n\n  options = {\n    silent: false,\n    ...options,\n  }\n\n  const cssFilepath = config.resolvedPaths.tailwindCss\n  const cssFilepathRelative = path.relative(\n    config.resolvedPaths.cwd,\n    cssFilepath,\n  )\n  const cssSpinner = spinner(\n    `Updating ${highlighter.info(cssFilepathRelative)}`,\n    {\n      silent: options.silent,\n    },\n  ).start()\n\n  const raw = await fs.readFile(cssFilepath, 'utf8')\n  const output = await transformCss(raw, css)\n  await fs.writeFile(cssFilepath, output, 'utf8')\n  cssSpinner.succeed()\n}\n\nexport async function transformCss(\n  input: string,\n  css: z.infer<typeof registryItemCssSchema>,\n) {\n  const plugins = [updateCssPlugin(css)]\n\n  const result = await postcss(plugins).process(input, {\n    from: undefined,\n  })\n\n  let output = result.css\n  output = output.replace(/\\/\\* ---break--- \\*\\//g, '')\n  output = output.replace(/(\\n\\s*\\n)+/g, '\\n\\n')\n  output = output.trimEnd()\n\n  return output\n}\n\nfunction updateCssPlugin(css: z.infer<typeof registryItemCssSchema>) {\n  return {\n    postcssPlugin: 'update-css',\n    Once(root: Root) {\n      for (const [selector, properties] of Object.entries(css)) {\n        if (selector.startsWith('@')) {\n          // Handle at-rules (@layer, @utility, etc.)\n          const atRuleMatch = selector.match(/@([a-z-]+)\\s*(.*)/i)\n          if (!atRuleMatch)\n            continue\n\n          const [, name, params] = atRuleMatch\n\n          // Special handling for keyframes - place them under @theme inline\n          if (name === 'keyframes') {\n            let themeInline = root.nodes?.find(\n              (node): node is AtRule =>\n                node.type === 'atrule'\n                && node.name === 'theme'\n                && node.params === 'inline',\n            ) as AtRule | undefined\n\n            if (!themeInline) {\n              themeInline = postcss.atRule({\n                name: 'theme',\n                params: 'inline',\n                raws: { semicolon: true, between: ' ', before: '\\n' },\n              })\n              root.append(themeInline)\n              root.insertBefore(\n                themeInline,\n                postcss.comment({ text: '---break---' }),\n              )\n            }\n\n            const keyframesRule = postcss.atRule({\n              name: 'keyframes',\n              params,\n              raws: { semicolon: true, between: ' ', before: '\\n  ' },\n            })\n\n            themeInline.append(keyframesRule)\n\n            if (typeof properties === 'object') {\n              for (const [step, stepProps] of Object.entries(properties)) {\n                processRule(keyframesRule, step, stepProps)\n              }\n            }\n          }\n          // Special handling for utility classes to preserve property values\n          else if (name === 'utility') {\n            const utilityAtRule = root.nodes?.find(\n              (node): node is AtRule =>\n                node.type === 'atrule'\n                && node.name === name\n                && node.params === params,\n            ) as AtRule | undefined\n\n            if (!utilityAtRule) {\n              const atRule = postcss.atRule({\n                name,\n                params,\n                raws: { semicolon: true, between: ' ', before: '\\n' },\n              })\n\n              root.append(atRule)\n              root.insertBefore(\n                atRule,\n                postcss.comment({ text: '---break---' }),\n              )\n\n              // Add declarations with their values preserved\n              if (typeof properties === 'object') {\n                for (const [prop, value] of Object.entries(properties)) {\n                  if (typeof value === 'string') {\n                    const decl = postcss.decl({\n                      prop,\n                      value,\n                      raws: { semicolon: true, before: '\\n    ' },\n                    })\n                    atRule.append(decl)\n                  }\n                  else if (typeof value === 'object') {\n                    processRule(atRule, prop, value)\n                  }\n                }\n              }\n            }\n            else {\n              // Update existing utility class\n              if (typeof properties === 'object') {\n                for (const [prop, value] of Object.entries(properties)) {\n                  if (typeof value === 'string') {\n                    const existingDecl = utilityAtRule.nodes?.find(\n                      (node): node is Declaration =>\n                        node.type === 'decl' && node.prop === prop,\n                    )\n\n                    const decl = postcss.decl({\n                      prop,\n                      value,\n                      raws: { semicolon: true, before: '\\n    ' },\n                    })\n\n                    existingDecl\n                      ? existingDecl.replaceWith(decl)\n                      : utilityAtRule.append(decl)\n                  }\n                  else if (typeof value === 'object') {\n                    processRule(utilityAtRule, prop, value)\n                  }\n                }\n              }\n            }\n          }\n          else {\n            // Handle other at-rules normally\n            processAtRule(root, name, params, properties)\n          }\n        }\n        else {\n          // Handle regular CSS rules\n          processRule(root, selector, properties)\n        }\n      }\n    },\n  }\n}\n\nfunction processAtRule(\n  root: Root | AtRule,\n  name: string,\n  params: string,\n  properties: any,\n) {\n  // Find or create the at-rule\n  let atRule = root.nodes?.find(\n    (node): node is AtRule =>\n      node.type === 'atrule' && node.name === name && node.params === params,\n  ) as AtRule | undefined\n\n  if (!atRule) {\n    atRule = postcss.atRule({\n      name,\n      params,\n      raws: { semicolon: true, between: ' ', before: '\\n' },\n    })\n    root.append(atRule)\n    root.insertBefore(atRule, postcss.comment({ text: '---break---' }))\n  }\n\n  // Process children of this at-rule\n  if (typeof properties === 'object') {\n    for (const [childSelector, childProps] of Object.entries(properties)) {\n      if (childSelector.startsWith('@')) {\n        // Nested at-rule\n        const nestedMatch = childSelector.match(/@([a-z-]+)\\s*(.*)/i)\n        if (nestedMatch) {\n          const [, nestedName, nestedParams] = nestedMatch\n          processAtRule(atRule, nestedName, nestedParams, childProps)\n        }\n      }\n      else {\n        // CSS rule within at-rule\n        processRule(atRule, childSelector, childProps)\n      }\n    }\n  }\n  else if (typeof properties === 'string') {\n    // Direct string content for the at-rule\n    try {\n      // Parse the CSS string with PostCSS\n      const parsed = postcss.parse(`.temp{${properties}}`)\n      const tempRule = parsed.first as Rule\n\n      if (tempRule && tempRule.nodes) {\n        // Create a rule for the at-rule if needed\n        const rule = postcss.rule({\n          selector: 'temp',\n          raws: { semicolon: true, between: ' ', before: '\\n  ' },\n        })\n\n        // Copy all declarations from the temp rule to our actual rule\n        tempRule.nodes.forEach((node) => {\n          if (node.type === 'decl') {\n            const clone = node.clone()\n            clone.raws.before = '\\n    '\n            rule.append(clone)\n          }\n        })\n\n        // Only add the rule if it has declarations\n        if (rule.nodes?.length) {\n          atRule.append(rule)\n        }\n      }\n    }\n    catch (error) {\n      console.error('Error parsing at-rule content:', properties, error)\n      throw error\n    }\n  }\n}\n\nfunction processRule(parent: Root | AtRule, selector: string, properties: any) {\n  let rule = parent.nodes?.find(\n    (node): node is Rule => node.type === 'rule' && node.selector === selector,\n  ) as Rule | undefined\n\n  if (!rule) {\n    rule = postcss.rule({\n      selector,\n      raws: { semicolon: true, between: ' ', before: '\\n  ' },\n    })\n    parent.append(rule)\n  }\n\n  if (typeof properties === 'object') {\n    for (const [prop, value] of Object.entries(properties)) {\n      if (typeof value === 'string') {\n        const decl = postcss.decl({\n          prop,\n          value,\n          raws: { semicolon: true, before: '\\n    ' },\n        })\n\n        // Replace existing property or add new one\n        const existingDecl = rule.nodes?.find(\n          (node): node is Declaration =>\n            node.type === 'decl' && node.prop === prop,\n        )\n\n        existingDecl ? existingDecl.replaceWith(decl) : rule.append(decl)\n      }\n      else if (typeof value === 'object') {\n        // Nested selector (including & selectors)\n        const nestedSelector = prop.startsWith('&')\n          ? selector.replace(/^([^:]+)/, `$1${prop.substring(1)}`)\n          : prop // Use the original selector for other nested elements\n        processRule(parent, nestedSelector, value)\n      }\n    }\n  }\n  else if (typeof properties === 'string') {\n    // Direct string content for the rule\n    try {\n      // Parse the CSS string with PostCSS\n      const parsed = postcss.parse(`.temp{${properties}}`)\n      const tempRule = parsed.first as Rule\n\n      if (tempRule && tempRule.nodes) {\n        // Copy all declarations from the temp rule to our actual rule\n        tempRule.nodes.forEach((node) => {\n          if (node.type === 'decl') {\n            const clone = node.clone()\n            clone.raws.before = '\\n    '\n            rule?.append(clone)\n          }\n        })\n      }\n    }\n    catch (error) {\n      console.error('Error parsing rule content:', selector, properties, error)\n      throw error\n    }\n  }\n}\n","import type Root from 'postcss/lib/root'\nimport type Rule from 'postcss/lib/rule'\nimport type {\n  registryItemCssVarsSchema,\n  registryItemTailwindSchema,\n} from '@/src/registry/schema'\nimport type { Config } from '@/src/utils/get-config'\nimport type { TailwindVersion } from '@/src/utils/get-project-info'\nimport { promises as fs } from 'node:fs'\nimport path from 'pathe'\nimport postcss from 'postcss'\nimport AtRule from 'postcss/lib/at-rule'\nimport { z } from 'zod'\nimport { getPackageInfo } from '@/src/utils/get-package-info'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { spinner } from '@/src/utils/spinner'\n\nexport async function updateCssVars(\n  cssVars: z.infer<typeof registryItemCssVarsSchema> | undefined,\n  config: Config,\n  options: {\n    cleanupDefaultNextStyles?: boolean\n    overwriteCssVars?: boolean\n    initIndex?: boolean\n    silent?: boolean\n    tailwindVersion?: TailwindVersion\n    tailwindConfig?: z.infer<typeof registryItemTailwindSchema>['config']\n  },\n) {\n  if (!config.resolvedPaths.tailwindCss || !Object.keys(cssVars ?? {}).length) {\n    return\n  }\n\n  options = {\n    cleanupDefaultNextStyles: false,\n    silent: false,\n    tailwindVersion: 'v3',\n    overwriteCssVars: false,\n    initIndex: true,\n    ...options,\n  }\n  const cssFilepath = config.resolvedPaths.tailwindCss\n  const cssFilepathRelative = path.relative(\n    config.resolvedPaths.cwd,\n    cssFilepath,\n  )\n  const cssVarsSpinner = spinner(\n    `Updating CSS variables in ${highlighter.info(cssFilepathRelative)}`,\n    {\n      silent: options.silent,\n    },\n  ).start()\n  const raw = await fs.readFile(cssFilepath, 'utf8')\n  const output = await transformCssVars(raw, cssVars ?? {}, config, {\n    cleanupDefaultNextStyles: options.cleanupDefaultNextStyles,\n    tailwindVersion: options.tailwindVersion,\n    tailwindConfig: options.tailwindConfig,\n    overwriteCssVars: options.overwriteCssVars,\n    initIndex: options.initIndex,\n  })\n  await fs.writeFile(cssFilepath, output, 'utf8')\n  cssVarsSpinner.succeed()\n}\n\nexport async function transformCssVars(\n  input: string,\n  cssVars: z.infer<typeof registryItemCssVarsSchema>,\n  config: Config,\n  options: {\n    cleanupDefaultNextStyles?: boolean\n    tailwindVersion?: TailwindVersion\n    tailwindConfig?: z.infer<typeof registryItemTailwindSchema>['config']\n    overwriteCssVars?: boolean\n    initIndex?: boolean\n  } = {\n    cleanupDefaultNextStyles: false,\n    tailwindVersion: 'v3',\n    tailwindConfig: undefined,\n    overwriteCssVars: false,\n    initIndex: true,\n  },\n) {\n  options = {\n    cleanupDefaultNextStyles: false,\n    tailwindVersion: 'v3',\n    tailwindConfig: undefined,\n    overwriteCssVars: false,\n    initIndex: true,\n    ...options,\n  }\n\n  let plugins = [updateCssVarsPlugin(cssVars)]\n\n  if (options.cleanupDefaultNextStyles) {\n    plugins.push(cleanupDefaultNextStylesPlugin())\n  }\n\n  if (options.tailwindVersion === 'v4') {\n    plugins = []\n\n    // Only add tw-animate-css if project does not have tailwindcss-animate\n    if (config.resolvedPaths?.cwd) {\n      const packageInfo = getPackageInfo(config.resolvedPaths.cwd)\n      if (\n        !packageInfo?.dependencies?.['tailwindcss-animate']\n        && !packageInfo?.devDependencies?.['tailwindcss-animate']\n        && options.initIndex\n      ) {\n        plugins.push(addCustomImport({ params: 'tw-animate-css' }))\n      }\n    }\n\n    plugins.push(addCustomVariant({ params: 'dark (&:is(.dark *))' }))\n\n    if (options.cleanupDefaultNextStyles) {\n      plugins.push(cleanupDefaultNextStylesPlugin())\n    }\n\n    plugins.push(\n      updateCssVarsPluginV4(cssVars, {\n        overwriteCssVars: options.overwriteCssVars,\n      }),\n    )\n    plugins.push(updateThemePlugin(cssVars))\n\n    if (options.tailwindConfig) {\n      plugins.push(updateTailwindConfigPlugin(options.tailwindConfig))\n      plugins.push(updateTailwindConfigAnimationPlugin(options.tailwindConfig))\n      plugins.push(updateTailwindConfigKeyframesPlugin(options.tailwindConfig))\n    }\n  }\n\n  if (config.tailwind.cssVariables && options.initIndex) {\n    plugins.push(\n      updateBaseLayerPlugin({ tailwindVersion: options.tailwindVersion }),\n    )\n  }\n\n  const result = await postcss(plugins).process(input, {\n    from: undefined,\n  })\n\n  let output = result.css\n\n  output = output.replace(/\\/\\* ---break--- \\*\\//g, '')\n\n  if (options.tailwindVersion === 'v4') {\n    output = output.replace(/(\\n\\s*\\n)+/g, '\\n\\n')\n  }\n\n  return output\n}\n\nfunction updateBaseLayerPlugin({\n  tailwindVersion,\n}: {\n  tailwindVersion?: TailwindVersion\n}) {\n  return {\n    postcssPlugin: 'update-base-layer',\n    Once(root: Root) {\n      const requiredRules = [\n        {\n          selector: '*',\n          apply:\n            tailwindVersion === 'v4'\n              ? 'border-border outline-ring/50'\n              : 'border-border',\n        },\n        { selector: 'body', apply: 'bg-background text-foreground' },\n      ]\n\n      let baseLayer = root.nodes.find(\n        (node): node is AtRule =>\n          node.type === 'atrule'\n          && node.name === 'layer'\n          && node.params === 'base'\n          && requiredRules.every(({ selector, apply }) =>\n            node.nodes?.some(\n              (rule): rule is Rule =>\n                rule.type === 'rule'\n                && rule.selector === selector\n                && rule.nodes.some(\n                  (applyRule): applyRule is AtRule =>\n                    applyRule.type === 'atrule'\n                    && applyRule.name === 'apply'\n                    && applyRule.params === apply,\n                ),\n            ),\n          ),\n      ) as AtRule | undefined\n\n      if (!baseLayer) {\n        baseLayer = postcss.atRule({\n          name: 'layer',\n          params: 'base',\n          raws: { semicolon: true, between: ' ', before: '\\n' },\n        })\n        root.append(baseLayer)\n        root.insertBefore(baseLayer, postcss.comment({ text: '---break---' }))\n      }\n\n      requiredRules.forEach(({ selector, apply }) => {\n        const existingRule = baseLayer?.nodes?.find(\n          (node): node is Rule =>\n            node.type === 'rule' && node.selector === selector,\n        )\n\n        if (!existingRule) {\n          baseLayer?.append(\n            postcss.rule({\n              selector,\n              nodes: [\n                postcss.atRule({\n                  name: 'apply',\n                  params: apply,\n                  raws: { semicolon: true, before: '\\n    ' },\n                }),\n              ],\n              raws: { semicolon: true, between: ' ', before: '\\n  ' },\n            }),\n          )\n        }\n      })\n    },\n  }\n}\n\nfunction updateCssVarsPlugin(\n  cssVars: z.infer<typeof registryItemCssVarsSchema>,\n) {\n  return {\n    postcssPlugin: 'update-css-vars',\n    Once(root: Root) {\n      let baseLayer = root.nodes.find(\n        node =>\n          node.type === 'atrule'\n          && node.name === 'layer'\n          && node.params === 'base',\n      ) as AtRule | undefined\n\n      if (!(baseLayer instanceof AtRule)) {\n        baseLayer = postcss.atRule({\n          name: 'layer',\n          params: 'base',\n          nodes: [],\n          raws: {\n            semicolon: true,\n            before: '\\n',\n            between: ' ',\n          },\n        })\n        root.append(baseLayer)\n        root.insertBefore(baseLayer, postcss.comment({ text: '---break---' }))\n      }\n\n      if (baseLayer !== undefined) {\n        // Add variables for each key in cssVars\n        Object.entries(cssVars).forEach(([key, vars]) => {\n          const selector = key === 'light' ? ':root' : `.${key}`\n          // TODO: Fix typecheck.\n          addOrUpdateVars(baseLayer as AtRule, selector, vars)\n        })\n      }\n    },\n  }\n}\n\nfunction removeConflictVars(root: Rule | Root) {\n  const rootRule = root.nodes.find(\n    (node): node is Rule => node.type === 'rule' && node.selector === ':root',\n  )\n\n  if (rootRule) {\n    const propsToRemove = ['--background', '--foreground']\n\n    rootRule.nodes\n      .filter(\n        (node): node is postcss.Declaration =>\n          node.type === 'decl' && propsToRemove.includes(node.prop),\n      )\n      .forEach(node => node.remove())\n\n    if (rootRule.nodes.length === 0) {\n      rootRule.remove()\n    }\n  }\n}\n\nfunction cleanupDefaultNextStylesPlugin() {\n  return {\n    postcssPlugin: 'cleanup-default-next-styles',\n    Once(root: Root) {\n      const bodyRule = root.nodes.find(\n        (node): node is Rule => node.type === 'rule' && node.selector === 'body',\n      )\n      if (bodyRule) {\n        // Remove color from the body node.\n        bodyRule.nodes\n          .find(\n            (node): node is postcss.Declaration =>\n              node.type === 'decl'\n              && node.prop === 'color'\n              && ['rgb(var(--foreground-rgb))', 'var(--foreground)'].includes(\n                node.value,\n              ),\n          )\n          ?.remove()\n\n        // Remove background: linear-gradient.\n        bodyRule.nodes\n          .find((node): node is postcss.Declaration => {\n            return (\n              node.type === 'decl'\n              && node.prop === 'background'\n              // This is only going to run on create project, so all good.\n              && (node.value.startsWith('linear-gradient')\n                || node.value === 'var(--background)')\n            )\n          })\n          ?.remove()\n\n        // Remove font-family: Arial, Helvetica, sans-serif;\n        bodyRule.nodes\n          .find(\n            (node): node is postcss.Declaration =>\n              node.type === 'decl'\n              && node.prop === 'font-family'\n              && node.value === 'Arial, Helvetica, sans-serif',\n          )\n          ?.remove()\n\n        // If the body rule is empty, remove it.\n        if (bodyRule.nodes.length === 0) {\n          bodyRule.remove()\n        }\n      }\n\n      removeConflictVars(root)\n\n      const darkRootRule = root.nodes.find(\n        (node): node is Rule =>\n          node.type === 'atrule'\n          && node.params === '(prefers-color-scheme: dark)',\n      )\n\n      if (darkRootRule) {\n        removeConflictVars(darkRootRule)\n        if (darkRootRule.nodes.length === 0) {\n          darkRootRule.remove()\n        }\n      }\n    },\n  }\n}\n\nfunction addOrUpdateVars(\n  baseLayer: AtRule,\n  selector: string,\n  vars: Record<string, string>,\n) {\n  let ruleNode = baseLayer.nodes?.find(\n    (node): node is Rule => node.type === 'rule' && node.selector === selector,\n  )\n\n  if (!ruleNode) {\n    if (Object.keys(vars).length > 0) {\n      ruleNode = postcss.rule({\n        selector,\n        raws: { between: ' ', before: '\\n  ' },\n      })\n      baseLayer.append(ruleNode)\n    }\n  }\n\n  Object.entries(vars).forEach(([key, value]) => {\n    const prop = `--${key.replace(/^--/, '')}`\n    const newDecl = postcss.decl({\n      prop,\n      value,\n      raws: { semicolon: true },\n    })\n\n    const existingDecl = ruleNode?.nodes.find(\n      (node): node is postcss.Declaration =>\n        node.type === 'decl' && node.prop === prop,\n    )\n\n    existingDecl ? existingDecl.replaceWith(newDecl) : ruleNode?.append(newDecl)\n  })\n}\n\nfunction updateCssVarsPluginV4(\n  cssVars: z.infer<typeof registryItemCssVarsSchema>,\n  options: {\n    overwriteCssVars?: boolean\n  },\n) {\n  return {\n    postcssPlugin: 'update-css-vars-v4',\n    Once(root: Root) {\n      Object.entries(cssVars).forEach(([key, vars]) => {\n        let selector = key === 'light' ? ':root' : `.${key}`\n\n        if (key === 'theme') {\n          selector = '@theme'\n          const themeNode = upsertThemeNode(root)\n          Object.entries(vars).forEach(([key, value]) => {\n            const prop = `--${key.replace(/^--/, '')}`\n            const newDecl = postcss.decl({\n              prop,\n              value,\n              raws: { semicolon: true },\n            })\n\n            const existingDecl = themeNode?.nodes?.find(\n              (node): node is postcss.Declaration =>\n                node.type === 'decl' && node.prop === prop,\n            )\n\n            // Only overwrite if overwriteCssVars is true\n            // i.e for registry:theme and registry:style\n            // We do not want new components to overwrite existing vars.\n            // Keep user defined vars.\n            if (options.overwriteCssVars) {\n              if (existingDecl) {\n                existingDecl.replaceWith(newDecl)\n              }\n              else {\n                themeNode?.append(newDecl)\n              }\n            }\n            else {\n              if (!existingDecl) {\n                themeNode?.append(newDecl)\n              }\n            }\n          })\n          return\n        }\n\n        let ruleNode = root.nodes?.find(\n          (node): node is Rule =>\n            node.type === 'rule' && node.selector === selector,\n        )\n\n        if (!ruleNode && Object.keys(vars).length > 0) {\n          ruleNode = postcss.rule({\n            selector,\n            nodes: [],\n            raws: { semicolon: true, between: ' ', before: '\\n' },\n          })\n          root.append(ruleNode)\n          root.insertBefore(ruleNode, postcss.comment({ text: '---break---' }))\n        }\n\n        Object.entries(vars).forEach(([key, value]) => {\n          let prop = `--${key.replace(/^--/, '')}`\n\n          // Special case for sidebar-background.\n          if (prop === '--sidebar-background') {\n            prop = '--sidebar'\n          }\n\n          if (isLocalHSLValue(value)) {\n            value = `hsl(${value})`\n          }\n\n          const newDecl = postcss.decl({\n            prop,\n            value,\n            raws: { semicolon: true },\n          })\n          const existingDecl = ruleNode?.nodes.find(\n            (node): node is postcss.Declaration =>\n              node.type === 'decl' && node.prop === prop,\n          )\n\n          // Only overwrite if overwriteCssVars is true\n          // i.e for registry:theme and registry:style\n          // We do not want new components to overwrite existing vars.\n          // Keep user defined vars.\n          if (options.overwriteCssVars) {\n            if (existingDecl) {\n              existingDecl.replaceWith(newDecl)\n            }\n            else {\n              ruleNode?.append(newDecl)\n            }\n          }\n          else {\n            if (!existingDecl) {\n              ruleNode?.append(newDecl)\n            }\n          }\n        })\n      })\n    },\n  }\n}\n\nfunction updateThemePlugin(cssVars: z.infer<typeof registryItemCssVarsSchema>) {\n  return {\n    postcssPlugin: 'update-theme',\n    Once(root: Root) {\n      // Find unique color names from light and dark.\n      const variables = Array.from(\n        new Set(\n          Object.keys(cssVars).flatMap(key =>\n            Object.keys(cssVars[key as keyof typeof cssVars] || {}),\n          ),\n        ),\n      )\n\n      if (!variables.length) {\n        return\n      }\n\n      const themeNode = upsertThemeNode(root)\n\n      const themeVarNodes = themeNode.nodes?.filter(\n        (node): node is postcss.Declaration =>\n          node.type === 'decl' && node.prop.startsWith('--'),\n      )\n\n      for (const variable of variables) {\n        const value = Object.values(cssVars).find(vars => vars[variable])?.[\n          variable\n        ]\n\n        if (!value) {\n          continue\n        }\n\n        if (variable === 'radius') {\n          const radiusVariables = {\n            sm: 'calc(var(--radius) - 4px)',\n            md: 'calc(var(--radius) - 2px)',\n            lg: 'var(--radius)',\n            xl: 'calc(var(--radius) + 4px)',\n          }\n          for (const [key, value] of Object.entries(radiusVariables)) {\n            const cssVarNode = postcss.decl({\n              prop: `--radius-${key}`,\n              value,\n              raws: { semicolon: true },\n            })\n            if (\n              themeNode?.nodes?.find(\n                (node): node is postcss.Declaration =>\n                  node.type === 'decl' && node.prop === cssVarNode.prop,\n              )\n            ) {\n              continue\n            }\n            themeNode?.append(cssVarNode)\n          }\n          continue\n        }\n\n        let prop\n          = isLocalHSLValue(value) || isColorValue(value)\n            ? `--color-${variable.replace(/^--/, '')}`\n            : `--${variable.replace(/^--/, '')}`\n        if (prop === '--color-sidebar-background') {\n          prop = '--color-sidebar'\n        }\n\n        let propValue = `var(--${variable})`\n        if (prop === '--color-sidebar') {\n          propValue = 'var(--sidebar)'\n        }\n\n        const cssVarNode = postcss.decl({\n          prop,\n          value: propValue,\n          raws: { semicolon: true },\n        })\n        const existingDecl = themeNode?.nodes?.find(\n          (node): node is postcss.Declaration =>\n            node.type === 'decl' && node.prop === cssVarNode.prop,\n        )\n        if (!existingDecl) {\n          if (themeVarNodes?.length) {\n            themeNode?.insertAfter(\n              themeVarNodes[themeVarNodes.length - 1],\n              cssVarNode,\n            )\n          }\n          else {\n            themeNode?.append(cssVarNode)\n          }\n        }\n      }\n    },\n  }\n}\n\nfunction upsertThemeNode(root: Root): AtRule {\n  let themeNode = root.nodes.find(\n    (node): node is AtRule =>\n      node.type === 'atrule'\n      && node.name === 'theme'\n      && node.params === 'inline',\n  )\n\n  if (!themeNode) {\n    themeNode = postcss.atRule({\n      name: 'theme',\n      params: 'inline',\n      nodes: [],\n      raws: { semicolon: true, between: ' ', before: '\\n' },\n    })\n    root.append(themeNode)\n    root.insertBefore(themeNode, postcss.comment({ text: '---break---' }))\n  }\n\n  return themeNode\n}\n\nfunction addCustomVariant({ params }: { params: string }) {\n  return {\n    postcssPlugin: 'add-custom-variant',\n    Once(root: Root) {\n      const customVariant = root.nodes.find(\n        (node): node is AtRule =>\n          node.type === 'atrule' && node.name === 'custom-variant',\n      )\n\n      if (!customVariant) {\n        // Find all import nodes\n        const importNodes = root.nodes.filter(\n          (node): node is AtRule =>\n            node.type === 'atrule' && node.name === 'import',\n        )\n\n        const variantNode = postcss.atRule({\n          name: 'custom-variant',\n          params,\n          raws: { semicolon: true, before: '\\n' },\n        })\n\n        if (importNodes.length > 0) {\n          // Insert after the last import\n          const lastImport = importNodes[importNodes.length - 1]\n          root.insertAfter(lastImport, variantNode)\n        }\n        else {\n          // If no imports, insert after the first node\n          root.insertAfter(root.nodes[0], variantNode)\n        }\n\n        root.insertBefore(variantNode, postcss.comment({ text: '---break---' }))\n      }\n    },\n  }\n}\n\nfunction addCustomImport({ params }: { params: string }) {\n  return {\n    postcssPlugin: 'add-custom-import',\n    Once(root: Root) {\n      const importNodes = root.nodes.filter(\n        (node): node is AtRule =>\n          node.type === 'atrule' && node.name === 'import',\n      )\n\n      // Find custom variant node (to ensure we insert before it)\n      const customVariantNode = root.nodes.find(\n        (node): node is AtRule =>\n          node.type === 'atrule' && node.name === 'custom-variant',\n      )\n\n      // Check if our specific import already exists\n      const hasImport = importNodes.some(\n        node => node.params.replace(/[\"']/g, '') === params,\n      )\n\n      if (!hasImport) {\n        const importNode = postcss.atRule({\n          name: 'import',\n          params: `\"${params}\"`,\n          raws: { semicolon: true, before: '\\n' },\n        })\n\n        if (importNodes.length > 0) {\n          // If there are existing imports, add after the last import\n          const lastImport = importNodes[importNodes.length - 1]\n          root.insertAfter(lastImport, importNode)\n        }\n        else if (customVariantNode) {\n          // If no imports but has custom-variant, insert before it\n          root.insertBefore(customVariantNode, importNode)\n          root.insertBefore(\n            customVariantNode,\n            postcss.comment({ text: '---break---' }),\n          )\n        }\n        else {\n          // If no imports and no custom-variant, insert at the start\n          root.prepend(importNode)\n          root.insertAfter(importNode, postcss.comment({ text: '---break---' }))\n        }\n      }\n    },\n  }\n}\n\nfunction updateTailwindConfigPlugin(\n  tailwindConfig: z.infer<typeof registryItemTailwindSchema>['config'],\n) {\n  return {\n    postcssPlugin: 'update-tailwind-config',\n    Once(root: Root) {\n      if (!tailwindConfig?.plugins) {\n        return\n      }\n\n      const quoteType = getQuoteType(root)\n      const quote = quoteType === 'single' ? '\\'' : '\"'\n\n      const pluginNodes = root.nodes.filter(\n        (node): node is AtRule =>\n          node.type === 'atrule' && node.name === 'plugin',\n      )\n\n      const lastPluginNode\n        = pluginNodes[pluginNodes.length - 1] || root.nodes[0]\n\n      for (const plugin of tailwindConfig.plugins) {\n        const pluginName = plugin.replace(/^require\\([\"']|[\"']\\)$/g, '')\n\n        // Check if the plugin is already present.\n        if (\n          pluginNodes.some((node) => {\n            return node.params.replace(/[\"']/g, '') === pluginName\n          })\n        ) {\n          continue\n        }\n\n        const pluginNode = postcss.atRule({\n          name: 'plugin',\n          params: `${quote}${pluginName}${quote}`,\n          raws: { semicolon: true, before: '\\n' },\n        })\n        root.insertAfter(lastPluginNode, pluginNode)\n        root.insertBefore(pluginNode, postcss.comment({ text: '---break---' }))\n      }\n    },\n  }\n}\n\nfunction updateTailwindConfigKeyframesPlugin(\n  tailwindConfig: z.infer<typeof registryItemTailwindSchema>['config'],\n) {\n  return {\n    postcssPlugin: 'update-tailwind-config-keyframes',\n    Once(root: Root) {\n      if (!tailwindConfig?.theme?.extend?.keyframes) {\n        return\n      }\n\n      const themeNode = upsertThemeNode(root)\n      const existingKeyFrameNodes = themeNode.nodes?.filter(\n        (node): node is AtRule =>\n          node.type === 'atrule' && node.name === 'keyframes',\n      )\n\n      const keyframeValueSchema = z.record(\n        z.string(),\n        z.record(z.string(), z.string()),\n      )\n\n      for (const [keyframeName, keyframeValue] of Object.entries(\n        tailwindConfig.theme.extend.keyframes,\n      )) {\n        if (typeof keyframeName !== 'string') {\n          continue\n        }\n\n        const parsedKeyframeValue = keyframeValueSchema.safeParse(keyframeValue)\n\n        if (!parsedKeyframeValue.success) {\n          continue\n        }\n\n        if (\n          existingKeyFrameNodes?.find(\n            (node): node is postcss.AtRule =>\n              node.type === 'atrule'\n              && node.name === 'keyframes'\n              && node.params === keyframeName,\n          )\n        ) {\n          continue\n        }\n\n        const keyframeNode = postcss.atRule({\n          name: 'keyframes',\n          params: keyframeName,\n          nodes: [],\n          raws: { semicolon: true, between: ' ', before: '\\n  ' },\n        })\n\n        for (const [key, values] of Object.entries(parsedKeyframeValue.data)) {\n          const rule = postcss.rule({\n            selector: key,\n            nodes: Object.entries(values).map(([key, value]) =>\n              postcss.decl({\n                prop: key,\n                value,\n                raws: { semicolon: true, before: '\\n      ', between: ': ' },\n              }),\n            ),\n            raws: { semicolon: true, between: ' ', before: '\\n    ' },\n          })\n          keyframeNode.append(rule)\n        }\n\n        themeNode.append(keyframeNode)\n        themeNode.insertBefore(\n          keyframeNode,\n          postcss.comment({ text: '---break---' }),\n        )\n      }\n    },\n  }\n}\n\nfunction updateTailwindConfigAnimationPlugin(\n  tailwindConfig: z.infer<typeof registryItemTailwindSchema>['config'],\n) {\n  return {\n    postcssPlugin: 'update-tailwind-config-animation',\n    Once(root: Root) {\n      if (!tailwindConfig?.theme?.extend?.animation) {\n        return\n      }\n\n      const themeNode = upsertThemeNode(root)\n      const existingAnimationNodes = themeNode.nodes?.filter(\n        (node): node is postcss.Declaration =>\n          node.type === 'decl' && node.prop.startsWith('--animate-'),\n      )\n\n      const parsedAnimationValue = z\n        .record(z.string(), z.string())\n        .safeParse(tailwindConfig.theme.extend.animation)\n      if (!parsedAnimationValue.success) {\n        return\n      }\n\n      for (const [key, value] of Object.entries(parsedAnimationValue.data)) {\n        const prop = `--animate-${key}`\n        if (\n          existingAnimationNodes?.find(\n            (node): node is postcss.Declaration => node.prop === prop,\n          )\n        ) {\n          continue\n        }\n\n        const animationNode = postcss.decl({\n          prop,\n          value,\n          raws: { semicolon: true, between: ': ', before: '\\n  ' },\n        })\n        themeNode.append(animationNode)\n      }\n    },\n  }\n}\n\nfunction getQuoteType(root: Root): 'single' | 'double' {\n  const firstNode = root.nodes[0]\n  const raw = firstNode.toString()\n\n  if (raw.includes('\\'')) {\n    return 'single'\n  }\n  return 'double'\n}\n\nexport function isLocalHSLValue(value: string) {\n  if (\n    value.startsWith('hsl')\n    || value.startsWith('rgb')\n    || value.startsWith('#')\n    || value.startsWith('oklch')\n  ) {\n    return false\n  }\n\n  const chunks = value.split(' ')\n\n  return (\n    chunks.length === 3\n    && chunks.slice(1, 3).every(chunk => chunk.includes('%'))\n  )\n}\n\nexport function isColorValue(value: string) {\n  return (\n    value.startsWith('hsl')\n    || value.startsWith('rgb')\n    || value.startsWith('#')\n    || value.startsWith('oklch')\n  )\n}\n","import type { RegistryItem } from '@/src/registry/schema'\nimport type { Config } from '@/src/utils/get-config'\nimport { addDependency } from 'nypm'\nimport { spinner } from '@/src/utils/spinner'\n\nexport async function updateDependencies(\n  dependencies: RegistryItem['dependencies'],\n  config: Config,\n  options: {\n    silent?: boolean\n    dev?: boolean\n  },\n) {\n  dependencies = Array.from(new Set(dependencies))\n  if (!dependencies?.length) {\n    return\n  }\n\n  options = {\n    silent: false,\n    ...options,\n  }\n\n  const dependenciesSpinner = spinner(`Installing dependencies.`, { silent: options.silent })?.start()\n  dependenciesSpinner?.start()\n\n  await addDependency(dependencies, { cwd: config.resolvedPaths.cwd, silent: true, dev: options?.dev })\n  dependenciesSpinner?.succeed()\n}\n","import type { CodemodPlugin } from 'vue-metamorph'\nimport type * as z from 'zod'\nimport type { TransformOpts } from '.'\nimport type { registryBaseColorSchema } from '@/src/registry/schema'\n\nexport function transformCssVars(opts: TransformOpts): CodemodPlugin {\n  return {\n    type: 'codemod',\n    name: 'add prefix to tailwind classes',\n\n    transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST } }) {\n      let transformCount = 0\n      const { baseColor, config } = opts\n\n      if (config.tailwind?.cssVariables || !baseColor?.inlineColors)\n        return transformCount\n\n      for (const scriptAST of scriptASTs) {\n        traverseScriptAST(scriptAST, {\n          visitLiteral(path) {\n            if (path.parent.value.type !== 'ImportDeclaration' && typeof path.node.value === 'string') {\n            // mutate the node\n              path.node.value = applyColorMapping(path.node.value.replace(/\"/g, ''), baseColor.inlineColors)\n              transformCount++\n            }\n\n            return this.traverse(path)\n          },\n        })\n      }\n\n      if (sfcAST) {\n        traverseTemplateAST(sfcAST, {\n          enterNode(node) {\n            if (node.type === 'Literal' && typeof node.value === 'string') {\n              if (!['BinaryExpression', 'Property'].includes(node.parent?.type ?? '')) {\n                node.value = applyColorMapping(node.value.replace(/\"/g, ''), baseColor.inlineColors)\n                transformCount++\n              }\n            }\n            // handle class attribute without binding\n            else if (node.type === 'VLiteral' && typeof node.value === 'string') {\n              if (node.parent.key.name === 'class') {\n                node.value = `\"${applyColorMapping(node.value.replace(/\"/g, ''), baseColor.inlineColors)}\"`\n                transformCount++\n              }\n            }\n          },\n          leaveNode() {\n\n          },\n        })\n      }\n\n      return transformCount\n    },\n  }\n}\n\n// Splits a className into variant-name-alpha.\n// eg. hover:bg-primary-100 -> [hover, bg-primary, 100]\nexport function splitClassName(className: string): (string | null)[] {\n  if (!className.includes('/') && !className.includes(':'))\n    return [null, className, null]\n\n  const parts: (string | null)[] = []\n  // First we split to find the alpha.\n  const [rest, alpha] = className.split('/')\n\n  // Check if rest has a colon.\n  if (!rest.includes(':'))\n    return [null, rest, alpha]\n\n  // Next we split the rest by the colon.\n  const split = rest.split(':')\n\n  // We take the last item from the split as the name.\n  const name = split.pop()\n\n  // We glue back the rest of the split.\n  const variant = split.join(':')\n\n  // Finally we push the variant, name and alpha.\n  parts.push(variant ?? null, name ?? null, alpha ?? null)\n\n  return parts\n}\n\nconst PREFIXES = ['bg-', 'text-', 'border-', 'ring-offset-', 'ring-']\n\nexport function applyColorMapping(\n  input: string,\n  mapping: z.infer<typeof registryBaseColorSchema>['inlineColors'],\n) {\n  // Handle border classes.\n  if (input.includes(' border '))\n    input = input.replace(' border ', ' border border-border ')\n\n  const classNames = input.split(' ')\n  const lightMode = new Set<string>()\n  const darkMode = new Set<string>()\n  for (const className of classNames) {\n    const [variant, value, modifier] = splitClassName(className)\n    const prefix = PREFIXES.find(prefix => value?.startsWith(prefix))\n    if (!prefix) {\n      if (!lightMode.has(className))\n        lightMode.add(className)\n\n      continue\n    }\n\n    const needle = value?.replace(prefix, '')\n    if (needle && needle in mapping.light) {\n      lightMode.add(\n        [variant, `${prefix}${mapping.light[needle]}`]\n          .filter(Boolean)\n          .join(':') + (modifier ? `/${modifier}` : ''),\n      )\n\n      darkMode.add(\n        ['dark', variant, `${prefix}${mapping.dark[needle]}`]\n          .filter(Boolean)\n          .join(':') + (modifier ? `/${modifier}` : ''),\n      )\n      continue\n    }\n\n    if (!lightMode.has(className))\n      lightMode.add(className)\n  }\n\n  return [...Array.from(lightMode), ...Array.from(darkMode)].join(' ').trim()\n}\n","import type { CodemodPlugin } from 'vue-metamorph'\nimport type { TransformOpts } from '.'\n\nexport function transformImport(opts: TransformOpts): CodemodPlugin {\n  return {\n    type: 'codemod',\n    name: 'modify import based on user config',\n\n    transform({ scriptASTs, utils: { traverseScriptAST } }) {\n      const transformCount = 0\n      const { config, isRemote } = opts\n      const utilsImport = '@/lib/utils'\n\n      for (const scriptAST of scriptASTs) {\n        traverseScriptAST(scriptAST, {\n          visitImportDeclaration(path) {\n            if (typeof path.node.source.value === 'string') {\n              const sourcePath = path.node.source.value\n\n              // Alias to `moduleSpecifier`\n              const updatedImport = updateImportAliases(sourcePath, config, isRemote)\n              path.node.source.value = updatedImport\n\n              // Replace `import { cn } from \"@/lib/utils\"`\n              if (updatedImport === utilsImport) {\n                const namedImports = path.node.specifiers?.map(node => node.local?.name ?? '') ?? []\n                const cnImport = namedImports.find(i => i === 'cn')\n                if (cnImport) {\n                  path.node.source.value = updatedImport === utilsImport ? sourcePath.replace(utilsImport, config.aliases.utils) : config.aliases.utils\n                }\n              }\n            }\n            return this.traverse(path)\n          },\n        })\n      }\n\n      return transformCount\n    },\n  }\n}\n\nfunction updateImportAliases(\n  moduleSpecifier: string,\n  config: TransformOpts['config'],\n  isRemote: boolean = false,\n) {\n  // Not a local import.\n  if (!moduleSpecifier.startsWith('@/') && !isRemote) {\n    return moduleSpecifier\n  }\n\n  // This treats the remote as coming from a faux registry.\n  if (isRemote && moduleSpecifier.startsWith('@/')) {\n    moduleSpecifier = moduleSpecifier.replace(/^@\\//, `@/registry/new-york/`)\n  }\n\n  // Not a registry import.\n  if (!moduleSpecifier.startsWith('@/registry/')) {\n    // We fix the alias and return.\n    const alias = config.aliases.components.split('/')[0]\n    return moduleSpecifier.replace(/^@\\//, `${alias}/`)\n  }\n\n  if (moduleSpecifier.match(/^@\\/registry\\/(.+)\\/ui/)) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/ui/,\n      config.aliases.ui ?? `${config.aliases.components}/ui`,\n    )\n  }\n\n  if (\n    config.aliases.components\n    && moduleSpecifier.match(/^@\\/registry\\/(.+)\\/components/)\n  ) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/components/,\n      config.aliases.components,\n    )\n  }\n\n  if (config.aliases.lib && moduleSpecifier.match(/^@\\/registry\\/(.+)\\/lib/)) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/lib/,\n      config.aliases.lib,\n    )\n  }\n\n  if (\n    config.aliases.composables\n    && moduleSpecifier.match(/^@\\/registry\\/(.+)\\/composables/)\n  ) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/composables/,\n      config.aliases.composables,\n    )\n  }\n\n  return moduleSpecifier.replace(\n    /^@\\/registry\\/[^/]+/,\n    config.aliases.components,\n  )\n}\n","import type { TransformOpts } from '.'\nimport { transform } from '@unovue/detypes'\n\nexport async function transformSFC(opts: TransformOpts) {\n  if (opts.config?.typescript)\n    return opts.raw\n\n  return await transformByDetype(opts.raw, opts.filename).then(res => res as string)\n}\n\nexport async function transformByDetype(content: string, filename: string) {\n  return await transform(content, filename, {\n    removeTsComments: true,\n    prettierOptions: {\n      proseWrap: 'never',\n    },\n  })\n}\n","import type { CodemodPlugin } from 'vue-metamorph'\nimport type { TransformOpts } from '.'\nimport { getProjectTailwindVersionFromConfig, type TailwindVersion } from '../get-project-info'\nimport { splitClassName } from './transform-css-vars'\n\nexport async function transformTwPrefix(opts: TransformOpts): Promise<CodemodPlugin> {\n  const tailwindVersion = await getProjectTailwindVersionFromConfig(opts.config)\n\n  return {\n    type: 'codemod',\n    name: 'add prefix to tailwind classes',\n\n    transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST, astHelpers } }) {\n      let transformCount = 0\n      const { config } = opts\n\n      if (!config.tailwind?.prefix)\n        return transformCount\n\n      // Helper function to check if a node is a variant property\n      function isVariantProperty(node: any): boolean {\n        if (node.type === 'Property') {\n          // Check if property key is \"variant\", \"size\", etc.\n          if (node.key?.type === 'Identifier') {\n            const keyName = node.key.name\n            return ['variant', 'size', 'color', 'type', 'state'].includes(keyName)\n          }\n          if (node.key?.type === 'Literal' && typeof node.key.value === 'string') {\n            const keyName = node.key.value\n            return ['variant', 'size', 'color', 'type', 'state'].includes(keyName)\n          }\n        }\n        return false\n      }\n\n      function traverseExpression(expression: any): void {\n        // Handle cn() function calls\n        if (expression.type === 'CallExpression'\n          && expression.callee?.type === 'Identifier'\n          && expression.callee.name === 'cn') {\n          expression.arguments.forEach((arg: any) => {\n            if (arg.type === 'Literal' && typeof arg.value === 'string') {\n              arg.value = applyPrefix(arg.value, config.tailwind.prefix, tailwindVersion)\n              transformCount++\n            }\n            else if (arg.type === 'ConditionalExpression') {\n              // Only transform consequent and alternate, not the test condition\n              if (arg.consequent?.type === 'Literal' && typeof arg.consequent.value === 'string') {\n                arg.consequent.value = applyPrefix(arg.consequent.value, config.tailwind.prefix, tailwindVersion)\n                transformCount++\n              }\n              if (arg.alternate?.type === 'Literal' && typeof arg.alternate.value === 'string') {\n                arg.alternate.value = applyPrefix(arg.alternate.value, config.tailwind.prefix, tailwindVersion)\n                transformCount++\n              }\n            }\n            else if (arg.type === 'BinaryExpression') {\n              // Only transform the right side if it's a string literal\n              if (arg.right?.type === 'Literal' && typeof arg.right.value === 'string') {\n                arg.right.value = applyPrefix(arg.right.value, config.tailwind.prefix, tailwindVersion)\n                transformCount++\n              }\n            }\n            else if (arg.type === 'ObjectExpression') {\n              // Handle object expressions like { variant: 'ghost', class: 'flex' }\n              arg.properties.forEach((prop: any) => {\n                if (prop.type === 'Property' && prop.value?.type === 'Literal' && typeof prop.value.value === 'string') {\n                  // Only transform if it's NOT a variant property\n                  if (!isVariantProperty(prop)) {\n                    prop.value.value = applyPrefix(prop.value.value, config.tailwind.prefix, tailwindVersion)\n                    transformCount++\n                  }\n                }\n              })\n            }\n            else {\n              // For other expression types, use astHelpers to find all literals\n              const literals = astHelpers.findAll(arg, { type: 'Literal' })\n              literals.forEach((literal: any) => {\n                if (typeof literal.value === 'string') {\n                  // Check if this literal is part of a variant property\n                  let shouldTransform = true\n                  let parent = literal.parent\n                  while (parent) {\n                    if (isVariantProperty(parent)) {\n                      shouldTransform = false\n                      break\n                    }\n                    parent = parent.parent\n                  }\n\n                  if (shouldTransform) {\n                    literal.value = applyPrefix(literal.value, config.tailwind.prefix, tailwindVersion)\n                    transformCount++\n                  }\n                }\n              })\n            }\n          })\n        }\n        // Handle other expression types recursively if needed\n        else if (expression.type === 'ConditionalExpression') {\n          // Only transform consequent and alternate, not the test condition\n          if (expression.consequent)\n            traverseExpression(expression.consequent)\n          if (expression.alternate)\n            traverseExpression(expression.alternate)\n        }\n        else if (expression.type === 'BinaryExpression') {\n          if (expression.left)\n            traverseExpression(expression.left)\n          if (expression.right)\n            traverseExpression(expression.right)\n        }\n      }\n\n      for (const scriptAST of scriptASTs) {\n        traverseScriptAST(scriptAST, {\n          visitCallExpression(path) {\n            // Handle cva function calls\n            if (path.node.callee.type === 'Identifier' && path.node.callee.name === 'cva') {\n              const args = path.node.arguments\n\n              // cva(base, ...)\n              if (args[0]?.type === 'Literal' && typeof args[0].value === 'string') {\n                args[0].value = applyPrefix(args[0].value, config.tailwind.prefix, tailwindVersion)\n                transformCount++\n              }\n\n              // cva(..., { variants: { ... } })\n              if (args[1]?.type === 'ObjectExpression') {\n                const variantsProperty = args[1].properties.find(\n                  prop => prop.type === 'Property'\n                    && prop.key.type === 'Identifier'\n                    && prop.key.name === 'variants',\n                )\n\n                if (variantsProperty && variantsProperty.type === 'Property' && variantsProperty.value.type === 'ObjectExpression') {\n                  // Only transform class strings in variants, not the variant names themselves\n                  const allProperties = astHelpers.findAll(variantsProperty.value, { type: 'Property' })\n                  allProperties.forEach((prop: any) => {\n                    if (prop.value?.type === 'Literal' && typeof prop.value.value === 'string') {\n                      prop.value.value = applyPrefix(prop.value.value, config.tailwind.prefix, tailwindVersion)\n                      transformCount++\n                    }\n                  })\n                }\n              }\n            }\n\n            // Handle cn function calls\n            if (path.node.callee.type === 'Identifier' && path.node.callee.name === 'cn') {\n              path.node.arguments.forEach((arg) => {\n                if (arg.type === 'Literal' && typeof arg.value === 'string') {\n                  arg.value = applyPrefix(arg.value, config.tailwind.prefix, tailwindVersion)\n                  transformCount++\n                }\n                else if (arg.type === 'ConditionalExpression') {\n                  // Only transform consequent and alternate, not the test condition\n                  if (arg.consequent?.type === 'Literal' && typeof arg.consequent.value === 'string') {\n                    arg.consequent.value = applyPrefix(arg.consequent.value, config.tailwind.prefix, tailwindVersion)\n                    transformCount++\n                  }\n                  if (arg.alternate?.type === 'Literal' && typeof arg.alternate.value === 'string') {\n                    arg.alternate.value = applyPrefix(arg.alternate.value, config.tailwind.prefix, tailwindVersion)\n                    transformCount++\n                  }\n                }\n                else if (arg.type === 'BinaryExpression') {\n                  // Only transform the right side if it's a string literal\n                  if (arg.right?.type === 'Literal' && typeof arg.right.value === 'string') {\n                    arg.right.value = applyPrefix(arg.right.value, config.tailwind.prefix, tailwindVersion)\n                    transformCount++\n                  }\n                }\n                else if (arg.type === 'ObjectExpression') {\n                  // Handle object expressions like { variant: 'ghost', class: 'flex' }\n                  arg.properties.forEach((prop: any) => {\n                    if (prop.type === 'Property' && prop.value?.type === 'Literal' && typeof prop.value.value === 'string') {\n                      // Only transform if it's NOT a variant property\n                      if (!isVariantProperty(prop)) {\n                        prop.value.value = applyPrefix(prop.value.value, config.tailwind.prefix, tailwindVersion)\n                        transformCount++\n                      }\n                    }\n                  })\n                }\n                else {\n                  // For other complex expressions, find all string literals but exclude variant properties\n                  const literals = astHelpers.findAll(arg, { type: 'Literal' })\n                  literals.forEach((literal) => {\n                    if (typeof literal.value === 'string') {\n                      // Check if this literal is part of a variant property\n                      let shouldTransform = true\n                      let parent = literal.parent\n                      while (parent) {\n                        if (isVariantProperty(parent)) {\n                          shouldTransform = false\n                          break\n                        }\n                        parent = parent.parent\n                      }\n\n                      if (shouldTransform) {\n                        literal.value = applyPrefix(literal.value, config.tailwind.prefix, tailwindVersion)\n                        transformCount++\n                      }\n                    }\n                  })\n                }\n              })\n            }\n\n            return this.traverse(path)\n          },\n        })\n      }\n\n      if (sfcAST) {\n        traverseTemplateAST(sfcAST, {\n          enterNode(node) {\n            // Handle v-bind:class, :class, v-bind:className, :className\n            if (node.type === 'VAttribute' && node.key.type === 'VDirectiveKey') {\n              if (node.key.argument?.type === 'VIdentifier') {\n                const argName = node.key.argument.name\n                if (['class', 'className', 'classes', 'classNames'].includes(argName)) {\n                  // Find literals but exclude condition values\n                  if (node.value?.type === 'VExpressionContainer' && node.value.expression) {\n                    traverseExpression(node.value.expression)\n                  }\n                }\n              }\n            }\n            // Handle static class attributes\n            else if (node.type === 'VLiteral' && typeof node.value === 'string') {\n              if (node.parent?.type === 'VAttribute'\n                && node.parent.key?.type === 'VIdentifier'\n                && ['class', 'className', 'classes', 'classNames'].includes(node.parent.key.name)) {\n                const cleanValue = node.value.replace(/\"/g, '')\n                const prefixedValue = applyPrefix(cleanValue, config.tailwind.prefix, tailwindVersion)\n                node.value = `\"${prefixedValue}\"`\n                transformCount++\n              }\n            }\n          },\n          leaveNode() {\n          },\n        })\n      }\n\n      return transformCount\n    },\n  }\n}\n\nexport function applyPrefix(input: string, prefix: string = '', tailwindVersion: TailwindVersion) {\n  if (tailwindVersion === 'v3') {\n    return input\n      .split(' ')\n      .map((className) => {\n        const [variant, value, modifier] = splitClassName(className)\n        if (variant) {\n          return modifier\n            ? `${variant}:${prefix}${value}/${modifier}`\n            : `${variant}:${prefix}${value}`\n        }\n        else {\n          return modifier\n            ? `${prefix}${value}/${modifier}`\n            : `${prefix}${value}`\n        }\n      })\n      .join(' ')\n  }\n\n  return input\n    .split(' ')\n    .map(className =>\n      className.indexOf(`${prefix}:`) === 0\n        ? className\n        : `${prefix}:${className.trim()}`,\n    )\n    .join(' ')\n}\n\nexport function applyPrefixesCss(css: string, prefix: string, tailwindVersion: TailwindVersion) {\n  const lines = css.split('\\n')\n  for (const line of lines) {\n    if (line.includes('@apply')) {\n      const originalTWCls = line.replace('@apply', '').trim()\n      const prefixedTwCls = applyPrefix(originalTWCls, prefix, tailwindVersion)\n      css = css.replace(originalTWCls, prefixedTwCls)\n    }\n  }\n  return css\n}\n","export const ICON_LIBRARIES = {\n  lucide: {\n    name: 'lucide-vue-next',\n    package: 'lucide-vue-next',\n    import: 'lucide-vue-next',\n  },\n  radix: {\n    name: '@radix-icons/vue',\n    package: '@radix-icons/vue',\n    import: '@radix-icons/vue',\n  },\n}\n","import type { CodemodPlugin } from 'vue-metamorph'\nimport type { TransformOpts } from '.'\nimport { ICON_LIBRARIES } from '@/src/utils/icon-libraries'\n\n// Lucide is the default icon library in the registry.\nconst SOURCE_LIBRARY = 'lucide'\n\nexport function transformIcons(opts: TransformOpts, registryIcons: Record<string, Record<string, string>>): CodemodPlugin {\n  return {\n    type: 'codemod',\n    name: 'modify import of icon library on user config',\n\n    transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST } }) {\n      let transformCount = 0\n      const { config } = opts\n\n      // No transform if we cannot read the icon library.\n      if (!config.iconLibrary || !(config.iconLibrary in ICON_LIBRARIES)) {\n        return transformCount\n      }\n\n      const sourceLibrary = SOURCE_LIBRARY\n      const targetLibrary = config.iconLibrary\n\n      if (sourceLibrary === targetLibrary) {\n        return transformCount\n      }\n\n      // Map<orignalIcon, targetedIcon>\n      const targetedIconsMap: Map<string, string> = new Map()\n      for (const scriptAST of scriptASTs) {\n        traverseScriptAST(scriptAST, {\n\n          visitImportDeclaration(path) {\n            if (![ICON_LIBRARIES.radix.import, ICON_LIBRARIES.lucide.import].includes(`${path.node.source.value}`))\n              return this.traverse(path)\n\n            for (const specifier of path.node.specifiers ?? []) {\n              if (specifier.type === 'ImportSpecifier') {\n                const iconName = specifier.imported.name\n\n                const targetedIcon = registryIcons[iconName]?.[targetLibrary]\n\n                if (!targetedIcon || targetedIconsMap.has(targetedIcon)) {\n                  continue\n                }\n\n                targetedIconsMap.set(iconName, targetedIcon)\n                specifier.imported.name = targetedIcon\n              }\n            }\n\n            if (targetedIconsMap.size > 0)\n              path.node.source.value = ICON_LIBRARIES[targetLibrary as keyof typeof ICON_LIBRARIES].import\n\n            return this.traverse(path)\n          },\n        })\n\n        if (sfcAST) {\n          traverseTemplateAST(sfcAST, {\n            enterNode(node) {\n              if (node.type === 'VElement' && targetedIconsMap.has(node.rawName)) {\n                node.rawName = targetedIconsMap.get(node.rawName) ?? ''\n                transformCount++\n              }\n            },\n          })\n        }\n      }\n\n      return transformCount\n    },\n  }\n}\n","import type { z } from 'zod'\nimport type { registryBaseColorSchema } from '@/src/registry/schema'\nimport type { Config } from '@/src/utils/get-config'\nimport { transform as metaTransform } from 'vue-metamorph'\nimport { getRegistryIcons } from '@/src/registry/api'\nimport { transformCssVars } from '@/src/utils/transformers/transform-css-vars'\nimport { transformImport } from '@/src/utils/transformers/transform-import'\nimport { transformSFC } from '@/src/utils/transformers/transform-sfc'\nimport { transformTwPrefix } from '@/src/utils/transformers/transform-tw-prefix'\nimport { transformIcons } from './transform-icons'\n\nexport interface TransformOpts {\n  filename: string\n  raw: string\n  config: Config\n  baseColor?: z.infer<typeof registryBaseColorSchema>\n  isRemote?: boolean\n}\n\nexport async function transform(opts: TransformOpts) {\n  const source = await transformSFC(opts)\n\n  const registryIcons = await getRegistryIcons()\n\n  return metaTransform(source, opts.filename, [\n    transformImport(opts),\n    transformCssVars(opts),\n    await transformTwPrefix(opts),\n    transformIcons(opts, registryIcons),\n  ]).code\n}\n","import type { z } from 'zod'\nimport type { RegistryItem, registryItemFileSchema } from '@/src/registry/schema'\nimport type { ProjectInfo } from '@/src/utils/get-project-info'\nimport { existsSync, promises as fs } from 'node:fs'\nimport { tmpdir } from 'node:os'\nimport path, { basename, dirname } from 'pathe'\nimport prompts from 'prompts'\nimport { transform as metaTransform } from 'vue-metamorph'\nimport {\n  getRegistryBaseColor,\n} from '@/src/registry/api'\nimport { type Config, getTSConfig } from '@/src/utils/get-config'\nimport { getProjectInfo } from '@/src/utils/get-project-info'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\nimport { spinner } from '@/src/utils/spinner'\nimport { transform } from '@/src/utils/transformers'\n// import { resolveImport } from '../resolve-import'\n\nexport async function updateFiles(\n  files: RegistryItem['files'],\n  config: Config,\n  options: {\n    overwrite?: boolean\n    force?: boolean\n    silent?: boolean\n    rootSpinner?: ReturnType<typeof spinner>\n    isRemote?: boolean\n  },\n) {\n  if (!files?.length) {\n    return {\n      filesCreated: [],\n      filesUpdated: [],\n      filesSkipped: [],\n    }\n  }\n  options = {\n    overwrite: false,\n    force: false,\n    silent: false,\n    isRemote: false,\n    ...options,\n  }\n  const filesCreatedSpinner = spinner(`Updating files.`, {\n    silent: options.silent,\n  })?.start()\n\n  const [projectInfo, baseColor] = await Promise.all([\n    getProjectInfo(config.resolvedPaths.cwd),\n    getRegistryBaseColor(config.tailwind.baseColor),\n  ])\n\n  let filesCreated: string[] = []\n  let filesUpdated: string[] = []\n  let filesSkipped: string[] = []\n  const folderSkipped = new Map<string, boolean>()\n\n  let tempRoot = ''\n  if (!config.typescript) {\n    for (const file of files) {\n      if (!file.content) {\n        continue\n      }\n      const dirName = path.dirname(file.path)\n      tempRoot = path.join(tmpdir(), 'shadcn-vue')\n\n      // Create the full temp directory path with original directory structure\n      const tempDir = path.join(tempRoot, 'registry', config.style, dirName)\n      const tempPath = path.join(tempRoot, 'registry', config.style, file.path)\n\n      await fs.mkdir(tempDir, { recursive: true })\n      await fs.writeFile(tempPath, file.content, 'utf-8')\n    }\n\n    await fs.cp(path.join(process.cwd(), 'node_modules'), tempRoot, {\n      recursive: true,\n      filter: src => !src.includes('/.bin/'),\n    })\n    await fs.writeFile(path.join(tempRoot, 'tsconfig.json'), `{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"./*\"]\n    },\n  },\n  \"include\": [\"**/*.vue\", \"**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}`, 'utf8')\n  }\n\n  for (const file of files) {\n    if (!file.content) {\n      continue\n    }\n\n    let filePath = resolveFilePath(file, config, {\n      framework: projectInfo?.framework.name,\n      commonRoot: findCommonRoot(\n        files.map(f => f.path),\n        file.path,\n      ),\n    })\n\n    if (!filePath) {\n      continue\n    }\n\n    const fileName = basename(file.path)\n    const targetDir = path.dirname(filePath)\n\n    if (!config.typescript) {\n      filePath = filePath.replace(/\\.ts?$/, match => '.js')\n    }\n\n    const existingFile = existsSync(filePath)\n\n    // Run our transformers.\n    const content = await transform({\n      filename: path.join(tempRoot, 'registry', config.style, file.path),\n      raw: file.content,\n      config,\n      baseColor,\n      isRemote: options.isRemote,\n    })\n\n    // Skip the file if it already exists and the content is the same.\n    if (existingFile) {\n      const existingFileContent = await fs.readFile(filePath, 'utf-8')\n      const [normalizedExisting, normalizedNew] = await Promise.all([\n        getNormalizedFileContent(existingFileContent),\n        getNormalizedFileContent(content),\n      ])\n      if (normalizedExisting === normalizedNew) {\n        filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath))\n        continue\n      }\n    }\n\n    // Check for existing folder in UI component only\n    if (file.type === 'registry:ui') {\n      const folderName = basename(dirname(filePath))\n      const existingFolder = existsSync(dirname(filePath))\n\n      if (!existingFolder) {\n        folderSkipped.set(folderName, false)\n      }\n\n      if (!folderSkipped.has(folderName) && !options.overwrite) {\n        filesCreatedSpinner.stop()\n        const { overwrite } = await prompts({\n          type: 'confirm',\n          name: 'overwrite',\n          message: `The folder ${highlighter.info(folderName)} already exists. Would you like to overwrite?`,\n          initial: false,\n        })\n        folderSkipped.set(folderName, !overwrite)\n        filesCreatedSpinner?.start()\n      }\n\n      if (folderSkipped.get(folderName) === true) {\n        filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath))\n        continue\n      }\n    }\n    else {\n      if (existingFile && !options.overwrite) {\n        filesCreatedSpinner.stop()\n        if (options.rootSpinner) {\n          options.rootSpinner.stop()\n        }\n        const { overwrite } = await prompts({\n          type: 'confirm',\n          name: 'overwrite',\n          message: `The file ${highlighter.info(\n            fileName,\n          )} already exists. Would you like to overwrite?`,\n          initial: false,\n        })\n\n        if (!overwrite) {\n          filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath))\n          if (options.rootSpinner) {\n            options.rootSpinner.start()\n          }\n          continue\n        }\n        filesCreatedSpinner?.start()\n        if (options.rootSpinner) {\n          options.rootSpinner.start()\n        }\n      }\n    }\n\n    // Create the target directory if it doesn't exist.\n    if (!existsSync(targetDir)) {\n      await fs.mkdir(targetDir, { recursive: true })\n    }\n\n    await fs.writeFile(filePath, content, 'utf-8')\n    existingFile\n      ? filesUpdated.push(path.relative(config.resolvedPaths.cwd, filePath))\n      : filesCreated.push(path.relative(config.resolvedPaths.cwd, filePath))\n  }\n\n  const allFiles = [...filesCreated, ...filesUpdated, ...filesSkipped]\n  const updatedFiles = await resolveImports(allFiles, config)\n\n  // Let's update filesUpdated with the updated files.\n  filesUpdated.push(...updatedFiles)\n\n  // If a file is in filesCreated and filesUpdated, we should remove it from filesUpdated.\n  filesUpdated = filesUpdated.filter(file => !filesCreated.includes(file))\n\n  const hasUpdatedFiles = filesCreated.length || filesUpdated.length\n  if (!hasUpdatedFiles && !filesSkipped.length) {\n    filesCreatedSpinner?.info('No files updated.')\n  }\n\n  // Remove duplicates.\n  filesCreated = Array.from(new Set(filesCreated))\n  filesUpdated = Array.from(new Set(filesUpdated))\n  filesSkipped = Array.from(new Set(filesSkipped))\n\n  if (filesCreated.length) {\n    filesCreatedSpinner?.succeed(\n      `Created ${filesCreated.length} ${\n        filesCreated.length === 1 ? 'file' : 'files'\n      }:`,\n    )\n    if (!options.silent) {\n      for (const file of filesCreated) {\n        logger.log(`  - ${file}`)\n      }\n    }\n  }\n  else {\n    filesCreatedSpinner?.stop()\n  }\n\n  if (filesUpdated.length) {\n    spinner(\n      `Updated ${filesUpdated.length} ${\n        filesUpdated.length === 1 ? 'file' : 'files'\n      }:`,\n      {\n        silent: options.silent,\n      },\n    )?.info()\n    if (!options.silent) {\n      for (const file of filesUpdated) {\n        logger.log(`  - ${file}`)\n      }\n    }\n  }\n\n  if (filesSkipped.length) {\n    spinner(\n      `Skipped ${filesSkipped.length} ${\n        filesSkipped.length === 1 ? 'file' : 'files'\n      }: (files might be identical, use --overwrite to overwrite)`,\n      {\n        silent: options.silent,\n      },\n    )?.info()\n    if (!options.silent) {\n      for (const file of filesSkipped) {\n        logger.log(`  - ${file}`)\n      }\n    }\n  }\n\n  if (!options.silent) {\n    logger.break()\n  }\n\n  return {\n    filesCreated,\n    filesUpdated,\n    filesSkipped,\n  }\n}\n\nexport function resolveFilePath(\n  file: z.infer<typeof registryItemFileSchema>,\n  config: Config,\n  options: {\n    commonRoot?: string\n    framework?: ProjectInfo['framework']['name']\n  },\n) {\n  if (file.target) {\n    if (file.target.startsWith('~/')) {\n      return path.join(config.resolvedPaths.cwd, file.target.replace('~/', ''))\n    }\n\n    let target = file.target\n\n    if (file.type === 'registry:page') {\n      target = resolvePageTarget(target, options.framework)\n      if (!target) {\n        return ''\n      }\n    }\n\n    return path.join(config.resolvedPaths.cwd, target.replace('src/', ''))\n  }\n\n  const targetDir = resolveFileTargetDirectory(file, config)\n\n  const relativePath = resolveNestedFilePath(file.path, targetDir)\n  return path.join(targetDir, relativePath)\n}\n\nfunction resolveFileTargetDirectory(\n  file: z.infer<typeof registryItemFileSchema>,\n  config: Config,\n) {\n  if (file.type === 'registry:ui') {\n    return config.resolvedPaths.ui\n  }\n\n  if (file.type === 'registry:lib') {\n    return config.resolvedPaths.lib\n  }\n\n  if (file.type === 'registry:block' || file.type === 'registry:component') {\n    return config.resolvedPaths.components\n  }\n\n  if (file.type === 'registry:hook' || file.type === 'registry:composable') {\n    return config.resolvedPaths.composables\n  }\n\n  return config.resolvedPaths.components\n}\n\nexport function findCommonRoot(paths: string[], needle: string): string {\n  // Remove leading slashes for consistent handling\n  const normalizedPaths = paths.map(p => p.replace(/^\\//, ''))\n  const normalizedNeedle = needle.replace(/^\\//, '')\n\n  // Get the directory path of the needle by removing the file name\n  const needleDir = normalizedNeedle.split('/').slice(0, -1).join('/')\n\n  // If needle is at root level, return empty string\n  if (!needleDir) {\n    return ''\n  }\n\n  // Split the needle directory into segments\n  const needleSegments = needleDir.split('/')\n\n  // Start from the full path and work backwards\n  for (let i = needleSegments.length; i > 0; i--) {\n    const testPath = needleSegments.slice(0, i).join('/')\n    // Check if this is a common root by verifying if any other paths start with it\n    const hasRelatedPaths = normalizedPaths.some(\n      path => path !== normalizedNeedle && path.startsWith(`${testPath}/`),\n    )\n    if (hasRelatedPaths) {\n      return `/${testPath}` // Add leading slash back for the result\n    }\n  }\n\n  // If no common root found with other files, return the parent directory of the needle\n  return `/${needleDir}` // Add leading slash back for the result\n}\n\nexport function resolveNestedFilePath(\n  filePath: string,\n  targetDir: string,\n): string {\n  // Normalize paths by removing leading/trailing slashes\n  const normalizedFilePath = filePath.replace(/^\\/|\\/$/g, '')\n  const normalizedTargetDir = targetDir.replace(/^\\/|\\/$/g, '')\n\n  // Split paths into segments\n  const fileSegments = normalizedFilePath.split('/')\n  const targetSegments = normalizedTargetDir.split('/')\n\n  // Find the last matching segment from targetDir in filePath\n  const lastTargetSegment = targetSegments[targetSegments.length - 1]\n  const commonDirIndex = fileSegments.findIndex(\n    segment => segment === lastTargetSegment,\n  )\n\n  if (commonDirIndex === -1) {\n    // Return just the filename if no common directory is found\n    return fileSegments[fileSegments.length - 1]\n  }\n\n  // Return everything after the common directory\n  return fileSegments.slice(commonDirIndex + 1).join('/')\n}\n\nexport async function getNormalizedFileContent(content: string) {\n  return content.replace(/\\r\\n/g, '\\n').trim()\n}\n\nexport function resolvePageTarget(\n  target: string,\n  framework?: ProjectInfo['framework']['name'],\n) {\n  if (!framework) {\n    return ''\n  }\n\n  if (framework === 'nuxt') {\n    return target\n  }\n\n  if (framework === 'laravel') {\n    let result = target.replace(/^app\\//, 'resources/js/pages/')\n    result = result.replace(/\\/page(\\.[jt]sx?)$/, '$1')\n\n    return result\n  }\n\n  return ''\n}\n\n// Replace the resolveImports function with this vue-metamorph version:\nasync function resolveImports(filePaths: string[], config: Config) {\n  const projectInfo = await getProjectInfo(config.resolvedPaths.cwd)\n  const tsConfig = await getTSConfig(config.resolvedPaths.cwd, projectInfo?.typescript ? 'tsconfig.json' : 'jsconfig.json')\n  const updatedFiles = []\n\n  if (!projectInfo || tsConfig === null) {\n    return []\n  }\n\n  for (const filepath of filePaths) {\n    const resolvedPath = path.resolve(config.resolvedPaths.cwd, filepath)\n\n    // Check if the file exists.\n    if (!existsSync(resolvedPath)) {\n      continue\n    }\n\n    const content = await fs.readFile(resolvedPath, 'utf-8')\n\n    try {\n      // Create a custom transformer for import resolution\n      const importResolverTransformer = (opts: any) => ({\n        name: 'import-resolver',\n        transform(node: any) {\n          // Handle import declarations\n          if (node.type === 'ImportDeclaration' && node.source?.value) {\n            const moduleSpecifier = node.source.value\n\n            // Filter out non-local imports.\n            if (\n              projectInfo?.aliasPrefix\n              && !moduleSpecifier.startsWith(`${projectInfo.aliasPrefix}/`)\n            ) {\n              return\n            }\n\n            // Find the probable import file path.\n            const probableImportFilePath = resolveImportSync(moduleSpecifier, tsConfig)\n\n            if (!probableImportFilePath) {\n              return\n            }\n\n            // Find the actual import file path.\n            const resolvedImportFilePath = resolveModuleByProbablePath(\n              probableImportFilePath,\n              filePaths,\n              config,\n            )\n\n            if (!resolvedImportFilePath) {\n              return\n            }\n\n            // Convert the resolved import file path to an aliased import.\n            const newImport = toAliasedImport(\n              resolvedImportFilePath,\n              config,\n              projectInfo,\n            )\n\n            if (!newImport || newImport === moduleSpecifier) {\n              return\n            }\n\n            // Update the import source\n            node.source.value = newImport\n            node.source.raw = `'${newImport}'`\n          }\n        },\n      })\n\n      // Use vue-metamorph transform\n      const result = metaTransform(content, resolvedPath, [\n        // @ts-expect-error type error\n        importResolverTransformer({}),\n      ])\n\n      // If the code changed, write it back\n      if (result.code !== content) {\n        await fs.writeFile(resolvedPath, result.code, 'utf-8')\n        updatedFiles.push(filepath)\n      }\n    }\n    catch (error) {\n      console.warn(`Failed to transform imports in ${filepath}:`, error)\n    }\n  }\n\n  return updatedFiles\n}\n\n// Helper function to resolve imports synchronously\nfunction resolveImportSync(moduleSpecifier: string, tsConfig: any): string | null {\n  if (!tsConfig?.compilerOptions?.paths) {\n    return null\n  }\n\n  const { baseUrl = '', paths } = tsConfig.compilerOptions\n\n  // Simple alias resolution\n  for (const [alias, pathList] of Object.entries(paths)) {\n    if (typeof alias === 'string' && Array.isArray(pathList)) {\n      const aliasPattern = alias.replace('/*', '')\n      if (moduleSpecifier.startsWith(aliasPattern)) {\n        const relativePath = moduleSpecifier.replace(aliasPattern, '')\n        const basePath = pathList[0]?.replace('/*', '') || ''\n        return path.resolve(baseUrl, basePath, relativePath)\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * Given an absolute \"probable\" import path (no ext),\n * plus an array of absolute file paths you already know about,\n * return 0N matches (best match first), and also check disk for any missing ones.\n */\nexport function resolveModuleByProbablePath(\n  probableImportFilePath: string,\n  files: string[],\n  config: Config,\n  extensions: string[] = ['.vue', '.ts', '.js', '.css'],\n) {\n  const cwd = path.normalize(config.resolvedPaths.cwd)\n\n  // 1) Build a set of POSIX-normalized, project-relative files\n  const relativeFiles = files.map(f => f.split(path.sep).join(path.posix.sep))\n  const fileSet = new Set(relativeFiles)\n\n  // 2) Strip any existing extension off the absolute base path\n  const extInPath = path.extname(probableImportFilePath)\n  const hasExt = extInPath !== ''\n  const absBase = hasExt\n    ? probableImportFilePath.slice(0, -extInPath.length)\n    : probableImportFilePath\n\n  // 3) Compute the project-relative \"base\" directory for strong matching\n  const relBaseRaw = path.relative(cwd, absBase)\n  const relBase = relBaseRaw.split(path.sep).join(path.posix.sep)\n\n  // 4) Decide which extensions to try\n  const tryExts = hasExt ? [extInPath] : extensions\n\n  // 5) Collect candidates\n  const candidates = new Set<string>()\n\n  // 5a) Fastpath: [base + ext] and [base/index + ext]\n  for (const e of tryExts) {\n    const absCand = absBase + e\n    const relCand = path.posix.normalize(path.relative(cwd, absCand))\n    if (fileSet.has(relCand) || existsSync(absCand)) {\n      candidates.add(relCand)\n    }\n\n    const absIdx = path.join(absBase, `index${e}`)\n    const relIdx = path.posix.normalize(path.relative(cwd, absIdx))\n    if (fileSet.has(relIdx) || existsSync(absIdx)) {\n      candidates.add(relIdx)\n    }\n  }\n\n  // 5b) Fallback: scan known files by basename\n  const name = path.basename(absBase)\n  for (const f of relativeFiles) {\n    if (tryExts.some(e => f.endsWith(`/${name}${e}`))) {\n      candidates.add(f)\n    }\n  }\n\n  // 6) If no matches, bail\n  if (candidates.size === 0)\n    return null\n\n  // 7) Sort by (1) extension priority, then (2) \"strong\" base match\n  const sorted = Array.from(candidates).sort((a, b) => {\n    // a) extension order\n    const aExt = path.posix.extname(a)\n    const bExt = path.posix.extname(b)\n    const ord = tryExts.indexOf(aExt) - tryExts.indexOf(bExt)\n    if (ord !== 0)\n      return ord\n    // b) strong match if path starts with relBase\n    const aStrong = relBase && a.startsWith(relBase) ? -1 : 1\n    const bStrong = relBase && b.startsWith(relBase) ? -1 : 1\n    return aStrong - bStrong\n  })\n\n  // 8) Return the first (best) candidate\n  return sorted[0]\n}\n\nexport function toAliasedImport(\n  filePath: string,\n  config: Config,\n  projectInfo: ProjectInfo,\n): string | null {\n  const abs = path.normalize(path.join(config.resolvedPaths.cwd, filePath))\n\n  // 1 Find the longest matching alias root in resolvedPaths\n  //    e.g. key=\"ui\", root=\"//components/ui\" beats key=\"components\"\n  const matches = Object.entries(config.resolvedPaths)\n    .filter(\n      ([, root]) => root && abs.startsWith(path.normalize(root + path.sep)),\n    )\n    .sort((a, b) => b[1].length - a[1].length)\n\n  if (matches.length === 0) {\n    return null\n  }\n  const [aliasKey, rootDir] = matches[0]\n\n  // 2 Compute the path UNDER that root\n  let rel = path.relative(rootDir, abs)\n  // force POSIX-style separators\n  rel = rel.split(path.sep).join('/') // e.g. \"button/index.vue\"\n\n  // 3 Strip code-file extensions, keep others (css, json, etc.)\n  const ext = path.posix.extname(rel)\n  const codeExts = ['.ts', '.vue', '.js']\n  const keepExt = codeExts.includes(ext) ? '' : ext\n  let noExt = rel.slice(0, rel.length - ext.length)\n\n  // 4 Collapse \"/index\" to its directory\n  if (noExt.endsWith('/index')) {\n    noExt = noExt.slice(0, -'/index'.length)\n  }\n\n  // 5 Build the aliased path\n  //    config.aliases[aliasKey] is e.g. \"@/components/ui\"\n  const aliasBase\n    = aliasKey === 'cwd'\n      ? projectInfo.aliasPrefix\n      : config.aliases[aliasKey as keyof typeof config.aliases]\n  if (!aliasBase) {\n    return null\n  }\n  // if noExt is empty (i.e. file was exactly at the root), we import the root\n  let suffix = noExt === '' ? '' : `/${noExt}`\n\n  // Remove /src from suffix.\n  // Alias will handle this.\n  suffix = suffix.replace('/src', '')\n\n  // 6 Prepend the prefix from projectInfo (e.g. \"@\") if needed\n  //    but usually config.aliases already include it.\n  return `${aliasBase}${suffix}${keepExt}`\n}\n","/* eslint-disable prefer-const */\n\nimport type { Config, configSchema, workspaceConfigSchema } from '@/src/utils/get-config'\nimport path from 'pathe'\nimport { z } from 'zod'\nimport { fetchRegistry, getRegistryParentMap, getRegistryTypeAliasMap, registryResolveItemsTree, resolveRegistryItems } from '@/src/registry/api'\nimport { registryItemSchema } from '@/src/registry/schema'\nimport { findCommonRoot, findPackageRoot, getWorkspaceConfig } from '@/src/utils/get-config'\nimport { getProjectTailwindVersionFromConfig } from '@/src/utils/get-project-info'\nimport { handleError } from '@/src/utils/handle-error'\nimport { logger } from '@/src/utils/logger'\nimport { spinner } from '@/src/utils/spinner'\nimport { updateCss } from '@/src/utils/updaters/update-css'\nimport { updateCssVars } from '@/src/utils/updaters/update-css-vars'\nimport { updateDependencies } from '@/src/utils/updaters/update-dependencies'\nimport { updateFiles } from '@/src/utils/updaters/update-files'\nimport { updateTailwindConfig } from '@/src/utils/updaters/update-tailwind-config'\n\nexport async function addComponents(\n  components: string[],\n  config: Config,\n  options: {\n    overwrite?: boolean\n    silent?: boolean\n    isNewProject?: boolean\n    style?: string\n  },\n) {\n  options = {\n    overwrite: false,\n    silent: false,\n    isNewProject: false,\n    style: 'index',\n    ...options,\n  }\n\n  const workspaceConfig = await getWorkspaceConfig(config)\n  if (\n    workspaceConfig\n    && workspaceConfig.ui\n    && workspaceConfig.ui.resolvedPaths.cwd !== config.resolvedPaths.cwd\n  ) {\n    return await addWorkspaceComponents(components, config, workspaceConfig, {\n      ...options,\n      isRemote:\n        components?.length === 1 && !!components[0].match(/\\/chat\\/b\\//),\n    })\n  }\n\n  return await addProjectComponents(components, config, options)\n}\n\nasync function addProjectComponents(\n  components: string[],\n  config: z.infer<typeof configSchema>,\n  options: {\n    overwrite?: boolean\n    silent?: boolean\n    isNewProject?: boolean\n    style?: string\n  },\n) {\n  const registrySpinner = spinner(`Checking registry.`, {\n    silent: options.silent,\n  })?.start()\n  const tree = await registryResolveItemsTree(components, config)\n  if (!tree) {\n    registrySpinner?.fail()\n    return handleError(new Error('Failed to fetch components from registry.'))\n  }\n  registrySpinner?.succeed()\n\n  const tailwindVersion = await getProjectTailwindVersionFromConfig(config)\n\n  await updateTailwindConfig(tree.tailwind?.config, config, {\n    silent: options.silent,\n    tailwindVersion,\n  })\n\n  const overwriteCssVars = await shouldOverwriteCssVars(components, config)\n  await updateCssVars(tree.cssVars, config, {\n    cleanupDefaultNextStyles: options.isNewProject,\n    silent: options.silent,\n    tailwindVersion,\n    tailwindConfig: tree.tailwind?.config,\n    overwriteCssVars,\n    initIndex: options.style ? options.style === 'index' : false,\n  })\n\n  // Add CSS updater\n  await updateCss(tree.css, config, {\n    silent: options.silent,\n  })\n\n  await updateDependencies(tree.dependencies, config, {\n    silent: options.silent,\n  })\n  await updateFiles(tree.files, config, {\n    overwrite: options.overwrite,\n    silent: options.silent,\n  })\n\n  if (tree.docs) {\n    logger.info(tree.docs)\n  }\n}\n\nasync function addWorkspaceComponents(\n  components: string[],\n  config: z.infer<typeof configSchema>,\n  workspaceConfig: z.infer<typeof workspaceConfigSchema>,\n  options: {\n    overwrite?: boolean\n    silent?: boolean\n    isNewProject?: boolean\n    isRemote?: boolean\n    style?: string\n  },\n) {\n  const registrySpinner = spinner(`Checking registry.`, {\n    silent: options.silent,\n  })?.start()\n  let registryItems = await resolveRegistryItems(components, config)\n  let result = await fetchRegistry(registryItems)\n  const payload = z.array(registryItemSchema).parse(result)\n  if (!payload) {\n    registrySpinner?.fail()\n    return handleError(new Error('Failed to fetch components from registry.'))\n  }\n  registrySpinner?.succeed()\n\n  const registryParentMap = getRegistryParentMap(payload)\n  const registryTypeAliasMap = getRegistryTypeAliasMap()\n\n  const filesCreated: string[] = []\n  const filesUpdated: string[] = []\n  const filesSkipped: string[] = []\n\n  const rootSpinner = spinner(`Installing components.`)?.start()\n\n  for (const component of payload) {\n    const alias = registryTypeAliasMap.get(component.type)\n    const registryParent = registryParentMap.get(component.name)\n\n    // We don't support this type of component.\n    if (!alias) {\n      continue\n    }\n\n    // A good start is ui for now.\n    // TODO: Add support for other types.\n    let targetConfig\n      = component.type === 'registry:ui' || registryParent?.type === 'registry:ui'\n        ? workspaceConfig.ui\n        : config\n\n    const tailwindVersion = await getProjectTailwindVersionFromConfig(\n      targetConfig,\n    )\n\n    const workspaceRoot = findCommonRoot(\n      config.resolvedPaths.cwd,\n      targetConfig.resolvedPaths.ui,\n    )\n    const packageRoot\n      = (await findPackageRoot(workspaceRoot, targetConfig.resolvedPaths.cwd))\n        ?? targetConfig.resolvedPaths.cwd\n\n    // 1. Update tailwind config.\n    if (component.tailwind?.config) {\n      await updateTailwindConfig(component.tailwind?.config, targetConfig, {\n        silent: true,\n        tailwindVersion,\n      })\n      filesUpdated.push(\n        path.relative(workspaceRoot, targetConfig.resolvedPaths.tailwindConfig),\n      )\n    }\n\n    // 2. Update css vars.\n    if (component.cssVars) {\n      const overwriteCssVars = await shouldOverwriteCssVars(components, config)\n      await updateCssVars(component.cssVars, targetConfig, {\n        silent: true,\n        tailwindVersion,\n        tailwindConfig: component.tailwind?.config,\n        overwriteCssVars,\n      })\n      filesUpdated.push(\n        path.relative(workspaceRoot, targetConfig.resolvedPaths.tailwindCss),\n      )\n    }\n\n    // 3. Update CSS\n    if (component.css) {\n      await updateCss(component.css, targetConfig, {\n        silent: true,\n      })\n      filesUpdated.push(\n        path.relative(workspaceRoot, targetConfig.resolvedPaths.tailwindCss),\n      )\n    }\n\n    // 4. Update dependencies.\n    await Promise.allSettled([\n      component.dependencies && component.dependencies.length\n        ? updateDependencies(\n            component.dependencies,\n            targetConfig,\n            { silent: true },\n          )\n        : Promise.resolve(),\n      component.devDependencies && component.devDependencies.length\n        ? updateDependencies(\n            component.devDependencies,\n            targetConfig,\n            { silent: true, dev: true },\n          )\n        : Promise.resolve(),\n    ])\n\n    // 5. Update files.\n    const files = await updateFiles(component.files, targetConfig, {\n      overwrite: options.overwrite,\n      silent: true,\n      rootSpinner,\n      isRemote: options.isRemote,\n    })\n\n    filesCreated.push(\n      ...files.filesCreated.map(file =>\n        path.relative(workspaceRoot, path.join(packageRoot, file)),\n      ),\n    )\n    filesUpdated.push(\n      ...files.filesUpdated.map(file =>\n        path.relative(workspaceRoot, path.join(packageRoot, file)),\n      ),\n    )\n    filesSkipped.push(\n      ...files.filesSkipped.map(file =>\n        path.relative(workspaceRoot, path.join(packageRoot, file)),\n      ),\n    )\n  }\n\n  rootSpinner?.succeed()\n\n  // Sort files.\n  filesCreated.sort()\n  filesUpdated.sort()\n  filesSkipped.sort()\n\n  const hasUpdatedFiles = filesCreated.length || filesUpdated.length\n  if (!hasUpdatedFiles && !filesSkipped.length) {\n    spinner(`No files updated.`, {\n      silent: options.silent,\n    })?.info()\n  }\n\n  if (filesCreated.length) {\n    spinner(\n      `Created ${filesCreated.length} ${\n        filesCreated.length === 1 ? 'file' : 'files'\n      }:`,\n      {\n        silent: options.silent,\n      },\n    )?.succeed()\n    for (const file of filesCreated) {\n      logger.log(`  - ${file}`)\n    }\n  }\n\n  if (filesUpdated.length) {\n    spinner(\n      `Updated ${filesUpdated.length} ${\n        filesUpdated.length === 1 ? 'file' : 'files'\n      }:`,\n      {\n        silent: options.silent,\n      },\n    )?.info()\n    for (const file of filesUpdated) {\n      logger.log(`  - ${file}`)\n    }\n  }\n\n  if (filesSkipped.length) {\n    spinner(\n      `Skipped ${filesSkipped.length} ${\n        filesUpdated.length === 1 ? 'file' : 'files'\n      }: (use --overwrite to overwrite)`,\n      {\n        silent: options.silent,\n      },\n    )?.info()\n    for (const file of filesSkipped) {\n      logger.log(`  - ${file}`)\n    }\n  }\n}\n\nasync function shouldOverwriteCssVars(\n  components: z.infer<typeof registryItemSchema>['name'][],\n  config: z.infer<typeof configSchema>,\n) {\n  const registryItems = await resolveRegistryItems(components, config)\n  const result = await fetchRegistry(registryItems)\n  const payload = z.array(registryItemSchema).parse(result)\n\n  return payload.some(\n    component =>\n      component.type === 'registry:theme' || component.type === 'registry:style',\n  )\n}\n","import type { ObjectLiteralExpression } from 'ts-morph'\nimport type { Config } from '@/src/utils/get-config'\nimport { promises as fs } from 'node:fs'\nimport path from 'pathe'\nimport { SyntaxKind } from 'ts-morph'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { spinner } from '@/src/utils/spinner'\nimport {\n  _createSourceFile,\n  _getQuoteChar,\n} from '@/src/utils/updaters/update-tailwind-config'\n\nexport async function updateTailwindContent(\n  content: string[],\n  config: Config,\n  options: {\n    silent?: boolean\n  },\n) {\n  if (!content) {\n    return\n  }\n\n  options = {\n    silent: false,\n    ...options,\n  }\n\n  const tailwindFileRelativePath = path.relative(\n    config.resolvedPaths.cwd,\n    config.resolvedPaths.tailwindConfig,\n  )\n  const tailwindSpinner = spinner(\n    `Updating ${highlighter.info(tailwindFileRelativePath)}`,\n    {\n      silent: options.silent,\n    },\n  ).start()\n  const raw = await fs.readFile(config.resolvedPaths.tailwindConfig, 'utf8')\n  const output = await transformTailwindContent(raw, content, config)\n  await fs.writeFile(config.resolvedPaths.tailwindConfig, output, 'utf8')\n  tailwindSpinner?.succeed()\n}\n\nexport async function transformTailwindContent(\n  input: string,\n  content: string[],\n  config: Config,\n) {\n  const sourceFile = await _createSourceFile(input, config)\n  // Find the object with content property.\n  // This is faster than traversing the default export.\n  // TODO: maybe we do need to traverse the default export?\n  const configObject = sourceFile\n    .getDescendantsOfKind(SyntaxKind.ObjectLiteralExpression)\n    .find(node =>\n      node\n        .getProperties()\n        .some(\n          property =>\n            property.isKind(SyntaxKind.PropertyAssignment)\n            && property.getName() === 'content',\n        ),\n    )\n\n  // We couldn't find the config object, so we return the input as is.\n  if (!configObject) {\n    return input\n  }\n\n  addTailwindConfigContent(configObject, content)\n\n  return sourceFile.getFullText()\n}\n\nasync function addTailwindConfigContent(\n  configObject: ObjectLiteralExpression,\n  content: string[],\n) {\n  const quoteChar = _getQuoteChar(configObject)\n\n  const existingProperty = configObject.getProperty('content')\n\n  if (!existingProperty) {\n    const newProperty = {\n      name: 'content',\n      initializer: `[${quoteChar}${content.join(\n        `${quoteChar}, ${quoteChar}`,\n      )}${quoteChar}]`,\n    }\n    configObject.addPropertyAssignment(newProperty)\n\n    return configObject\n  }\n\n  if (existingProperty.isKind(SyntaxKind.PropertyAssignment)) {\n    const initializer = existingProperty.getInitializer()\n\n    // If property is an array, append.\n    if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      for (const contentItem of content) {\n        const newValue = `${quoteChar}${contentItem}${quoteChar}`\n\n        // Check if the array already contains the value.\n        if (\n          initializer\n            .getElements()\n            .map(element => element.getText())\n            .includes(newValue)\n        ) {\n          continue\n        }\n\n        initializer.addElement(newValue)\n      }\n    }\n\n    return configObject\n  }\n\n  return configObject\n}\n","import type { Config } from '@/src/utils/get-config'\nimport { promises as fs } from 'node:fs'\nimport { Command } from 'commander'\nimport path from 'pathe'\nimport prompts from 'prompts'\nimport { z } from 'zod'\nimport { preFlightInit } from '@/src/preflights/preflight-init'\nimport { BASE_COLORS, getRegistryBaseColors, getRegistryItem, getRegistryStyles, isUrl } from '@/src/registry/api'\nimport { addComponents } from '@/src/utils/add-components'\nimport * as ERRORS from '@/src/utils/errors'\nimport {\n  DEFAULT_COMPONENTS,\n  DEFAULT_TAILWIND_CONFIG,\n  DEFAULT_TAILWIND_CSS,\n  DEFAULT_UTILS,\n  getConfig,\n  rawConfigSchema,\n  resolveConfigPaths,\n} from '@/src/utils/get-config'\nimport { getProjectConfig, getProjectInfo, getProjectTailwindVersionFromConfig } from '@/src/utils/get-project-info'\nimport { handleError } from '@/src/utils/handle-error'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\nimport { spinner } from '@/src/utils/spinner'\nimport { updateTailwindContent } from '@/src/utils/updaters/update-tailwind-content'\n\nexport const initOptionsSchema = z.object({\n  cwd: z.string(),\n  components: z.array(z.string()).optional(),\n  yes: z.boolean(),\n  defaults: z.boolean(),\n  force: z.boolean(),\n  silent: z.boolean(),\n  isNewProject: z.boolean(),\n  srcDir: z.boolean().optional(),\n  cssVariables: z.boolean(),\n  // template: z.string().optional(),\n  // .refine(\n  //     (val) => {\n  //       if (val) {\n  //         return TEMPLATES[val as keyof typeof TEMPLATES]\n  //       }\n  //       return true\n  //     },\n  //     {\n  //       message: \"Invalid template. Please use 'next' or 'next-monorepo'.\",\n  //     }\n  //   ),\n  baseColor: z\n    .string()\n    .optional()\n    .refine(\n      (val) => {\n        if (val) {\n          return BASE_COLORS.find(color => color.name === val)\n        }\n\n        return true\n      },\n      {\n        message: `Invalid base color. Please use '${BASE_COLORS.map(\n          color => color.name,\n        ).join('\\', \\'')}'`,\n      },\n    ),\n  style: z.string(),\n})\n\nexport const init = new Command()\n  .name('init')\n  .description('initialize your project and install dependencies')\n  .argument(\n    '[components...]',\n    'the components to add or a url to the component.',\n  )\n  .option('-y, --yes', 'skip confirmation prompt.', true)\n  .option('-d, --defaults,', 'use default configuration.', false)\n  .option('-f, --force', 'force overwrite of existing configuration.', false)\n  .option(\n    '-c, --cwd <cwd>',\n    'the working directory. defaults to the current directory.',\n    process.cwd(),\n  )\n  .option('-s, --silent', 'mute output.', false)\n  // .option(\n  //   '--src-dir',\n  //   'use the src directory when creating a new project.',\n  //   false,\n  // )\n  .option('--css-variables', 'use css variables for theming.', true)\n  .option('--no-css-variables', 'do not use css variables for theming.')\n  .action(async (components, opts) => {\n    try {\n      const options = initOptionsSchema.parse({\n        cwd: path.resolve(opts.cwd),\n        isNewProject: false,\n        components,\n        style: 'index',\n        ...opts,\n      })\n\n      // We need to check if we're initializing with a new style.\n      // We fetch the payload of the first item.\n      // This is okay since the request is cached and deduped.\n      if (components.length > 0 && isUrl(components[0])) {\n        const item = await getRegistryItem(components[0], '')\n\n        // Skip base color if style.\n        // We set a default and let the style override it.\n        if (item?.type === 'registry:style') {\n          options.baseColor = 'neutral'\n          options.style = item.extends ?? 'index'\n        }\n      }\n\n      await runInit(options)\n\n      logger.log(\n        `${highlighter.success(\n          'Success!',\n        )} Project initialization completed.\\nYou may now add components.`,\n      )\n      logger.break()\n    }\n    catch (error) {\n      logger.break()\n      handleError(error)\n    }\n  })\n\nexport async function runInit(\n  options: z.infer<typeof initOptionsSchema> & {\n    skipPreflight?: boolean\n  },\n) {\n  let projectInfo\n  if (!options.skipPreflight) {\n    const preflight = await preFlightInit(options)\n    if (preflight.errors[ERRORS.MISSING_DIR_OR_EMPTY_PROJECT]) {\n      process.exit(1)\n    }\n    // if (preflight.errors[ERRORS.MISSING_DIR_OR_EMPTY_PROJECT]) {\n    //   const { projectPath } = await createProject(options)\n    //   if (!projectPath) {\n    //     process.exit(1)\n    //   }\n    //   options.cwd = projectPath\n    //   options.isNewProject = true\n    // }\n    projectInfo = preflight.projectInfo\n  }\n  else {\n    projectInfo = await getProjectInfo(options.cwd)\n  }\n\n  const projectConfig = await getProjectConfig(options.cwd, projectInfo)\n  const config = projectConfig\n    ? await promptForMinimalConfig(projectConfig, options)\n    : await promptForConfig(await getConfig(options.cwd))\n\n  if (!options.yes) {\n    const { proceed } = await prompts({\n      type: 'confirm',\n      name: 'proceed',\n      message: `Write configuration to ${highlighter.info(\n        'components.json',\n      )}. Proceed?`,\n      initial: true,\n    })\n\n    if (!proceed) {\n      process.exit(0)\n    }\n  }\n\n  // Write components.json.\n  const componentSpinner = spinner(`Writing components.json.`).start()\n  const targetPath = path.resolve(options.cwd, 'components.json')\n  await fs.writeFile(targetPath, JSON.stringify(config, null, 2), 'utf8')\n  componentSpinner.succeed()\n\n  // Add components.\n  const fullConfig = await resolveConfigPaths(options.cwd, config)\n  const components = [\n    ...(options.style === 'none' ? [] : [options.style]),\n    ...(options.components ?? []),\n  ]\n  await addComponents(components, fullConfig, {\n    // Init will always overwrite files.\n    overwrite: true,\n    silent: options.silent,\n    style: options.style,\n    isNewProject:\n      options.isNewProject || projectInfo?.framework.name === 'nuxt',\n  })\n\n  // If a new project is using src dir, let's update the tailwind content config.\n  // TODO: Handle this per framework.\n  if (options.isNewProject && options.srcDir) {\n    await updateTailwindContent(\n      ['./src/**/*.{js,ts,jsx,tsx,mdx}'],\n      fullConfig,\n      {\n        silent: options.silent,\n      },\n    )\n  }\n\n  return fullConfig\n}\n\nasync function promptForConfig(defaultConfig: Config | null = null) {\n  const [styles, baseColors] = await Promise.all([\n    getRegistryStyles(),\n    getRegistryBaseColors(),\n  ])\n\n  logger.info('')\n  const options = await prompts([\n    {\n      type: 'toggle',\n      name: 'typescript',\n      message: `Would you like to use ${highlighter.info(\n        'TypeScript',\n      )} (recommended)?`,\n      initial: defaultConfig?.typescript ?? true,\n      active: 'yes',\n      inactive: 'no',\n    },\n    {\n      type: 'select',\n      name: 'style',\n      message: `Which ${highlighter.info('style')} would you like to use?`,\n      choices: styles.map(style => ({\n        title: style.name === 'new-york' ? 'New York (Recommended)' : style.label,\n        value: style.name,\n      })),\n    },\n    {\n      type: 'select',\n      name: 'tailwindBaseColor',\n      message: `Which color would you like to use as the ${highlighter.info(\n        'base color',\n      )}?`,\n      choices: baseColors.map(color => ({\n        title: color.label,\n        value: color.name,\n      })),\n    },\n    {\n      type: 'text',\n      name: 'tailwindCss',\n      message: `Where is your ${highlighter.info('global CSS')} file?`,\n      initial: defaultConfig?.tailwind.css ?? DEFAULT_TAILWIND_CSS,\n    },\n    {\n      type: 'toggle',\n      name: 'tailwindCssVariables',\n      message: `Would you like to use ${highlighter.info(\n        'CSS variables',\n      )} for theming?`,\n      initial: defaultConfig?.tailwind.cssVariables ?? true,\n      active: 'yes',\n      inactive: 'no',\n    },\n    {\n      type: 'text',\n      name: 'tailwindPrefix',\n      message: `Are you using a custom ${highlighter.info(\n        'tailwind prefix eg. tw-',\n      )}? (Leave blank if not)`,\n      initial: '',\n    },\n    {\n      type: 'text',\n      name: 'tailwindConfig',\n      message: `Where is your ${highlighter.info(\n        'tailwind.config.js',\n      )} located?`,\n      initial: defaultConfig?.tailwind.config ?? DEFAULT_TAILWIND_CONFIG,\n    },\n    {\n      type: 'text',\n      name: 'components',\n      message: `Configure the import alias for ${highlighter.info(\n        'components',\n      )}:`,\n      initial: defaultConfig?.aliases.components ?? DEFAULT_COMPONENTS,\n    },\n    {\n      type: 'text',\n      name: 'utils',\n      message: `Configure the import alias for ${highlighter.info('utils')}:`,\n      initial: defaultConfig?.aliases.utils ?? DEFAULT_UTILS,\n    },\n  ])\n\n  return rawConfigSchema.parse({\n    $schema: 'https://shadcn-vue.com/schema.json',\n    style: options.style,\n    tailwind: {\n      config: options.tailwindConfig,\n      css: options.tailwindCss,\n      baseColor: options.tailwindBaseColor,\n      cssVariables: options.tailwindCssVariables,\n      prefix: options.tailwindPrefix,\n    },\n    typescript: options.typescript,\n    aliases: {\n      utils: options.utils,\n      components: options.components,\n      // TODO: fix this.\n      lib: options.components.replace(/\\/components$/, '/lib'),\n      composables: options.components.replace(/\\/components$/, '/composables'),\n    },\n  })\n}\n\nasync function promptForMinimalConfig(\n  defaultConfig: Config,\n  opts: z.infer<typeof initOptionsSchema>,\n) {\n  let style = defaultConfig.style\n  let baseColor = defaultConfig.tailwind.baseColor\n  let cssVariables = defaultConfig.tailwind.cssVariables\n\n  if (!opts.defaults) {\n    const [styles, baseColors, tailwindVersion] = await Promise.all([\n      getRegistryStyles(),\n      getRegistryBaseColors(),\n      getProjectTailwindVersionFromConfig(defaultConfig),\n    ])\n\n    const options = await prompts([\n      {\n        type: tailwindVersion === 'v4' ? null : 'select',\n        name: 'style',\n        message: `Which ${highlighter.info('style')} would you like to use?`,\n        choices: styles.map(style => ({\n          title: style.name === 'new-york' ? 'New York (Recommended)' : style.label,\n          value: style.name,\n        })),\n        initial: 0,\n      },\n      {\n        type: opts.baseColor ? null : 'select',\n        name: 'tailwindBaseColor',\n        message: `Which color would you like to use as the ${highlighter.info(\n          'base color',\n        )}?`,\n        choices: baseColors.map(color => ({\n          title: color.label,\n          value: color.name,\n        })),\n      },\n    ])\n\n    style = options.style ?? 'new-york'\n    baseColor = options.tailwindBaseColor ?? baseColor\n    cssVariables = opts.cssVariables\n  }\n\n  return rawConfigSchema.parse({\n    $schema: defaultConfig?.$schema,\n    style,\n    tailwind: {\n      ...defaultConfig?.tailwind,\n      baseColor,\n      cssVariables,\n    },\n    typescript: defaultConfig.typescript,\n    aliases: defaultConfig?.aliases,\n    iconLibrary: defaultConfig?.iconLibrary,\n  })\n}\n","import type { z } from 'zod'\nimport type { addOptionsSchema } from '@/src/commands/add'\nimport fs from 'fs-extra'\nimport path from 'pathe'\nimport * as ERRORS from '@/src/utils/errors'\nimport { getConfig } from '@/src/utils/get-config'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\n\nexport async function preFlightAdd(options: z.infer<typeof addOptionsSchema>) {\n  const errors: Record<string, boolean> = {}\n\n  // Ensure target directory exists.\n  // Check for empty project. We assume if no package.json exists, the project is empty.\n  if (\n    !fs.existsSync(options.cwd)\n    || !fs.existsSync(path.resolve(options.cwd, 'package.json'))\n  ) {\n    errors[ERRORS.MISSING_DIR_OR_EMPTY_PROJECT] = true\n    return {\n      errors,\n      config: null,\n    }\n  }\n\n  // Check for existing components.json file.\n  if (!fs.existsSync(path.resolve(options.cwd, 'components.json'))) {\n    errors[ERRORS.MISSING_CONFIG] = true\n    return {\n      errors,\n      config: null,\n    }\n  }\n\n  try {\n    const config = await getConfig(options.cwd)\n\n    return {\n      errors,\n      config: config!,\n    }\n  }\n  catch (error) {\n    logger.break()\n    logger.error(\n      `An invalid ${highlighter.info(\n        'components.json',\n      )} file was found at ${highlighter.info(\n        options.cwd,\n      )}.\\nBefore you can add components, you must create a valid ${highlighter.info(\n        'components.json',\n      )} file by running the ${highlighter.info('init')} command.`,\n    )\n    logger.error(\n      `Learn more at ${highlighter.info(\n        'https://shadcn-vue.com/docs/components-json',\n      )}.`,\n    )\n    logger.break()\n    process.exit(1)\n  }\n}\n","import type { registryItemTypeSchema } from '../registry'\nimport { Command } from 'commander'\nimport path from 'pathe'\nimport prompts from 'prompts'\nimport { z } from 'zod'\nimport { runInit } from '@/src/commands/init'\nimport { preFlightAdd } from '@/src/preflights/preflight-add'\nimport { getRegistryIndex, getRegistryItem, isUrl } from '@/src/registry/api'\nimport { addComponents } from '@/src/utils/add-components'\nimport * as ERRORS from '@/src/utils/errors'\nimport { getProjectInfo } from '@/src/utils/get-project-info'\nimport { handleError } from '@/src/utils/handle-error'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\n\nconst DEPRECATED_COMPONENTS = [\n  {\n    name: 'toast',\n    deprecatedBy: 'sonner',\n    message:\n      'The toast component is deprecated. Use the sonner component instead.',\n  },\n  {\n    name: 'toaster',\n    deprecatedBy: 'sonner',\n    message:\n      'The toaster component is deprecated. Use the sonner component instead.',\n  },\n]\n\nexport const addOptionsSchema = z.object({\n  components: z.array(z.string()).optional(),\n  yes: z.boolean(),\n  overwrite: z.boolean(),\n  cwd: z.string(),\n  all: z.boolean(),\n  path: z.string().optional(),\n  silent: z.boolean(),\n  srcDir: z.boolean().optional(),\n  cssVariables: z.boolean(),\n})\n\nexport const add = new Command()\n  .name('add')\n  .description('add a component to your project')\n  .argument(\n    '[components...]',\n    'the components to add or a url to the component.',\n  )\n  .option('-y, --yes', 'skip confirmation prompt.', false)\n  .option('-o, --overwrite', 'overwrite existing files.', false)\n  .option(\n    '-c, --cwd <cwd>',\n    'the working directory. defaults to the current directory.',\n    process.cwd(),\n  )\n  .option('-a, --all', 'add all available components', false)\n  .option('-p, --path <path>', 'the path to add the component to.')\n  .option('-s, --silent', 'mute output.', false)\n  // .option(\n  //   '--src-dir',\n  //   'use the src directory when creating a new project.',\n  //   false,\n  // )\n  // .option(\n  //   '--no-src-dir',\n  //   'do not use the src directory when creating a new project.',\n  // )\n  .option('--css-variables', 'use css variables for theming.', true)\n  .option('--no-css-variables', 'do not use css variables for theming.')\n  .action(async (components, opts) => {\n    try {\n      const options = addOptionsSchema.parse({\n        components,\n        cwd: path.resolve(opts.cwd),\n        ...opts,\n      })\n\n      let itemType: z.infer<typeof registryItemTypeSchema> | undefined\n\n      if (components.length > 0 && isUrl(components[0])) {\n        const item = await getRegistryItem(components[0], '')\n        itemType = item?.type\n      }\n\n      if (\n        !options.yes\n        && (itemType === 'registry:style' || itemType === 'registry:theme')\n      ) {\n        logger.break()\n        const { confirm } = await prompts({\n          type: 'confirm',\n          name: 'confirm',\n          message: highlighter.warn(\n            `You are about to install a new ${itemType.replace(\n              'registry:',\n              '',\n            )}. \\nExisting CSS variables and components will be overwritten. Continue?`,\n          ),\n        })\n        if (!confirm) {\n          logger.break()\n          logger.log(`Installation cancelled.`)\n          logger.break()\n          process.exit(1)\n        }\n      }\n\n      if (!options.components?.length) {\n        options.components = await promptForRegistryComponents(options)\n      }\n\n      const projectInfo = await getProjectInfo(options.cwd)\n      if (projectInfo?.tailwindVersion === 'v4') {\n        const deprecatedComponents = DEPRECATED_COMPONENTS.filter(component =>\n          options.components?.includes(component.name),\n        )\n\n        if (deprecatedComponents?.length) {\n          logger.break()\n          deprecatedComponents.forEach((component) => {\n            logger.warn(highlighter.warn(component.message))\n          })\n          logger.break()\n          process.exit(1)\n        }\n      }\n\n      let { errors, config } = await preFlightAdd(options)\n\n      // No components.json file. Prompt the user to run init.\n      if (errors[ERRORS.MISSING_CONFIG]) {\n        const { proceed } = await prompts({\n          type: 'confirm',\n          name: 'proceed',\n          message: `You need to create a ${highlighter.info(\n            'components.json',\n          )} file to add components. Proceed?`,\n          initial: true,\n        })\n\n        if (!proceed) {\n          logger.break()\n          process.exit(1)\n        }\n\n        config = await runInit({\n          cwd: options.cwd,\n          yes: true,\n          force: true,\n          defaults: false,\n          skipPreflight: false,\n          silent: true,\n          isNewProject: false,\n          srcDir: options.srcDir,\n          cssVariables: options.cssVariables,\n          style: 'index',\n        })\n      }\n\n      // createProject\n\n      if (!config) {\n        throw new Error(\n          `Failed to read config at ${highlighter.info(options.cwd)}.`,\n        )\n      }\n\n      await addComponents(options.components, config, options)\n    }\n    catch (error) {\n      logger.break()\n      handleError(error)\n    }\n  })\n\nasync function promptForRegistryComponents(\n  options: z.infer<typeof addOptionsSchema>,\n) {\n  const registryIndex = await getRegistryIndex()\n\n  if (!registryIndex) {\n    logger.break()\n    handleError(new Error('Failed to fetch registry index.'))\n    return []\n  }\n\n  if (options.all) {\n    return registryIndex\n      .map(entry => entry.name)\n      .filter(\n        component => !DEPRECATED_COMPONENTS.some(c => c.name === component),\n      )\n  }\n\n  if (options.components?.length) {\n    return options.components\n  }\n\n  const { components } = await prompts({\n    type: 'multiselect',\n    name: 'components',\n    message: 'Which components would you like to add?',\n    hint: 'Space to select. A to toggle all. Enter to submit.',\n    instructions: false,\n    choices: registryIndex\n      .filter(\n        entry =>\n          entry.type === 'registry:ui'\n          && !DEPRECATED_COMPONENTS.some(\n            component => component.name === entry.name,\n          ),\n      )\n      .map(entry => ({\n        title: entry.name,\n        value: entry.name,\n        selected: options.all ? true : options.components?.includes(entry.name),\n      })),\n  })\n\n  if (!components?.length) {\n    logger.warn('No components selected. Exiting.')\n    logger.info('')\n    process.exit(1)\n  }\n\n  const result = z.array(z.string()).safeParse(components)\n  if (!result.success) {\n    logger.error('')\n    handleError(new Error('Something went wrong. Please try again.'))\n    return []\n  }\n  return result.data\n}\n","import type { z } from 'zod'\nimport type { buildOptionsSchema } from '@/src/commands/build'\nimport fs from 'fs-extra'\nimport path from 'pathe'\nimport * as ERRORS from '@/src/utils/errors'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\n\nexport async function preFlightBuild(\n  options: z.infer<typeof buildOptionsSchema>,\n) {\n  const errors: Record<string, boolean> = {}\n\n  const resolvePaths = {\n    cwd: options.cwd,\n    registryFile: path.resolve(options.cwd, options.registryFile),\n    outputDir: path.resolve(options.cwd, options.outputDir),\n  }\n\n  // Ensure registry file exists.\n  if (!fs.existsSync(resolvePaths.registryFile)) {\n    errors[ERRORS.BUILD_MISSING_REGISTRY_FILE] = true\n  }\n\n  // Create output directory if it doesn't exist.\n  await fs.mkdir(resolvePaths.outputDir, { recursive: true })\n\n  if (Object.keys(errors).length > 0) {\n    if (errors[ERRORS.BUILD_MISSING_REGISTRY_FILE]) {\n      logger.break()\n      logger.error(\n        `The path ${highlighter.info(\n          resolvePaths.registryFile,\n        )} does not exist.`,\n      )\n    }\n\n    logger.break()\n    process.exit(1)\n  }\n\n  return {\n    errors,\n    resolvePaths,\n  }\n}\n","import * as fs from 'node:fs/promises'\nimport { Command } from 'commander'\nimport * as path from 'pathe'\nimport { z } from 'zod'\nimport { preFlightBuild } from '@/src/preflights/preflight-build'\nimport { registryItemSchema, registrySchema } from '@/src/registry'\nimport { handleError } from '@/src/utils/handle-error'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\nimport { spinner } from '@/src/utils/spinner'\n\nexport const buildOptionsSchema = z.object({\n  cwd: z.string(),\n  registryFile: z.string(),\n  outputDir: z.string(),\n})\n\nexport const build = new Command()\n  .name('build')\n  .description('build components for a shadcn registry')\n  .argument('[registry]', 'path to registry.json file', './registry.json')\n  .option(\n    '-o, --output <path>',\n    'destination directory for json files',\n    './public/r',\n  )\n  .option(\n    '-c, --cwd <cwd>',\n    'the working directory. defaults to the current directory.',\n    process.cwd(),\n  )\n  .action(async (registry: string, opts) => {\n    try {\n      const options = buildOptionsSchema.parse({\n        cwd: path.resolve(opts.cwd),\n        registryFile: registry,\n        outputDir: opts.output,\n      })\n\n      const { resolvePaths } = await preFlightBuild(options)\n      const content = await fs.readFile(resolvePaths.registryFile, 'utf-8')\n\n      const result = registrySchema.safeParse(JSON.parse(content))\n\n      if (!result.success) {\n        logger.error(\n          `Invalid registry file found at ${highlighter.info(\n            resolvePaths.registryFile,\n          )}.`,\n        )\n        process.exit(1)\n      }\n\n      const buildSpinner = spinner('Building registry...')\n      for (const registryItem of result.data.items) {\n        if (!registryItem.files) {\n          continue\n        }\n\n        buildSpinner.start(`Building ${registryItem.name}...`)\n\n        // Add the schema to the registry item.\n        registryItem.$schema\n          = 'https://shadcn-vue.com/schema/registry-item.json'\n\n        // Loop through each file in the files array.\n        for (const file of registryItem.files) {\n          file.content = await fs.readFile(\n            path.resolve(resolvePaths.cwd, file.path),\n            'utf-8',\n          )\n        }\n\n        // Validate the registry item.\n        const result = registryItemSchema.safeParse(registryItem)\n        if (!result.success) {\n          logger.error(\n            `Invalid registry item found for ${highlighter.info(\n              registryItem.name,\n            )}.`,\n          )\n          continue\n        }\n\n        // Write the registry item to the output directory.\n        await fs.writeFile(\n          path.resolve(resolvePaths.outputDir, `${result.data.name}.json`),\n          JSON.stringify(result.data, null, 2),\n        )\n      }\n\n      buildSpinner.succeed('Building registry.')\n    }\n    catch (error) {\n      logger.break()\n      handleError(error)\n    }\n  })\n","import type { registryIndexSchema } from '@/src/registry/schema'\nimport type { Config } from '@/src/utils/get-config'\nimport { existsSync, promises as fs } from 'node:fs'\nimport { Command } from 'commander'\nimport { type Change, diffLines } from 'diff'\nimport path from 'pathe'\nimport { z } from 'zod'\nimport {\n  fetchTree,\n  getItemTargetPath,\n  getRegistryBaseColor,\n  getRegistryIndex,\n} from '@/src/registry/api'\nimport { getConfig } from '@/src/utils/get-config'\nimport { handleError } from '@/src/utils/handle-error'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\nimport { transform } from '@/src/utils/transformers'\n\nconst updateOptionsSchema = z.object({\n  component: z.string().optional(),\n  yes: z.boolean(),\n  cwd: z.string(),\n  path: z.string().optional(),\n})\n\nexport const diff = new Command()\n  .name('diff')\n  .description('check for updates against the registry')\n  .argument('[component]', 'the component name')\n  .option('-y, --yes', 'skip confirmation prompt.', false)\n  .option(\n    '-c, --cwd <cwd>',\n    'the working directory. defaults to the current directory.',\n    process.cwd(),\n  )\n  .action(async (name, opts) => {\n    try {\n      const options = updateOptionsSchema.parse({\n        component: name,\n        ...opts,\n      })\n\n      const cwd = path.resolve(options.cwd)\n\n      if (!existsSync(cwd)) {\n        logger.error(`The path ${cwd} does not exist. Please try again.`)\n        process.exit(1)\n      }\n\n      const config = await getConfig(cwd)\n      if (!config) {\n        logger.warn(\n          `Configuration is missing. Please run ${highlighter.success(\n            `init`,\n          )} to create a components.json file.`,\n        )\n        process.exit(1)\n      }\n\n      const registryIndex = await getRegistryIndex()\n\n      if (!registryIndex) {\n        handleError(new Error('Failed to fetch registry index.'))\n        process.exit(1)\n      }\n\n      if (!options.component) {\n        const targetDir = config.resolvedPaths.components\n\n        // Find all components that exist in the project.\n        const projectComponents = registryIndex.filter((item) => {\n          for (const file of item.files ?? []) {\n            const filePath = path.resolve(\n              targetDir,\n              typeof file === 'string' ? file : file.path,\n            )\n            if (existsSync(filePath)) {\n              return true\n            }\n          }\n\n          return false\n        })\n\n        // Check for updates.\n        const componentsWithUpdates = []\n        for (const component of projectComponents) {\n          const changes = await diffComponent(component, config)\n          if (changes.length) {\n            componentsWithUpdates.push({\n              name: component.name,\n              changes,\n            })\n          }\n        }\n\n        if (!componentsWithUpdates.length) {\n          logger.info('No updates found.')\n          process.exit(0)\n        }\n\n        logger.info('The following components have updates available:')\n        for (const component of componentsWithUpdates) {\n          logger.info(`- ${component.name}`)\n          for (const change of component.changes) {\n            logger.info(`  - ${change.filePath}`)\n          }\n        }\n        logger.break()\n        logger.info(\n          `Run ${highlighter.success(`diff <component>`)} to see the changes.`,\n        )\n        process.exit(0)\n      }\n\n      // Show diff for a single component.\n      const component = registryIndex.find(\n        item => item.name === options.component,\n      )\n\n      if (!component) {\n        logger.error(\n          `The component ${highlighter.success(\n            options.component,\n          )} does not exist.`,\n        )\n        process.exit(1)\n      }\n\n      const changes = await diffComponent(component, config)\n\n      if (!changes.length) {\n        logger.info(`No updates found for ${options.component}.`)\n        process.exit(0)\n      }\n\n      for (const change of changes) {\n        logger.info(`- ${change.filePath}`)\n        await printDiff(change.patch)\n        logger.info('')\n      }\n    }\n    catch (error) {\n      handleError(error)\n    }\n  })\n\nasync function diffComponent(\n  component: z.infer<typeof registryIndexSchema>[number],\n  config: Config,\n) {\n  const payload = await fetchTree(config.style, [component])\n  const baseColor = await getRegistryBaseColor(config.tailwind.baseColor)\n\n  if (!payload) {\n    return []\n  }\n\n  const changes = []\n\n  for (const item of payload) {\n    const targetDir = await getItemTargetPath(config, item)\n\n    if (!targetDir) {\n      continue\n    }\n\n    for (const file of item.files ?? []) {\n      const filePath = path.resolve(\n        targetDir,\n        typeof file === 'string' ? file : file.path,\n      )\n\n      if (!existsSync(filePath)) {\n        continue\n      }\n\n      const fileContent = await fs.readFile(filePath, 'utf8')\n\n      if (typeof file === 'string' || !file.content) {\n        continue\n      }\n\n      const registryContent = await transform({\n        filename: file.path,\n        raw: file.content,\n        config,\n        baseColor,\n      })\n\n      const patch = diffLines(registryContent as string, fileContent)\n      if (patch.length > 1) {\n        changes.push({\n          filePath,\n          patch,\n        })\n      }\n    }\n  }\n\n  return changes\n}\n\nasync function printDiff(diff: Change[]) {\n  diff.forEach((part) => {\n    if (part) {\n      if (part.added) {\n        return process.stdout.write(highlighter.success(part.value))\n      }\n      if (part.removed) {\n        return process.stdout.write(highlighter.error(part.value))\n      }\n\n      return process.stdout.write(part.value)\n    }\n  })\n}\n","import { Command } from 'commander'\nimport consola from 'consola'\nimport { getConfig } from '@/src/utils/get-config'\nimport { getProjectInfo } from '@/src/utils/get-project-info'\nimport { logger } from '@/src/utils/logger'\n\nexport const info = new Command()\n  .name('info')\n  .description('get information about your project')\n  .option(\n    '-c, --cwd <cwd>',\n    'the working directory. defaults to the current directory.',\n    process.cwd(),\n  )\n  .action(async (opts) => {\n    logger.info('> project info')\n    consola.log(await getProjectInfo(opts.cwd))\n    logger.break()\n    logger.info('> components.json')\n    consola.log(await getConfig(opts.cwd))\n  })\n","import type { z } from 'zod'\nimport type { iconsSchema } from '@/src/registry/schema'\nimport type { Config } from '@/src/utils/get-config'\nimport { randomBytes } from 'node:crypto'\nimport { promises as fs } from 'node:fs'\nimport { tmpdir } from 'node:os'\nimport path from 'pathe'\nimport prompts from 'prompts'\nimport { glob } from 'tinyglobby'\nimport { Project, ScriptKind, SyntaxKind } from 'ts-morph'\nimport { getRegistryIcons } from '@/src/registry/api'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { ICON_LIBRARIES } from '@/src/utils/icon-libraries'\nimport { logger } from '@/src/utils/logger'\nimport { spinner } from '@/src/utils/spinner'\nimport { updateDependencies } from '@/src/utils/updaters/update-dependencies'\n\nexport async function migrateIcons(config: Config) {\n  if (!config.resolvedPaths.ui) {\n    throw new Error(\n      'We could not find a valid `ui` path in your `components.json` file. Please ensure you have a valid `ui` path in your `components.json` file.',\n    )\n  }\n\n  const uiPath = config.resolvedPaths.ui\n  const [files, registryIcons] = await Promise.all([\n    glob('**/*.{js,ts,jsx,tsx}', {\n      cwd: uiPath,\n    }),\n    getRegistryIcons(),\n  ])\n\n  if (Object.keys(registryIcons).length === 0) {\n    throw new Error('Something went wrong fetching the registry icons.')\n  }\n\n  const libraryChoices = Object.entries(ICON_LIBRARIES).map(\n    ([name, iconLibrary]) => ({\n      title: iconLibrary.name,\n      value: name,\n    }),\n  )\n\n  const migrateOptions = await prompts([\n    {\n      type: 'select',\n      name: 'sourceLibrary',\n      message: `Which icon library would you like to ${highlighter.info(\n        'migrate from',\n      )}?`,\n      choices: libraryChoices,\n    },\n    {\n      type: 'select',\n      name: 'targetLibrary',\n      message: `Which icon library would you like to ${highlighter.info(\n        'migrate to',\n      )}?`,\n      choices: libraryChoices,\n    },\n  ])\n\n  if (migrateOptions.sourceLibrary === migrateOptions.targetLibrary) {\n    throw new Error(\n      'You cannot migrate to the same icon library. Please choose a different icon library.',\n    )\n  }\n\n  if (\n    !(\n      migrateOptions.sourceLibrary in ICON_LIBRARIES\n      && migrateOptions.targetLibrary in ICON_LIBRARIES\n    )\n  ) {\n    throw new Error('Invalid icon library. Please choose a valid icon library.')\n  }\n\n  const sourceLibrary\n    = ICON_LIBRARIES[migrateOptions.sourceLibrary as keyof typeof ICON_LIBRARIES]\n  const targetLibrary\n    = ICON_LIBRARIES[migrateOptions.targetLibrary as keyof typeof ICON_LIBRARIES]\n  const { confirm } = await prompts({\n    type: 'confirm',\n    name: 'confirm',\n    initial: true,\n    message: `We will migrate ${highlighter.info(\n      files.length,\n    )} files in ${highlighter.info(\n      `./${path.relative(config.resolvedPaths.cwd, uiPath)}`,\n    )} from ${highlighter.info(sourceLibrary.name)} to ${highlighter.info(\n      targetLibrary.name,\n    )}. Continue?`,\n  })\n\n  if (!confirm) {\n    logger.info('Migration cancelled.')\n    process.exit(0)\n  }\n\n  if (targetLibrary.package) {\n    await updateDependencies([targetLibrary.package], config, {\n      silent: false,\n    })\n  }\n\n  const migrationSpinner = spinner(`Migrating icons...`)?.start()\n\n  await Promise.all(\n    files.map(async (file) => {\n      migrationSpinner.text = `Migrating ${file}...`\n\n      const filePath = path.join(uiPath, file)\n      const fileContent = await fs.readFile(filePath, 'utf-8')\n\n      const content = await migrateIconsFile(\n        fileContent,\n        migrateOptions.sourceLibrary,\n        migrateOptions.targetLibrary,\n        registryIcons,\n      )\n\n      await fs.writeFile(filePath, content)\n    }),\n  )\n\n  migrationSpinner.succeed('Migration complete.')\n}\n\nexport async function migrateIconsFile(\n  content: string,\n  sourceLibrary: keyof typeof ICON_LIBRARIES,\n  targetLibrary: keyof typeof ICON_LIBRARIES,\n  iconsMapping: z.infer<typeof iconsSchema>,\n) {\n  const sourceLibraryImport = ICON_LIBRARIES[sourceLibrary]?.import\n  const targetLibraryImport = ICON_LIBRARIES[targetLibrary]?.import\n\n  const dir = await fs.mkdtemp(path.join(tmpdir(), 'shadcn-'))\n  const project = new Project({\n    compilerOptions: {},\n  })\n\n  const tempFile = path.join(\n    dir,\n    `shadcn-icons-${randomBytes(4).toString('hex')}.tsx`,\n  )\n  const sourceFile = project.createSourceFile(tempFile, content, {\n    scriptKind: ScriptKind.TSX,\n  })\n\n  // Find all sourceLibrary imports.\n  const targetedIcons: string[] = []\n  for (const importDeclaration of sourceFile.getImportDeclarations() ?? []) {\n    if (\n      importDeclaration.getModuleSpecifier()?.getText()\n      !== `\"${sourceLibraryImport}\"`\n    ) {\n      continue\n    }\n\n    for (const specifier of importDeclaration.getNamedImports() ?? []) {\n      const iconName = specifier.getName()\n\n      // TODO: this is O(n^2) but okay for now.\n      const targetedIcon = Object.values(iconsMapping).find(\n        icon => icon[sourceLibrary] === iconName,\n      )?.[targetLibrary]\n\n      if (!targetedIcon || targetedIcons.includes(targetedIcon)) {\n        continue\n      }\n\n      targetedIcons.push(targetedIcon)\n\n      // Remove the named import.\n      specifier.remove()\n\n      // Replace with the targeted icon.\n      sourceFile\n        .getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement)\n        .filter(node => node.getTagNameNode()?.getText() === iconName)\n        .forEach(node => node.getTagNameNode()?.replaceWithText(targetedIcon))\n    }\n\n    // If the named import is empty, remove the import declaration.\n    if (importDeclaration.getNamedImports()?.length === 0) {\n      importDeclaration.remove()\n    }\n  }\n\n  if (targetedIcons.length > 0) {\n    sourceFile.addImportDeclaration({\n      moduleSpecifier: targetLibraryImport,\n      namedImports: targetedIcons.map(icon => ({\n        name: icon,\n      })),\n    })\n  }\n\n  return await sourceFile.getText()\n}\n","import type { z } from 'zod'\nimport type { migrateOptionsSchema } from '@/src/commands/migrate'\nimport fs from 'fs-extra'\nimport path from 'pathe'\n// import { addOptionsSchema } from '@/src/commands/add'\nimport * as ERRORS from '@/src/utils/errors'\nimport { getConfig } from '@/src/utils/get-config'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\n\nexport async function preFlightMigrate(\n  options: z.infer<typeof migrateOptionsSchema>,\n) {\n  const errors: Record<string, boolean> = {}\n\n  // Ensure target directory exists.\n  // Check for empty project. We assume if no package.json exists, the project is empty.\n  if (\n    !fs.existsSync(options.cwd)\n    || !fs.existsSync(path.resolve(options.cwd, 'package.json'))\n  ) {\n    errors[ERRORS.MISSING_DIR_OR_EMPTY_PROJECT] = true\n    return {\n      errors,\n      config: null,\n    }\n  }\n\n  // Check for existing components.json file.\n  if (!fs.existsSync(path.resolve(options.cwd, 'components.json'))) {\n    errors[ERRORS.MISSING_CONFIG] = true\n    return {\n      errors,\n      config: null,\n    }\n  }\n\n  try {\n    const config = await getConfig(options.cwd)\n\n    return {\n      errors,\n      config: config!,\n    }\n  }\n  catch (error) {\n    logger.break()\n    logger.error(\n      `An invalid ${highlighter.info(\n        'components.json',\n      )} file was found at ${highlighter.info(\n        options.cwd,\n      )}.\\nBefore you can run a migration, you must create a valid ${highlighter.info(\n        'components.json',\n      )} file by running the ${highlighter.info('init')} command.`,\n    )\n    logger.error(\n      `Learn more at ${highlighter.info(\n        'https://shadcn-vue.com/docs/components-json',\n      )}.`,\n    )\n    logger.break()\n    process.exit(1)\n  }\n}\n","import { Command } from 'commander'\nimport consola from 'consola'\nimport path from 'pathe'\nimport { z } from 'zod'\nimport { migrateIcons } from '@/src/migrations/migrate-icons'\nimport { preFlightMigrate } from '@/src/preflights/preflight-migrate'\nimport * as ERRORS from '@/src/utils/errors'\nimport { handleError } from '@/src/utils/handle-error'\n\nexport const migrations = [\n  {\n    name: 'icons',\n    description: 'migrate your ui components to a different icon library.',\n  },\n] as const\n\nexport const migrateOptionsSchema = z.object({\n  cwd: z.string(),\n  list: z.boolean(),\n  migration: z\n    .string()\n    .refine(\n      value =>\n        value && migrations.some(migration => migration.name === value),\n      {\n        message:\n          'You must specify a valid migration. Run `shadcn migrate --list` to see available migrations.',\n      },\n    )\n    .optional(),\n})\n\nexport const migrate = new Command()\n  .name('migrate')\n  .description('run a migration.')\n  .argument('[migration]', 'the migration to run.')\n  .option(\n    '-c, --cwd <cwd>',\n    'the working directory. defaults to the current directory.',\n    process.cwd(),\n  )\n  .option('-l, --list', 'list all migrations.', false)\n  .action(async (migration, opts) => {\n    try {\n      const options = migrateOptionsSchema.parse({\n        cwd: path.resolve(opts.cwd),\n        migration,\n        list: opts.list,\n      })\n\n      if (options.list || !options.migration) {\n        consola.info('Available migrations:')\n        for (const migration of migrations) {\n          consola.info(`- ${migration.name}: ${migration.description}`)\n        }\n        return\n      }\n\n      if (!options.migration) {\n        throw new Error(\n          'You must specify a migration. Run `shadcn migrate --list` to see available migrations.',\n        )\n      }\n\n      const { errors, config } = await preFlightMigrate(options)\n\n      if (\n        errors[ERRORS.MISSING_DIR_OR_EMPTY_PROJECT]\n        || errors[ERRORS.MISSING_CONFIG]\n      ) {\n        throw new Error(\n          'No `components.json` file found. Ensure you are at the root of your project.',\n        )\n      }\n\n      if (!config) {\n        throw new Error(\n          'Something went wrong reading your `components.json` file. Please ensure you have a valid `components.json` file.',\n        )\n      }\n\n      if (options.migration === 'icons') {\n        await migrateIcons(config)\n      }\n    }\n    catch (error) {\n      handleError(error)\n    }\n  })\n","{\n  \"name\": \"shadcn-vue\",\n  \"type\": \"module\",\n  \"version\": \"2.2.0\",\n  \"description\": \"Add components to your apps.\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/unovue/shadcn-vue.git\",\n    \"directory\": \"packages/cli\"\n  },\n  \"keywords\": [\n    \"components\",\n    \"ui\",\n    \"vue\",\n    \"nuxt\",\n    \"tailwind\",\n    \"radix-ui\",\n    \"radix-vue\",\n    \"reka-ui\",\n    \"shadcn\",\n    \"shadcn-vue\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"default\": \"./dist/index.js\"\n    },\n    \"./registry\": {\n      \"types\": \"./dist/registry/index.d.ts\",\n      \"default\": \"./dist/registry/index.js\"\n    }\n  },\n  \"bin\": \"./dist/index.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"dev\": \"tsdown --watch\",\n    \"build\": \"tsdown\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"clean\": \"node ./scripts/rimraf.js\",\n    \"lint\": \"eslint .\",\n    \"lint:fix\": \"eslint --fix .\",\n    \"start:dev\": \"REGISTRY_URL=http://localhost:5173/r node dist/index.js\",\n    \"start\": \"node dist/index.js\",\n    \"release\": \"changeset version\",\n    \"pub:beta\": \"pnpm build && pnpm publish --no-git-checks --access public --tag beta\",\n    \"pub:next\": \"pnpm build && pnpm publish --no-git-checks --access public --tag next\",\n    \"pub:release\": \"pnpm build && pnpm publish  --no-git-checks --access public\",\n    \"test\": \"vitest run\",\n    \"test:update\": \"vitest run -u\",\n    \"test:ui\": \"vitest --ui\"\n  },\n  \"dependencies\": {\n    \"@unovue/detypes\": \"^0.8.5\",\n    \"@vue/compiler-sfc\": \"^3.5\",\n    \"commander\": \"^14.0.0\",\n    \"consola\": \"^3.4.2\",\n    \"cosmiconfig\": \"^9.0.0\",\n    \"deepmerge\": \"^4.3.1\",\n    \"diff\": \"^8.0.2\",\n    \"fs-extra\": \"^11.3.0\",\n    \"get-tsconfig\": \"^4.10.1\",\n    \"magic-string\": \"^0.30.17\",\n    \"nypm\": \"^0.6.0\",\n    \"ofetch\": \"^1.4.1\",\n    \"ora\": \"^8.2.0\",\n    \"pathe\": \"^2.0.3\",\n    \"postcss\": \"^8.5.3\",\n    \"prompts\": \"^2.4.2\",\n    \"reka-ui\": \"catalog:\",\n    \"stringify-object\": \"^5.0.0\",\n    \"tailwindcss\": \"^4.1.7\",\n    \"tinyexec\": \"^1.0.1\",\n    \"tinyglobby\": \"catalog:\",\n    \"ts-morph\": \"^26.0.0\",\n    \"undici\": \"^7.10.0\",\n    \"vue-metamorph\": \"^3.3.3\",\n    \"zod\": \"catalog:\"\n  },\n  \"devDependencies\": {\n    \"@types/diff\": \"^8.0.0\",\n    \"@types/fs-extra\": \"^11.0.4\",\n    \"@types/node\": \"^22.15.21\",\n    \"@types/prompts\": \"^2.4.9\",\n    \"@types/stringify-object\": \"^4.0.5\",\n    \"msw\": \"^2.8.4\",\n    \"tsdown\": \"^0.12.3\",\n    \"type-fest\": \"^4.41.0\",\n    \"typescript\": \"catalog:\"\n  }\n}\n","#!/usr/bin/env node\nimport { Command } from 'commander'\nimport { add } from '@/src/commands/add'\nimport { build } from '@/src/commands/build'\nimport { diff } from '@/src/commands/diff'\nimport { info } from '@/src/commands/info'\nimport { init } from '@/src/commands/init'\nimport { migrate } from '@/src/commands/migrate'\n\nimport packageJson from '../package.json'\n\nprocess.on('SIGINT', () => process.exit(0))\nprocess.on('SIGTERM', () => process.exit(0))\n\nasync function main() {\n  const program = new Command()\n    .name('shadcn-vue')\n    .description('add components and dependencies to your project')\n    .version(\n      packageJson.version || '1.0.0',\n      '-v, --version',\n      'display the version number',\n    )\n\n  program\n    .addCommand(init)\n    .addCommand(add)\n    .addCommand(diff)\n    .addCommand(migrate)\n    .addCommand(info)\n    .addCommand(build)\n\n  program.parse()\n}\n\nmain()\n\nexport * from './registry/api'\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAa,+BAA+B;AAE5C,MAAa,iBAAiB;AAE9B,MAAa,0BAA0B;AACvC,MAAa,uBAAuB;AACpC,MAAa,wBAAwB;AAMrC,MAAa,8BAA8B;;;;ACF3C,eAAsB,cACpBA,SACA;CACA,MAAMC,SAAkC,CAAE;AAI1C,MACG,GAAG,WAAW,QAAQ,IAAI,KACvB,GAAG,WAAW,KAAK,QAAQ,QAAQ,KAAK,eAAe,CAAC,EAC5D;AACA,yCAA8C;AAC9C,SAAO;GACL;GACA,aAAa;EACd;CACF;CAED,MAAM,iBAAiB,SAAS,oBAAoB,EAClD,QAAQ,QAAQ,OACjB,EAAC,CAAC,OAAO;AAEV,KACE,GAAG,WAAW,KAAK,QAAQ,QAAQ,KAAK,kBAAkB,CAAC,KACvD,QAAQ,OACZ;AACA,kBAAgB,MAAM;AACtB,SAAO,OAAO;AACd,SAAO,OACJ,IAAI,YAAY,KACf,kBACD,CAAC,0BAA0B,YAAY,KACtC,QAAQ,IACT,CAAC,+BAA+B,YAAY,KAC3C,kBACD,CAAC,gBAAgB,YAAY,KAAK,OAAO,CAAC,SAC5C;AACD,SAAO,OAAO;AACd,UAAQ,KAAK,EAAE;CAChB;AAED,iBAAgB,SAAS;CAEzB,MAAM,mBAAmB,SAAS,uBAAuB,EACvD,QAAQ,QAAQ,OACjB,EAAC,CAAC,OAAO;CACV,MAAM,cAAc,MAAM,eAAe,QAAQ,IAAI;AACrD,MAAK,eAAe,aAAa,UAAU,SAAS,UAAU;AAC5D,kCAAuC;AACvC,oBAAkB,MAAM;AACxB,SAAO,OAAO;AACd,MAAI,aAAa,UAAU,MAAM,aAC/B,QAAO,OACJ,+CAA+C,YAAY,KAC1D,QAAQ,IACT,CAAC,WACS,YAAY,KACrB,aAAa,UAAU,MAAM,aAC9B,CAAC,+FACH;AAEH,SAAO,OAAO;AACd,UAAQ,KAAK,EAAE;CAChB;AACD,mBAAkB,SACf,6BAA6B,YAAY,KACxC,YAAY,UAAU,MACvB,CAAC,GACH;CAED,IAAI,yBAAyB;AAE7B,KAAI,YAAY,oBAAoB,KAClC,2BAA0B,wCAAwC,YAAY,KAC5E,KACD,CAAC;CAGJ,MAAM,kBAAkB,QAAQ,wBAAwB,EACtD,QAAQ,QAAQ,OACjB,EAAC,CAAC,OAAO;AACV,KACE,YAAY,oBAAoB,UAC3B,aAAa,uBAAuB,aAAa,kBACtD;AACA,oCAAyC;AACzC,mBAAiB,MAAM;CACxB,WAEC,YAAY,oBAAoB,SAC5B,aAAa,iBACjB;AACA,oCAAyC;AACzC,mBAAiB,MAAM;CACxB,YACS,YAAY,iBAAiB;AACrC,oCAAyC;AACzC,mBAAiB,MAAM;CACxB,MAEC,kBAAiB,SAAS;CAG5B,MAAM,kBAAkB,SAAS,2BAA2B,EAC1D,QAAQ,QAAQ,OACjB,EAAC,CAAC,OAAO;AACV,MAAK,aAAa,aAAa;AAC7B,iCAAsC;AACtC,mBAAiB,MAAM;CACxB,MAEC,kBAAiB,SAAS;AAG5B,KAAI,OAAO,KAAK,OAAO,CAAC,SAAS,GAAG;AAClC,MAAI,iCAAwC;AAC1C,UAAO,OAAO;AACd,UAAO,OACJ,yCAAyC,YAAY,KACpD,QAAQ,IACT,CAAC,GACH;AACD,UAAO,OACJ,uFACF;AACD,UAAO,OAAO,sCAAsC;AACpD,OAAI,aAAa,UAAU,MAAM,SAC/B,QAAO,OACJ,QAAQ,YAAY,KACnB,aAAa,UAAU,MAAM,SAC9B,CAAC,kBACH;EAEJ;AAED,MAAI,8BAAqC;AACvC,UAAO,OAAO;AACd,UAAO,OAAO,mDAAmD;AACjE,OAAI,aAAa,UAAU,MAAM,aAC/B,QAAO,OACJ,QAAQ,YAAY,KACnB,aAAa,UAAU,MAAM,aAC9B,CAAC,uCACH;EAEJ;AAED,SAAO,OAAO;AACd,UAAQ,KAAK,EAAE;CAChB;AAED,QAAO;EACL;EACA;CACD;AACF;;;;ACxJD,eAAsB,UACpBC,KACAC,QACAC,SAGA;AACA,MACG,OAAO,cAAc,gBAClB,OACD,OAAO,KAAK,IAAI,CAAC,WAAW,EAE/B;AAGF,WAAU;EACR,QAAQ;EACR,GAAG;CACJ;CAED,MAAM,cAAc,OAAO,cAAc;CACzC,MAAM,sBAAsB,KAAK,SAC/B,OAAO,cAAc,KACrB,YACD;CACD,MAAM,aAAa,SAChB,WAAW,YAAY,KAAK,oBAAoB,CAAC,GAClD,EACE,QAAQ,QAAQ,OACjB,EACF,CAAC,OAAO;CAET,MAAM,MAAM,MAAM,SAAG,SAAS,aAAa,OAAO;CAClD,MAAM,SAAS,MAAM,aAAa,KAAK,IAAI;AAC3C,OAAM,SAAG,UAAU,aAAa,QAAQ,OAAO;AAC/C,YAAW,SAAS;AACrB;AAED,eAAsB,aACpBC,OACAC,KACA;CACA,MAAM,UAAU,CAAC,gBAAgB,IAAI,AAAC;CAEtC,MAAM,SAAS,MAAM,QAAQ,QAAQ,CAAC,QAAQ,OAAO,EACnD,aACD,EAAC;CAEF,IAAI,SAAS,OAAO;AACpB,UAAS,OAAO,QAAQ,0BAA0B,GAAG;AACrD,UAAS,OAAO,QAAQ,eAAe,OAAO;AAC9C,UAAS,OAAO,SAAS;AAEzB,QAAO;AACR;AAED,SAAS,gBAAgBA,KAA4C;AACnE,QAAO;EACL,eAAe;EACf,KAAKC,MAAY;AACf,QAAK,MAAM,CAAC,UAAU,WAAW,IAAI,OAAO,QAAQ,IAAI,CACtD,KAAI,SAAS,WAAW,IAAI,EAAE;IAE5B,MAAM,cAAc,SAAS,MAAM,qBAAqB;AACxD,SAAK,YACH;IAEF,MAAM,GAAGC,QAAM,OAAO,GAAG;AAGzB,QAAIA,WAAS,aAAa;KACxB,IAAI,cAAc,KAAK,OAAO,KAC5B,CAAC,SACC,KAAK,SAAS,YACX,KAAK,SAAS,WACd,KAAK,WAAW,SACtB;AAED,UAAK,aAAa;AAChB,oBAAc,QAAQ,OAAO;OAC3B,MAAM;OACN,QAAQ;OACR,MAAM;QAAE,WAAW;QAAM,SAAS;QAAK,QAAQ;OAAM;MACtD,EAAC;AACF,WAAK,OAAO,YAAY;AACxB,WAAK,aACH,aACA,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CACzC;KACF;KAED,MAAM,gBAAgB,QAAQ,OAAO;MACnC,MAAM;MACN;MACA,MAAM;OAAE,WAAW;OAAM,SAAS;OAAK,QAAQ;MAAQ;KACxD,EAAC;AAEF,iBAAY,OAAO,cAAc;AAEjC,gBAAW,eAAe,SACxB,MAAK,MAAM,CAAC,MAAM,UAAU,IAAI,OAAO,QAAQ,WAAW,CACxD,aAAY,eAAe,MAAM,UAAU;IAGhD,WAEQA,WAAS,WAAW;KAC3B,MAAM,gBAAgB,KAAK,OAAO,KAChC,CAAC,SACC,KAAK,SAAS,YACX,KAAK,SAASA,UACd,KAAK,WAAW,OACtB;AAED,UAAK,eAAe;MAClB,MAAM,SAAS,QAAQ,OAAO;OAC5B;OACA;OACA,MAAM;QAAE,WAAW;QAAM,SAAS;QAAK,QAAQ;OAAM;MACtD,EAAC;AAEF,WAAK,OAAO,OAAO;AACnB,WAAK,aACH,QACA,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CACzC;AAGD,iBAAW,eAAe,UACxB;YAAK,MAAM,CAAC,MAAM,MAAM,IAAI,OAAO,QAAQ,WAAW,CACpD,YAAW,UAAU,UAAU;QAC7B,MAAM,OAAO,QAAQ,KAAK;SACxB;SACA;SACA,MAAM;UAAE,WAAW;UAAM,QAAQ;SAAU;QAC5C,EAAC;AACF,eAAO,OAAO,KAAK;OACpB,kBACe,UAAU,SACxB,aAAY,QAAQ,MAAM,MAAM;MAEnC;KAEJ,kBAGY,eAAe,UACxB;WAAK,MAAM,CAAC,MAAM,MAAM,IAAI,OAAO,QAAQ,WAAW,CACpD,YAAW,UAAU,UAAU;OAC7B,MAAM,eAAe,cAAc,OAAO,KACxC,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,SAAS,KACzC;OAED,MAAM,OAAO,QAAQ,KAAK;QACxB;QACA;QACA,MAAM;SAAE,WAAW;SAAM,QAAQ;QAAU;OAC5C,EAAC;AAEF,sBACI,aAAa,YAAY,KAAK,GAC9B,cAAc,OAAO,KAAK;MAC/B,kBACe,UAAU,SACxB,aAAY,eAAe,MAAM,MAAM;KAE1C;IAGN,MAGC,eAAc,MAAMA,QAAM,QAAQ,WAAW;GAEhD,MAGC,aAAY,MAAM,UAAU,WAAW;EAG5C;CACF;AACF;AAED,SAAS,cACPC,MACAC,QACAC,QACAC,YACA;CAEA,IAAI,SAAS,KAAK,OAAO,KACvB,CAAC,SACC,KAAK,SAAS,YAAY,KAAK,SAASJ,UAAQ,KAAK,WAAW,OACnE;AAED,MAAK,QAAQ;AACX,WAAS,QAAQ,OAAO;GACtB;GACA;GACA,MAAM;IAAE,WAAW;IAAM,SAAS;IAAK,QAAQ;GAAM;EACtD,EAAC;AACF,OAAK,OAAO,OAAO;AACnB,OAAK,aAAa,QAAQ,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CAAC;CACpE;AAGD,YAAW,eAAe,SACxB,MAAK,MAAM,CAAC,eAAe,WAAW,IAAI,OAAO,QAAQ,WAAW,CAClE,KAAI,cAAc,WAAW,IAAI,EAAE;EAEjC,MAAM,cAAc,cAAc,MAAM,qBAAqB;AAC7D,MAAI,aAAa;GACf,MAAM,GAAG,YAAY,aAAa,GAAG;AACrC,iBAAc,QAAQ,YAAY,cAAc,WAAW;EAC5D;CACF,MAGC,aAAY,QAAQ,eAAe,WAAW;iBAIpC,eAAe,SAE7B,KAAI;EAEF,MAAM,SAAS,QAAQ,OAAO,QAAQ,WAAW,GAAG;EACpD,MAAM,WAAW,OAAO;AAExB,MAAI,YAAY,SAAS,OAAO;GAE9B,MAAM,OAAO,QAAQ,KAAK;IACxB,UAAU;IACV,MAAM;KAAE,WAAW;KAAM,SAAS;KAAK,QAAQ;IAAQ;GACxD,EAAC;AAGF,YAAS,MAAM,QAAQ,CAAC,SAAS;AAC/B,QAAI,KAAK,SAAS,QAAQ;KACxB,MAAM,QAAQ,KAAK,OAAO;AAC1B,WAAM,KAAK,SAAS;AACpB,UAAK,OAAO,MAAM;IACnB;GACF,EAAC;AAGF,OAAI,KAAK,OAAO,OACd,QAAO,OAAO,KAAK;EAEtB;CACF,SACM,OAAO;AACZ,UAAQ,MAAM,kCAAkC,YAAY,MAAM;AAClE,QAAM;CACP;AAEJ;AAED,SAAS,YAAYK,QAAuBC,UAAkBF,YAAiB;CAC7E,IAAI,OAAO,OAAO,OAAO,KACvB,CAAC,SAAuB,KAAK,SAAS,UAAU,KAAK,aAAa,SACnE;AAED,MAAK,MAAM;AACT,SAAO,QAAQ,KAAK;GAClB;GACA,MAAM;IAAE,WAAW;IAAM,SAAS;IAAK,QAAQ;GAAQ;EACxD,EAAC;AACF,SAAO,OAAO,KAAK;CACpB;AAED,YAAW,eAAe,UACxB;OAAK,MAAM,CAAC,MAAM,MAAM,IAAI,OAAO,QAAQ,WAAW,CACpD,YAAW,UAAU,UAAU;GAC7B,MAAM,OAAO,QAAQ,KAAK;IACxB;IACA;IACA,MAAM;KAAE,WAAW;KAAM,QAAQ;IAAU;GAC5C,EAAC;GAGF,MAAM,eAAe,KAAK,OAAO,KAC/B,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,SAAS,KACzC;AAED,kBAAe,aAAa,YAAY,KAAK,GAAG,KAAK,OAAO,KAAK;EAClE,kBACe,UAAU,UAAU;GAElC,MAAM,iBAAiB,KAAK,WAAW,IAAI,GACvC,SAAS,QAAQ,aAAa,IAAI,KAAK,UAAU,EAAE,CAAC,EAAE,GACtD;AACJ,eAAY,QAAQ,gBAAgB,MAAM;EAC3C;CACF,kBAEa,eAAe,SAE7B,KAAI;EAEF,MAAM,SAAS,QAAQ,OAAO,QAAQ,WAAW,GAAG;EACpD,MAAM,WAAW,OAAO;AAExB,MAAI,YAAY,SAAS,MAEvB,UAAS,MAAM,QAAQ,CAAC,SAAS;AAC/B,OAAI,KAAK,SAAS,QAAQ;IACxB,MAAM,QAAQ,KAAK,OAAO;AAC1B,UAAM,KAAK,SAAS;AACpB,UAAM,OAAO,MAAM;GACpB;EACF,EAAC;CAEL,SACM,OAAO;AACZ,UAAQ,MAAM,+BAA+B,UAAU,YAAY,MAAM;AACzE,QAAM;CACP;AAEJ;;;;AC9TD,eAAsB,cACpBG,SACAC,QACAC,SAQA;AACA,MAAK,OAAO,cAAc,gBAAgB,OAAO,KAAK,WAAW,CAAE,EAAC,CAAC,OACnE;AAGF,WAAU;EACR,0BAA0B;EAC1B,QAAQ;EACR,iBAAiB;EACjB,kBAAkB;EAClB,WAAW;EACX,GAAG;CACJ;CACD,MAAM,cAAc,OAAO,cAAc;CACzC,MAAM,sBAAsB,KAAK,SAC/B,OAAO,cAAc,KACrB,YACD;CACD,MAAM,iBAAiB,SACpB,4BAA4B,YAAY,KAAK,oBAAoB,CAAC,GACnE,EACE,QAAQ,QAAQ,OACjB,EACF,CAAC,OAAO;CACT,MAAM,MAAM,MAAM,SAAG,SAAS,aAAa,OAAO;CAClD,MAAM,SAAS,MAAM,mBAAiB,KAAK,WAAW,CAAE,GAAE,QAAQ;EAChE,0BAA0B,QAAQ;EAClC,iBAAiB,QAAQ;EACzB,gBAAgB,QAAQ;EACxB,kBAAkB,QAAQ;EAC1B,WAAW,QAAQ;CACpB,EAAC;AACF,OAAM,SAAG,UAAU,aAAa,QAAQ,OAAO;AAC/C,gBAAe,SAAS;AACzB;AAED,eAAsBC,mBACpBC,OACAC,SACAJ,QACAK,UAMI;CACF,0BAA0B;CAC1B,iBAAiB;CACjB;CACA,kBAAkB;CAClB,WAAW;AACZ,GACD;AACA,WAAU;EACR,0BAA0B;EAC1B,iBAAiB;EACjB;EACA,kBAAkB;EAClB,WAAW;EACX,GAAG;CACJ;CAED,IAAI,UAAU,CAAC,oBAAoB,QAAQ,AAAC;AAE5C,KAAI,QAAQ,yBACV,SAAQ,KAAK,gCAAgC,CAAC;AAGhD,KAAI,QAAQ,oBAAoB,MAAM;AACpC,YAAU,CAAE;AAGZ,MAAI,OAAO,eAAe,KAAK;GAC7B,MAAM,cAAc,eAAe,OAAO,cAAc,IAAI;AAC5D,QACG,aAAa,eAAe,2BACzB,aAAa,kBAAkB,0BAChC,QAAQ,UAEX,SAAQ,KAAK,gBAAgB,EAAE,QAAQ,iBAAkB,EAAC,CAAC;EAE9D;AAED,UAAQ,KAAK,iBAAiB,EAAE,QAAQ,uBAAwB,EAAC,CAAC;AAElE,MAAI,QAAQ,yBACV,SAAQ,KAAK,gCAAgC,CAAC;AAGhD,UAAQ,KACN,sBAAsB,SAAS,EAC7B,kBAAkB,QAAQ,iBAC3B,EAAC,CACH;AACD,UAAQ,KAAK,kBAAkB,QAAQ,CAAC;AAExC,MAAI,QAAQ,gBAAgB;AAC1B,WAAQ,KAAK,2BAA2B,QAAQ,eAAe,CAAC;AAChE,WAAQ,KAAK,oCAAoC,QAAQ,eAAe,CAAC;AACzE,WAAQ,KAAK,oCAAoC,QAAQ,eAAe,CAAC;EAC1E;CACF;AAED,KAAI,OAAO,SAAS,gBAAgB,QAAQ,UAC1C,SAAQ,KACN,sBAAsB,EAAE,iBAAiB,QAAQ,gBAAiB,EAAC,CACpE;CAGH,MAAM,SAAS,MAAM,QAAQ,QAAQ,CAAC,QAAQ,OAAO,EACnD,aACD,EAAC;CAEF,IAAI,SAAS,OAAO;AAEpB,UAAS,OAAO,QAAQ,0BAA0B,GAAG;AAErD,KAAI,QAAQ,oBAAoB,KAC9B,UAAS,OAAO,QAAQ,eAAe,OAAO;AAGhD,QAAO;AACR;AAED,SAAS,sBAAsB,EAC7B,iBAGD,EAAE;AACD,QAAO;EACL,eAAe;EACf,KAAKC,MAAY;GACf,MAAM,gBAAgB,CACpB;IACE,UAAU;IACV,OACE,oBAAoB,OAChB,kCACA;GACP,GACD;IAAE,UAAU;IAAQ,OAAO;GAAiC,CAC7D;GAED,IAAI,YAAY,KAAK,MAAM,KACzB,CAAC,SACC,KAAK,SAAS,YACX,KAAK,SAAS,WACd,KAAK,WAAW,UAChB,cAAc,MAAM,CAAC,EAAE,UAAU,OAAO,KACzC,KAAK,OAAO,KACV,CAAC,SACC,KAAK,SAAS,UACX,KAAK,aAAa,YAClB,KAAK,MAAM,KACZ,CAAC,cACC,UAAU,SAAS,YAChB,UAAU,SAAS,WACnB,UAAU,WAAW,MAC3B,CACJ,CACF,CACJ;AAED,QAAK,WAAW;AACd,gBAAY,QAAQ,OAAO;KACzB,MAAM;KACN,QAAQ;KACR,MAAM;MAAE,WAAW;MAAM,SAAS;MAAK,QAAQ;KAAM;IACtD,EAAC;AACF,SAAK,OAAO,UAAU;AACtB,SAAK,aAAa,WAAW,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CAAC;GACvE;AAED,iBAAc,QAAQ,CAAC,EAAE,UAAU,OAAO,KAAK;IAC7C,MAAM,eAAe,WAAW,OAAO,KACrC,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,aAAa,SAC7C;AAED,SAAK,aACH,YAAW,OACT,QAAQ,KAAK;KACX;KACA,OAAO,CACL,QAAQ,OAAO;MACb,MAAM;MACN,QAAQ;MACR,MAAM;OAAE,WAAW;OAAM,QAAQ;MAAU;KAC5C,EAAC,AACH;KACD,MAAM;MAAE,WAAW;MAAM,SAAS;MAAK,QAAQ;KAAQ;IACxD,EAAC,CACH;GAEJ,EAAC;EACH;CACF;AACF;AAED,SAAS,oBACPF,SACA;AACA,QAAO;EACL,eAAe;EACf,KAAKE,MAAY;GACf,IAAI,YAAY,KAAK,MAAM,KACzB,UACE,KAAK,SAAS,YACX,KAAK,SAAS,WACd,KAAK,WAAW,OACtB;AAED,SAAM,qBAAqB,SAAS;AAClC,gBAAY,QAAQ,OAAO;KACzB,MAAM;KACN,QAAQ;KACR,OAAO,CAAE;KACT,MAAM;MACJ,WAAW;MACX,QAAQ;MACR,SAAS;KACV;IACF,EAAC;AACF,SAAK,OAAO,UAAU;AACtB,SAAK,aAAa,WAAW,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CAAC;GACvE;AAED,OAAI,qBAEF,QAAO,QAAQ,QAAQ,CAAC,QAAQ,CAAC,CAAC,KAAK,KAAK,KAAK;IAC/C,MAAM,WAAW,QAAQ,UAAU,WAAW,GAAG,IAAI;AAErD,oBAAgB,WAAqB,UAAU,KAAK;GACrD,EAAC;EAEL;CACF;AACF;AAED,SAAS,mBAAmBC,MAAmB;CAC7C,MAAM,WAAW,KAAK,MAAM,KAC1B,CAAC,SAAuB,KAAK,SAAS,UAAU,KAAK,aAAa,QACnE;AAED,KAAI,UAAU;EACZ,MAAM,gBAAgB,CAAC,gBAAgB,cAAe;AAEtD,WAAS,MACN,OACC,CAAC,SACC,KAAK,SAAS,UAAU,cAAc,SAAS,KAAK,KAAK,CAC5D,CACA,QAAQ,UAAQ,KAAK,QAAQ,CAAC;AAEjC,MAAI,SAAS,MAAM,WAAW,EAC5B,UAAS,QAAQ;CAEpB;AACF;AAED,SAAS,iCAAiC;AACxC,QAAO;EACL,eAAe;EACf,KAAKD,MAAY;GACf,MAAM,WAAW,KAAK,MAAM,KAC1B,CAAC,SAAuB,KAAK,SAAS,UAAU,KAAK,aAAa,OACnE;AACD,OAAI,UAAU;AAEZ,aAAS,MACN,KACC,CAAC,SACC,KAAK,SAAS,UACX,KAAK,SAAS,WACd,CAAC,8BAA8B,mBAAoB,EAAC,SACrD,KAAK,MACN,CACJ,EACC,QAAQ;AAGZ,aAAS,MACN,KAAK,CAAC,SAAsC;AAC3C,YACE,KAAK,SAAS,UACX,KAAK,SAAS,iBAEb,KAAK,MAAM,WAAW,kBAAkB,IACvC,KAAK,UAAU;IAEvB,EAAC,EACA,QAAQ;AAGZ,aAAS,MACN,KACC,CAAC,SACC,KAAK,SAAS,UACX,KAAK,SAAS,iBACd,KAAK,UAAU,+BACrB,EACC,QAAQ;AAGZ,QAAI,SAAS,MAAM,WAAW,EAC5B,UAAS,QAAQ;GAEpB;AAED,sBAAmB,KAAK;GAExB,MAAM,eAAe,KAAK,MAAM,KAC9B,CAAC,SACC,KAAK,SAAS,YACX,KAAK,WAAW,+BACtB;AAED,OAAI,cAAc;AAChB,uBAAmB,aAAa;AAChC,QAAI,aAAa,MAAM,WAAW,EAChC,cAAa,QAAQ;GAExB;EACF;CACF;AACF;AAED,SAAS,gBACPE,WACAC,UACAC,MACA;CACA,IAAI,WAAW,UAAU,OAAO,KAC9B,CAAC,SAAuB,KAAK,SAAS,UAAU,KAAK,aAAa,SACnE;AAED,MAAK,UACH;MAAI,OAAO,KAAK,KAAK,CAAC,SAAS,GAAG;AAChC,cAAW,QAAQ,KAAK;IACtB;IACA,MAAM;KAAE,SAAS;KAAK,QAAQ;IAAQ;GACvC,EAAC;AACF,aAAU,OAAO,SAAS;EAC3B;;AAGH,QAAO,QAAQ,KAAK,CAAC,QAAQ,CAAC,CAAC,KAAK,MAAM,KAAK;EAC7C,MAAM,QAAQ,IAAI,IAAI,QAAQ,OAAO,GAAG,CAAC;EACzC,MAAM,UAAU,QAAQ,KAAK;GAC3B;GACA;GACA,MAAM,EAAE,WAAW,KAAM;EAC1B,EAAC;EAEF,MAAM,eAAe,UAAU,MAAM,KACnC,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,SAAS,KACzC;AAED,iBAAe,aAAa,YAAY,QAAQ,GAAG,UAAU,OAAO,QAAQ;CAC7E,EAAC;AACH;AAED,SAAS,sBACPN,SACAO,SAGA;AACA,QAAO;EACL,eAAe;EACf,KAAKL,MAAY;AACf,UAAO,QAAQ,QAAQ,CAAC,QAAQ,CAAC,CAAC,KAAK,KAAK,KAAK;IAC/C,IAAI,WAAW,QAAQ,UAAU,WAAW,GAAG,IAAI;AAEnD,QAAI,QAAQ,SAAS;AACnB,gBAAW;KACX,MAAM,YAAY,gBAAgB,KAAK;AACvC,YAAO,QAAQ,KAAK,CAAC,QAAQ,CAAC,CAACM,OAAK,MAAM,KAAK;MAC7C,MAAM,QAAQ,IAAI,MAAI,QAAQ,OAAO,GAAG,CAAC;MACzC,MAAM,UAAU,QAAQ,KAAK;OAC3B;OACA;OACA,MAAM,EAAE,WAAW,KAAM;MAC1B,EAAC;MAEF,MAAM,eAAe,WAAW,OAAO,KACrC,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,SAAS,KACzC;AAMD,UAAI,QAAQ,iBACV,KAAI,aACF,cAAa,YAAY,QAAQ;UAGjC,YAAW,OAAO,QAAQ;gBAIvB,aACH,YAAW,OAAO,QAAQ;KAG/B,EAAC;AACF;IACD;IAED,IAAI,WAAW,KAAK,OAAO,KACzB,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,aAAa,SAC7C;AAED,SAAK,YAAY,OAAO,KAAK,KAAK,CAAC,SAAS,GAAG;AAC7C,gBAAW,QAAQ,KAAK;MACtB;MACA,OAAO,CAAE;MACT,MAAM;OAAE,WAAW;OAAM,SAAS;OAAK,QAAQ;MAAM;KACtD,EAAC;AACF,UAAK,OAAO,SAAS;AACrB,UAAK,aAAa,UAAU,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CAAC;IACtE;AAED,WAAO,QAAQ,KAAK,CAAC,QAAQ,CAAC,CAACA,OAAK,MAAM,KAAK;KAC7C,IAAI,QAAQ,IAAI,MAAI,QAAQ,OAAO,GAAG,CAAC;AAGvC,SAAI,SAAS,uBACX,QAAO;AAGT,SAAI,gBAAgB,MAAM,CACxB,UAAS,MAAM,MAAM;KAGvB,MAAM,UAAU,QAAQ,KAAK;MAC3B;MACA;MACA,MAAM,EAAE,WAAW,KAAM;KAC1B,EAAC;KACF,MAAM,eAAe,UAAU,MAAM,KACnC,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,SAAS,KACzC;AAMD,SAAI,QAAQ,iBACV,KAAI,aACF,cAAa,YAAY,QAAQ;SAGjC,WAAU,OAAO,QAAQ;eAItB,aACH,WAAU,OAAO,QAAQ;IAG9B,EAAC;GACH,EAAC;EACH;CACF;AACF;AAED,SAAS,kBAAkBR,SAAoD;AAC7E,QAAO;EACL,eAAe;EACf,KAAKE,MAAY;GAEf,MAAM,YAAY,MAAM,KACtB,IAAI,IACF,OAAO,KAAK,QAAQ,CAAC,QAAQ,SAC3B,OAAO,KAAK,QAAQ,QAAgC,CAAE,EAAC,CACxD,EAEJ;AAED,QAAK,UAAU,OACb;GAGF,MAAM,YAAY,gBAAgB,KAAK;GAEvC,MAAM,gBAAgB,UAAU,OAAO,OACrC,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,KAAK,WAAW,KAAK,CACrD;AAED,QAAK,MAAM,YAAY,WAAW;IAChC,MAAM,QAAQ,OAAO,OAAO,QAAQ,CAAC,KAAK,UAAQ,KAAK,UAAU,GAC/D;AAGF,SAAK,MACH;AAGF,QAAI,aAAa,UAAU;KACzB,MAAM,kBAAkB;MACtB,IAAI;MACJ,IAAI;MACJ,IAAI;MACJ,IAAI;KACL;AACD,UAAK,MAAM,CAAC,KAAKO,QAAM,IAAI,OAAO,QAAQ,gBAAgB,EAAE;MAC1D,MAAMC,eAAa,QAAQ,KAAK;OAC9B,OAAO,WAAW,IAAI;OACtB;OACA,MAAM,EAAE,WAAW,KAAM;MAC1B,EAAC;AACF,UACE,WAAW,OAAO,KAChB,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,SAASA,aAAW,KACpD,CAED;AAEF,iBAAW,OAAOA,aAAW;KAC9B;AACD;IACD;IAED,IAAI,OACA,gBAAgB,MAAM,IAAI,aAAa,MAAM,IAC1C,UAAU,SAAS,QAAQ,OAAO,GAAG,CAAC,KACtC,IAAI,SAAS,QAAQ,OAAO,GAAG,CAAC;AACvC,QAAI,SAAS,6BACX,QAAO;IAGT,IAAI,aAAa,QAAQ,SAAS;AAClC,QAAI,SAAS,kBACX,aAAY;IAGd,MAAM,aAAa,QAAQ,KAAK;KAC9B;KACA,OAAO;KACP,MAAM,EAAE,WAAW,KAAM;IAC1B,EAAC;IACF,MAAM,eAAe,WAAW,OAAO,KACrC,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,SAAS,WAAW,KACpD;AACD,SAAK,aACH,KAAI,eAAe,OACjB,YAAW,YACT,cAAc,cAAc,SAAS,IACrC,WACD;QAGD,YAAW,OAAO,WAAW;GAGlC;EACF;CACF;AACF;AAED,SAAS,gBAAgBR,MAAoB;CAC3C,IAAI,YAAY,KAAK,MAAM,KACzB,CAAC,SACC,KAAK,SAAS,YACX,KAAK,SAAS,WACd,KAAK,WAAW,SACtB;AAED,MAAK,WAAW;AACd,cAAY,QAAQ,OAAO;GACzB,MAAM;GACN,QAAQ;GACR,OAAO,CAAE;GACT,MAAM;IAAE,WAAW;IAAM,SAAS;IAAK,QAAQ;GAAM;EACtD,EAAC;AACF,OAAK,OAAO,UAAU;AACtB,OAAK,aAAa,WAAW,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CAAC;CACvE;AAED,QAAO;AACR;AAED,SAAS,iBAAiB,EAAE,QAA4B,EAAE;AACxD,QAAO;EACL,eAAe;EACf,KAAKA,MAAY;GACf,MAAM,gBAAgB,KAAK,MAAM,KAC/B,CAAC,SACC,KAAK,SAAS,YAAY,KAAK,SAAS,iBAC3C;AAED,QAAK,eAAe;IAElB,MAAM,cAAc,KAAK,MAAM,OAC7B,CAAC,SACC,KAAK,SAAS,YAAY,KAAK,SAAS,SAC3C;IAED,MAAM,cAAc,QAAQ,OAAO;KACjC,MAAM;KACN;KACA,MAAM;MAAE,WAAW;MAAM,QAAQ;KAAM;IACxC,EAAC;AAEF,QAAI,YAAY,SAAS,GAAG;KAE1B,MAAM,aAAa,YAAY,YAAY,SAAS;AACpD,UAAK,YAAY,YAAY,YAAY;IAC1C,MAGC,MAAK,YAAY,KAAK,MAAM,IAAI,YAAY;AAG9C,SAAK,aAAa,aAAa,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CAAC;GACzE;EACF;CACF;AACF;AAED,SAAS,gBAAgB,EAAE,QAA4B,EAAE;AACvD,QAAO;EACL,eAAe;EACf,KAAKA,MAAY;GACf,MAAM,cAAc,KAAK,MAAM,OAC7B,CAAC,SACC,KAAK,SAAS,YAAY,KAAK,SAAS,SAC3C;GAGD,MAAM,oBAAoB,KAAK,MAAM,KACnC,CAAC,SACC,KAAK,SAAS,YAAY,KAAK,SAAS,iBAC3C;GAGD,MAAM,YAAY,YAAY,KAC5B,UAAQ,KAAK,OAAO,QAAQ,SAAS,GAAG,KAAK,OAC9C;AAED,QAAK,WAAW;IACd,MAAM,aAAa,QAAQ,OAAO;KAChC,MAAM;KACN,SAAS,GAAG,OAAO;KACnB,MAAM;MAAE,WAAW;MAAM,QAAQ;KAAM;IACxC,EAAC;AAEF,QAAI,YAAY,SAAS,GAAG;KAE1B,MAAM,aAAa,YAAY,YAAY,SAAS;AACpD,UAAK,YAAY,YAAY,WAAW;IACzC,WACQ,mBAAmB;AAE1B,UAAK,aAAa,mBAAmB,WAAW;AAChD,UAAK,aACH,mBACA,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CACzC;IACF,OACI;AAEH,UAAK,QAAQ,WAAW;AACxB,UAAK,YAAY,YAAY,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CAAC;IACvE;GACF;EACF;CACF;AACF;AAED,SAAS,2BACPS,gBACA;AACA,QAAO;EACL,eAAe;EACf,KAAKT,MAAY;AACf,QAAK,gBAAgB,QACnB;GAGF,MAAM,YAAY,aAAa,KAAK;GACpC,MAAM,QAAQ,cAAc,WAAW,MAAO;GAE9C,MAAM,cAAc,KAAK,MAAM,OAC7B,CAAC,SACC,KAAK,SAAS,YAAY,KAAK,SAAS,SAC3C;GAED,MAAM,iBACF,YAAY,YAAY,SAAS,MAAM,KAAK,MAAM;AAEtD,QAAK,MAAM,UAAU,eAAe,SAAS;IAC3C,MAAM,aAAa,OAAO,QAAQ,2BAA2B,GAAG;AAGhE,QACE,YAAY,KAAK,CAAC,SAAS;AACzB,YAAO,KAAK,OAAO,QAAQ,SAAS,GAAG,KAAK;IAC7C,EAAC,CAEF;IAGF,MAAM,aAAa,QAAQ,OAAO;KAChC,MAAM;KACN,SAAS,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM;KACtC,MAAM;MAAE,WAAW;MAAM,QAAQ;KAAM;IACxC,EAAC;AACF,SAAK,YAAY,gBAAgB,WAAW;AAC5C,SAAK,aAAa,YAAY,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CAAC;GACxE;EACF;CACF;AACF;AAED,SAAS,oCACPS,gBACA;AACA,QAAO;EACL,eAAe;EACf,KAAKT,MAAY;AACf,QAAK,gBAAgB,OAAO,QAAQ,UAClC;GAGF,MAAM,YAAY,gBAAgB,KAAK;GACvC,MAAM,wBAAwB,UAAU,OAAO,OAC7C,CAAC,SACC,KAAK,SAAS,YAAY,KAAK,SAAS,YAC3C;GAED,MAAM,sBAAsB,EAAE,OAC5B,EAAE,QAAQ,EACV,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,QAAQ,CAAC,CACjC;AAED,QAAK,MAAM,CAAC,cAAc,cAAc,IAAI,OAAO,QACjD,eAAe,MAAM,OAAO,UAC7B,EAAE;AACD,eAAW,iBAAiB,SAC1B;IAGF,MAAM,sBAAsB,oBAAoB,UAAU,cAAc;AAExE,SAAK,oBAAoB,QACvB;AAGF,QACE,uBAAuB,KACrB,CAAC,SACC,KAAK,SAAS,YACX,KAAK,SAAS,eACd,KAAK,WAAW,aACtB,CAED;IAGF,MAAM,eAAe,QAAQ,OAAO;KAClC,MAAM;KACN,QAAQ;KACR,OAAO,CAAE;KACT,MAAM;MAAE,WAAW;MAAM,SAAS;MAAK,QAAQ;KAAQ;IACxD,EAAC;AAEF,SAAK,MAAM,CAAC,KAAK,OAAO,IAAI,OAAO,QAAQ,oBAAoB,KAAK,EAAE;KACpE,MAAM,OAAO,QAAQ,KAAK;MACxB,UAAU;MACV,OAAO,OAAO,QAAQ,OAAO,CAAC,IAAI,CAAC,CAACM,OAAK,MAAM,KAC7C,QAAQ,KAAK;OACX,MAAMA;OACN;OACA,MAAM;QAAE,WAAW;QAAM,QAAQ;QAAY,SAAS;OAAM;MAC7D,EAAC,CACH;MACD,MAAM;OAAE,WAAW;OAAM,SAAS;OAAK,QAAQ;MAAU;KAC1D,EAAC;AACF,kBAAa,OAAO,KAAK;IAC1B;AAED,cAAU,OAAO,aAAa;AAC9B,cAAU,aACR,cACA,QAAQ,QAAQ,EAAE,MAAM,cAAe,EAAC,CACzC;GACF;EACF;CACF;AACF;AAED,SAAS,oCACPG,gBACA;AACA,QAAO;EACL,eAAe;EACf,KAAKT,MAAY;AACf,QAAK,gBAAgB,OAAO,QAAQ,UAClC;GAGF,MAAM,YAAY,gBAAgB,KAAK;GACvC,MAAM,yBAAyB,UAAU,OAAO,OAC9C,CAAC,SACC,KAAK,SAAS,UAAU,KAAK,KAAK,WAAW,aAAa,CAC7D;GAED,MAAM,uBAAuB,EAC1B,OAAO,EAAE,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAC9B,UAAU,eAAe,MAAM,OAAO,UAAU;AACnD,QAAK,qBAAqB,QACxB;AAGF,QAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,QAAQ,qBAAqB,KAAK,EAAE;IACpE,MAAM,QAAQ,YAAY,IAAI;AAC9B,QACE,wBAAwB,KACtB,CAAC,SAAsC,KAAK,SAAS,KACtD,CAED;IAGF,MAAM,gBAAgB,QAAQ,KAAK;KACjC;KACA;KACA,MAAM;MAAE,WAAW;MAAM,SAAS;MAAM,QAAQ;KAAQ;IACzD,EAAC;AACF,cAAU,OAAO,cAAc;GAChC;EACF;CACF;AACF;AAED,SAAS,aAAaA,MAAiC;CACrD,MAAM,YAAY,KAAK,MAAM;CAC7B,MAAM,MAAM,UAAU,UAAU;AAEhC,KAAI,IAAI,SAAS,IAAK,CACpB,QAAO;AAET,QAAO;AACR;AAED,SAAgB,gBAAgBU,OAAe;AAC7C,KACE,MAAM,WAAW,MAAM,IACpB,MAAM,WAAW,MAAM,IACvB,MAAM,WAAW,IAAI,IACrB,MAAM,WAAW,QAAQ,CAE5B,QAAO;CAGT,MAAM,SAAS,MAAM,MAAM,IAAI;AAE/B,QACE,OAAO,WAAW,KACf,OAAO,MAAM,GAAG,EAAE,CAAC,MAAM,WAAS,MAAM,SAAS,IAAI,CAAC;AAE5D;AAED,SAAgB,aAAaA,OAAe;AAC1C,QACE,MAAM,WAAW,MAAM,IACpB,MAAM,WAAW,MAAM,IACvB,MAAM,WAAW,IAAI,IACrB,MAAM,WAAW,QAAQ;AAE/B;;;;ACx4BD,eAAsB,mBACpBC,gBACAC,QACAC,SAIA;AACA,kBAAe,MAAM,KAAK,IAAI,IAAIC,gBAAc;AAChD,MAAKA,gBAAc,OACjB;AAGF,WAAU;EACR,QAAQ;EACR,GAAG;CACJ;CAED,MAAM,sBAAsB,SAAS,2BAA2B,EAAE,QAAQ,QAAQ,OAAQ,EAAC,EAAE,OAAO;AACpG,sBAAqB,OAAO;AAE5B,OAAM,cAAcA,gBAAc;EAAE,KAAK,OAAO,cAAc;EAAK,QAAQ;EAAM,KAAK,SAAS;CAAK,EAAC;AACrG,sBAAqB,SAAS;AAC/B;;;;ACvBD,SAAgB,iBAAiBC,MAAoC;AACnE,QAAO;EACL,MAAM;EACN,MAAM;EAEN,UAAU,EAAE,YAAY,QAAQ,OAAO,EAAE,mBAAmB,qBAAqB,EAAE,EAAE;GACnF,IAAI,iBAAiB;GACrB,MAAM,EAAE,WAAW,QAAQ,GAAG;AAE9B,OAAI,OAAO,UAAU,iBAAiB,WAAW,aAC/C,QAAO;AAET,QAAK,MAAM,aAAa,WACtB,mBAAkB,WAAW,EAC3B,aAAaC,QAAM;AACjB,QAAIA,OAAK,OAAO,MAAM,SAAS,8BAA8BA,OAAK,KAAK,UAAU,UAAU;AAEzF,YAAK,KAAK,QAAQ,kBAAkB,OAAK,KAAK,MAAM,QAAQ,MAAM,GAAG,EAAE,UAAU,aAAa;AAC9F;IACD;AAED,WAAO,KAAK,SAASA,OAAK;GAC3B,EACF,EAAC;AAGJ,OAAI,OACF,qBAAoB,QAAQ;IAC1B,UAAU,MAAM;AACd,SAAI,KAAK,SAAS,oBAAoB,KAAK,UAAU,UACnD;WAAK,CAAC,oBAAoB,UAAW,EAAC,SAAS,KAAK,QAAQ,QAAQ,GAAG,EAAE;AACvE,YAAK,QAAQ,kBAAkB,KAAK,MAAM,QAAQ,MAAM,GAAG,EAAE,UAAU,aAAa;AACpF;MACD;gBAGM,KAAK,SAAS,qBAAqB,KAAK,UAAU,UACzD;UAAI,KAAK,OAAO,IAAI,SAAS,SAAS;AACpC,YAAK,SAAS,GAAG,kBAAkB,KAAK,MAAM,QAAQ,MAAM,GAAG,EAAE,UAAU,aAAa,CAAC;AACzF;MACD;;IAEJ;IACD,YAAY,CAEX;GACF,EAAC;AAGJ,UAAO;EACR;CACF;AACF;AAID,SAAgB,eAAeC,WAAsC;AACnE,MAAK,UAAU,SAAS,IAAI,KAAK,UAAU,SAAS,IAAI,CACtD,QAAO;EAAC;EAAM;EAAW;CAAK;CAEhC,MAAMC,QAA2B,CAAE;CAEnC,MAAM,CAAC,MAAM,MAAM,GAAG,UAAU,MAAM,IAAI;AAG1C,MAAK,KAAK,SAAS,IAAI,CACrB,QAAO;EAAC;EAAM;EAAM;CAAM;CAG5B,MAAM,QAAQ,KAAK,MAAM,IAAI;CAG7B,MAAMC,SAAO,MAAM,KAAK;CAGxB,MAAM,UAAU,MAAM,KAAK,IAAI;AAG/B,OAAM,KAAK,WAAW,MAAMA,UAAQ,MAAM,SAAS,KAAK;AAExD,QAAO;AACR;AAED,MAAM,WAAW;CAAC;CAAO;CAAS;CAAW;CAAgB;AAAQ;AAErE,SAAgB,kBACdC,OACAC,SACA;AAEA,KAAI,MAAM,SAAS,WAAW,CAC5B,SAAQ,MAAM,QAAQ,YAAY,yBAAyB;CAE7D,MAAM,aAAa,MAAM,MAAM,IAAI;CACnC,MAAM,YAAY,IAAI;CACtB,MAAM,WAAW,IAAI;AACrB,MAAK,MAAM,aAAa,YAAY;EAClC,MAAM,CAAC,SAAS,OAAO,SAAS,GAAG,eAAe,UAAU;EAC5D,MAAM,SAAS,SAAS,KAAK,cAAU,OAAO,WAAWC,SAAO,CAAC;AACjE,OAAK,QAAQ;AACX,QAAK,UAAU,IAAI,UAAU,CAC3B,WAAU,IAAI,UAAU;AAE1B;EACD;EAED,MAAM,SAAS,OAAO,QAAQ,QAAQ,GAAG;AACzC,MAAI,UAAU,UAAU,QAAQ,OAAO;AACrC,aAAU,IACR,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,MAAM,QAAQ,CAAE,EAC3C,OAAO,QAAQ,CACf,KAAK,IAAI,IAAI,YAAY,GAAG,SAAS,IAAI,IAC7C;AAED,YAAS,IACP;IAAC;IAAQ;KAAU,EAAE,OAAO,EAAE,QAAQ,KAAK,QAAQ;GAAE,EAClD,OAAO,QAAQ,CACf,KAAK,IAAI,IAAI,YAAY,GAAG,SAAS,IAAI,IAC7C;AACD;EACD;AAED,OAAK,UAAU,IAAI,UAAU,CAC3B,WAAU,IAAI,UAAU;CAC3B;AAED,QAAO,CAAC,GAAG,MAAM,KAAK,UAAU,EAAE,GAAG,MAAM,KAAK,SAAS,AAAC,EAAC,KAAK,IAAI,CAAC,MAAM;AAC5E;;;;ACjID,SAAgB,gBAAgBC,MAAoC;AAClE,QAAO;EACL,MAAM;EACN,MAAM;EAEN,UAAU,EAAE,YAAY,OAAO,EAAE,mBAAmB,EAAE,EAAE;GACtD,MAAM,iBAAiB;GACvB,MAAM,EAAE,QAAQ,UAAU,GAAG;GAC7B,MAAM,cAAc;AAEpB,QAAK,MAAM,aAAa,WACtB,mBAAkB,WAAW,EAC3B,uBAAuBC,QAAM;AAC3B,eAAWA,OAAK,KAAK,OAAO,UAAU,UAAU;KAC9C,MAAM,aAAaA,OAAK,KAAK,OAAO;KAGpC,MAAM,gBAAgB,oBAAoB,YAAY,QAAQ,SAAS;AACvE,YAAK,KAAK,OAAO,QAAQ;AAGzB,SAAI,kBAAkB,aAAa;MACjC,MAAM,eAAe,OAAK,KAAK,YAAY,IAAI,UAAQ,KAAK,OAAO,QAAQ,GAAG,IAAI,CAAE;MACpF,MAAM,WAAW,aAAa,KAAK,OAAK,MAAM,KAAK;AACnD,UAAI,SACF,QAAK,KAAK,OAAO,QAAQ,kBAAkB,cAAc,WAAW,QAAQ,aAAa,OAAO,QAAQ,MAAM,GAAG,OAAO,QAAQ;KAEnI;IACF;AACD,WAAO,KAAK,SAASA,OAAK;GAC3B,EACF,EAAC;AAGJ,UAAO;EACR;CACF;AACF;AAED,SAAS,oBACPC,iBACAC,QACAC,WAAoB,OACpB;AAEA,MAAK,gBAAgB,WAAW,KAAK,KAAK,SACxC,QAAO;AAIT,KAAI,YAAY,gBAAgB,WAAW,KAAK,CAC9C,mBAAkB,gBAAgB,QAAQ,SAAS,sBAAsB;AAI3E,MAAK,gBAAgB,WAAW,cAAc,EAAE;EAE9C,MAAM,QAAQ,OAAO,QAAQ,WAAW,MAAM,IAAI,CAAC;AACnD,SAAO,gBAAgB,QAAQ,SAAS,EAAE,MAAM,GAAG;CACpD;AAED,KAAI,gBAAgB,MAAM,yBAAyB,CACjD,QAAO,gBAAgB,QACrB,0BACA,OAAO,QAAQ,OAAO,EAAE,OAAO,QAAQ,WAAW,KACnD;AAGH,KACE,OAAO,QAAQ,cACZ,gBAAgB,MAAM,iCAAiC,CAE1D,QAAO,gBAAgB,QACrB,kCACA,OAAO,QAAQ,WAChB;AAGH,KAAI,OAAO,QAAQ,OAAO,gBAAgB,MAAM,0BAA0B,CACxE,QAAO,gBAAgB,QACrB,2BACA,OAAO,QAAQ,IAChB;AAGH,KACE,OAAO,QAAQ,eACZ,gBAAgB,MAAM,kCAAkC,CAE3D,QAAO,gBAAgB,QACrB,mCACA,OAAO,QAAQ,YAChB;AAGH,QAAO,gBAAgB,QACrB,uBACA,OAAO,QAAQ,WAChB;AACF;;;;ACnGD,eAAsB,aAAaC,MAAqB;AACtD,KAAI,KAAK,QAAQ,WACf,QAAO,KAAK;AAEd,QAAO,MAAM,kBAAkB,KAAK,KAAK,KAAK,SAAS,CAAC,KAAK,SAAO,IAAc;AACnF;AAED,eAAsB,kBAAkBC,SAAiBC,UAAkB;AACzE,QAAO,MAAM,YAAU,SAAS,UAAU;EACxC,kBAAkB;EAClB,iBAAiB,EACf,WAAW,QACZ;CACF,EAAC;AACH;;;;ACZD,eAAsB,kBAAkBC,MAA6C;CACnF,MAAM,kBAAkB,MAAM,oCAAoC,KAAK,OAAO;AAE9E,QAAO;EACL,MAAM;EACN,MAAM;EAEN,UAAU,EAAE,YAAY,QAAQ,OAAO,EAAE,mBAAmB,qBAAqB,YAAY,EAAE,EAAE;GAC/F,IAAI,iBAAiB;GACrB,MAAM,EAAE,QAAQ,GAAG;AAEnB,QAAK,OAAO,UAAU,OACpB,QAAO;GAGT,SAAS,kBAAkBC,MAAoB;AAC7C,QAAI,KAAK,SAAS,YAAY;AAE5B,SAAI,KAAK,KAAK,SAAS,cAAc;MACnC,MAAM,UAAU,KAAK,IAAI;AACzB,aAAO;OAAC;OAAW;OAAQ;OAAS;OAAQ;MAAQ,EAAC,SAAS,QAAQ;KACvE;AACD,SAAI,KAAK,KAAK,SAAS,oBAAoB,KAAK,IAAI,UAAU,UAAU;MACtE,MAAM,UAAU,KAAK,IAAI;AACzB,aAAO;OAAC;OAAW;OAAQ;OAAS;OAAQ;MAAQ,EAAC,SAAS,QAAQ;KACvE;IACF;AACD,WAAO;GACR;GAED,SAAS,mBAAmBC,YAAuB;AAEjD,QAAI,WAAW,SAAS,oBACnB,WAAW,QAAQ,SAAS,gBAC5B,WAAW,OAAO,SAAS,KAC9B,YAAW,UAAU,QAAQ,CAACC,QAAa;AACzC,SAAI,IAAI,SAAS,oBAAoB,IAAI,UAAU,UAAU;AAC3D,UAAI,QAAQ,YAAY,IAAI,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AAC3E;KACD,WACQ,IAAI,SAAS,yBAAyB;AAE7C,UAAI,IAAI,YAAY,SAAS,oBAAoB,IAAI,WAAW,UAAU,UAAU;AAClF,WAAI,WAAW,QAAQ,YAAY,IAAI,WAAW,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AACjG;MACD;AACD,UAAI,IAAI,WAAW,SAAS,oBAAoB,IAAI,UAAU,UAAU,UAAU;AAChF,WAAI,UAAU,QAAQ,YAAY,IAAI,UAAU,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AAC/F;MACD;KACF,WACQ,IAAI,SAAS,oBAEpB;UAAI,IAAI,OAAO,SAAS,oBAAoB,IAAI,MAAM,UAAU,UAAU;AACxE,WAAI,MAAM,QAAQ,YAAY,IAAI,MAAM,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AACvF;MACD;gBAEM,IAAI,SAAS,mBAEpB,KAAI,WAAW,QAAQ,CAACC,SAAc;AACpC,UAAI,KAAK,SAAS,cAAc,KAAK,OAAO,SAAS,oBAAoB,KAAK,MAAM,UAAU,UAE5F;YAAK,kBAAkB,KAAK,EAAE;AAC5B,aAAK,MAAM,QAAQ,YAAY,KAAK,MAAM,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AACzF;OACD;;KAEJ,EAAC;UAEC;MAEH,MAAM,WAAW,WAAW,QAAQ,KAAK,EAAE,MAAM,UAAW,EAAC;AAC7D,eAAS,QAAQ,CAACC,YAAiB;AACjC,kBAAW,QAAQ,UAAU,UAAU;QAErC,IAAI,kBAAkB;QACtB,IAAI,SAAS,QAAQ;AACrB,eAAO,QAAQ;AACb,aAAI,kBAAkB,OAAO,EAAE;AAC7B,4BAAkB;AAClB;SACD;AACD,kBAAS,OAAO;QACjB;AAED,YAAI,iBAAiB;AACnB,iBAAQ,QAAQ,YAAY,QAAQ,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AACnF;QACD;OACF;MACF,EAAC;KACH;IACF,EAAC;aAGK,WAAW,SAAS,yBAAyB;AAEpD,SAAI,WAAW,WACb,oBAAmB,WAAW,WAAW;AAC3C,SAAI,WAAW,UACb,oBAAmB,WAAW,UAAU;IAC3C,WACQ,WAAW,SAAS,oBAAoB;AAC/C,SAAI,WAAW,KACb,oBAAmB,WAAW,KAAK;AACrC,SAAI,WAAW,MACb,oBAAmB,WAAW,MAAM;IACvC;GACF;AAED,QAAK,MAAM,aAAa,WACtB,mBAAkB,WAAW,EAC3B,oBAAoBC,QAAM;AAExB,QAAIA,OAAK,KAAK,OAAO,SAAS,gBAAgBA,OAAK,KAAK,OAAO,SAAS,OAAO;KAC7E,MAAM,OAAOA,OAAK,KAAK;AAGvB,SAAI,KAAK,IAAI,SAAS,oBAAoB,KAAK,GAAG,UAAU,UAAU;AACpE,WAAK,GAAG,QAAQ,YAAY,KAAK,GAAG,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AACnF;KACD;AAGD,SAAI,KAAK,IAAI,SAAS,oBAAoB;MACxC,MAAM,mBAAmB,KAAK,GAAG,WAAW,KAC1C,UAAQ,KAAK,SAAS,cACjB,KAAK,IAAI,SAAS,gBAClB,KAAK,IAAI,SAAS,WACxB;AAED,UAAI,oBAAoB,iBAAiB,SAAS,cAAc,iBAAiB,MAAM,SAAS,oBAAoB;OAElH,MAAM,gBAAgB,WAAW,QAAQ,iBAAiB,OAAO,EAAE,MAAM,WAAY,EAAC;AACtF,qBAAc,QAAQ,CAACF,SAAc;AACnC,YAAI,KAAK,OAAO,SAAS,oBAAoB,KAAK,MAAM,UAAU,UAAU;AAC1E,cAAK,MAAM,QAAQ,YAAY,KAAK,MAAM,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AACzF;QACD;OACF,EAAC;MACH;KACF;IACF;AAGD,QAAIE,OAAK,KAAK,OAAO,SAAS,gBAAgBA,OAAK,KAAK,OAAO,SAAS,KACtE,QAAK,KAAK,UAAU,QAAQ,CAAC,QAAQ;AACnC,SAAI,IAAI,SAAS,oBAAoB,IAAI,UAAU,UAAU;AAC3D,UAAI,QAAQ,YAAY,IAAI,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AAC3E;KACD,WACQ,IAAI,SAAS,yBAAyB;AAE7C,UAAI,IAAI,YAAY,SAAS,oBAAoB,IAAI,WAAW,UAAU,UAAU;AAClF,WAAI,WAAW,QAAQ,YAAY,IAAI,WAAW,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AACjG;MACD;AACD,UAAI,IAAI,WAAW,SAAS,oBAAoB,IAAI,UAAU,UAAU,UAAU;AAChF,WAAI,UAAU,QAAQ,YAAY,IAAI,UAAU,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AAC/F;MACD;KACF,WACQ,IAAI,SAAS,oBAEpB;UAAI,IAAI,OAAO,SAAS,oBAAoB,IAAI,MAAM,UAAU,UAAU;AACxE,WAAI,MAAM,QAAQ,YAAY,IAAI,MAAM,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AACvF;MACD;gBAEM,IAAI,SAAS,mBAEpB,KAAI,WAAW,QAAQ,CAACF,SAAc;AACpC,UAAI,KAAK,SAAS,cAAc,KAAK,OAAO,SAAS,oBAAoB,KAAK,MAAM,UAAU,UAE5F;YAAK,kBAAkB,KAAK,EAAE;AAC5B,aAAK,MAAM,QAAQ,YAAY,KAAK,MAAM,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AACzF;OACD;;KAEJ,EAAC;UAEC;MAEH,MAAM,WAAW,WAAW,QAAQ,KAAK,EAAE,MAAM,UAAW,EAAC;AAC7D,eAAS,QAAQ,CAAC,YAAY;AAC5B,kBAAW,QAAQ,UAAU,UAAU;QAErC,IAAI,kBAAkB;QACtB,IAAI,SAAS,QAAQ;AACrB,eAAO,QAAQ;AACb,aAAI,kBAAkB,OAAO,EAAE;AAC7B,4BAAkB;AAClB;SACD;AACD,kBAAS,OAAO;QACjB;AAED,YAAI,iBAAiB;AACnB,iBAAQ,QAAQ,YAAY,QAAQ,OAAO,OAAO,SAAS,QAAQ,gBAAgB;AACnF;QACD;OACF;MACF,EAAC;KACH;IACF,EAAC;AAGJ,WAAO,KAAK,SAASE,OAAK;GAC3B,EACF,EAAC;AAGJ,OAAI,OACF,qBAAoB,QAAQ;IAC1B,UAAU,MAAM;AAEd,SAAI,KAAK,SAAS,gBAAgB,KAAK,IAAI,SAAS,iBAClD;UAAI,KAAK,IAAI,UAAU,SAAS,eAAe;OAC7C,MAAM,UAAU,KAAK,IAAI,SAAS;AAClC,WAAI;QAAC;QAAS;QAAa;QAAW;OAAa,EAAC,SAAS,QAAQ,EAEnE;YAAI,KAAK,OAAO,SAAS,0BAA0B,KAAK,MAAM,WAC5D,oBAAmB,KAAK,MAAM,WAAW;OAC1C;MAEJ;gBAGM,KAAK,SAAS,qBAAqB,KAAK,UAAU,UACzD;UAAI,KAAK,QAAQ,SAAS,gBACrB,KAAK,OAAO,KAAK,SAAS,iBAC1B;OAAC;OAAS;OAAa;OAAW;MAAa,EAAC,SAAS,KAAK,OAAO,IAAI,KAAK,EAAE;OACnF,MAAM,aAAa,KAAK,MAAM,QAAQ,MAAM,GAAG;OAC/C,MAAM,gBAAgB,YAAY,YAAY,OAAO,SAAS,QAAQ,gBAAgB;AACtF,YAAK,SAAS,GAAG,cAAc;AAC/B;MACD;;IAEJ;IACD,YAAY,CACX;GACF,EAAC;AAGJ,UAAO;EACR;CACF;AACF;AAED,SAAgB,YAAYC,OAAeC,SAAiB,IAAIC,iBAAkC;AAChG,KAAI,oBAAoB,KACtB,QAAO,MACJ,MAAM,IAAI,CACV,IAAI,CAAC,cAAc;EAClB,MAAM,CAAC,SAAS,OAAO,SAAS,GAAG,eAAe,UAAU;AAC5D,MAAI,QACF,QAAO,YACF,EAAE,QAAQ,GAAG,OAAO,EAAE,MAAM,GAAG,SAAS,KACxC,EAAE,QAAQ,GAAG,OAAO,EAAE,MAAM;MAGjC,QAAO,YACF,EAAE,OAAO,EAAE,MAAM,GAAG,SAAS,KAC7B,EAAE,OAAO,EAAE,MAAM;CAEzB,EAAC,CACD,KAAK,IAAI;AAGd,QAAO,MACJ,MAAM,IAAI,CACV,IAAI,eACH,UAAU,SAAS,EAAE,OAAO,GAAG,KAAK,IAChC,aACC,EAAE,OAAO,GAAG,UAAU,MAAM,CAAC,EACnC,CACA,KAAK,IAAI;AACb;;;;AC3RD,MAAa,iBAAiB;CAC5B,QAAQ;EACN,MAAM;EACN,SAAS;EACT,QAAQ;CACT;CACD,OAAO;EACL,MAAM;EACN,SAAS;EACT,QAAQ;CACT;AACF;;;;ACND,MAAM,iBAAiB;AAEvB,SAAgB,eAAeC,MAAqBC,eAAsE;AACxH,QAAO;EACL,MAAM;EACN,MAAM;EAEN,UAAU,EAAE,YAAY,QAAQ,OAAO,EAAE,mBAAmB,qBAAqB,EAAE,EAAE;GACnF,IAAI,iBAAiB;GACrB,MAAM,EAAE,QAAQ,GAAG;AAGnB,QAAK,OAAO,iBAAiB,OAAO,eAAe,gBACjD,QAAO;GAGT,MAAM,gBAAgB;GACtB,MAAM,gBAAgB,OAAO;AAE7B,OAAI,kBAAkB,cACpB,QAAO;GAIT,MAAMC,mBAAwC,IAAI;AAClD,QAAK,MAAM,aAAa,YAAY;AAClC,sBAAkB,WAAW,EAE3B,uBAAuBC,QAAM;AAC3B,UAAK,CAAC,eAAe,MAAM,QAAQ,eAAe,OAAO,MAAO,EAAC,UAAU,EAAEA,OAAK,KAAK,OAAO,MAAM,EAAE,CACpG,QAAO,KAAK,SAASA,OAAK;AAE5B,UAAK,MAAM,aAAaA,OAAK,KAAK,cAAc,CAAE,EAChD,KAAI,UAAU,SAAS,mBAAmB;MACxC,MAAM,WAAW,UAAU,SAAS;MAEpC,MAAM,eAAe,cAAc,YAAY;AAE/C,WAAK,gBAAgB,iBAAiB,IAAI,aAAa,CACrD;AAGF,uBAAiB,IAAI,UAAU,aAAa;AAC5C,gBAAU,SAAS,OAAO;KAC3B;AAGH,SAAI,iBAAiB,OAAO,EAC1B,QAAK,KAAK,OAAO,QAAQ,eAAe,eAA8C;AAExF,YAAO,KAAK,SAASA,OAAK;IAC3B,EACF,EAAC;AAEF,QAAI,OACF,qBAAoB,QAAQ,EAC1B,UAAU,MAAM;AACd,SAAI,KAAK,SAAS,cAAc,iBAAiB,IAAI,KAAK,QAAQ,EAAE;AAClE,WAAK,UAAU,iBAAiB,IAAI,KAAK,QAAQ,IAAI;AACrD;KACD;IACF,EACF,EAAC;GAEL;AAED,UAAO;EACR;CACF;AACF;;;;ACvDD,eAAsBC,YAAUC,MAAqB;CACnD,MAAM,SAAS,MAAM,aAAa,KAAK;CAEvC,MAAM,gBAAgB,MAAM,kBAAkB;AAE9C,QAAO,UAAc,QAAQ,KAAK,UAAU;EAC1C,gBAAgB,KAAK;EACrB,iBAAiB,KAAK;EACtB,MAAM,kBAAkB,KAAK;EAC7B,eAAe,MAAM,cAAc;CACpC,EAAC,CAAC;AACJ;;;;ACXD,eAAsB,YACpBC,SACAC,QACAC,SAOA;AACA,MAAKC,SAAO,OACV,QAAO;EACL,cAAc,CAAE;EAChB,cAAc,CAAE;EAChB,cAAc,CAAE;CACjB;AAEH,WAAU;EACR,WAAW;EACX,OAAO;EACP,QAAQ;EACR,UAAU;EACV,GAAG;CACJ;CACD,MAAM,sBAAsB,SAAS,kBAAkB,EACrD,QAAQ,QAAQ,OACjB,EAAC,EAAE,OAAO;CAEX,MAAM,CAAC,aAAa,UAAU,GAAG,MAAM,QAAQ,IAAI,CACjD,eAAe,OAAO,cAAc,IAAI,EACxC,qBAAqB,OAAO,SAAS,UAAU,AAChD,EAAC;CAEF,IAAIC,eAAyB,CAAE;CAC/B,IAAIC,eAAyB,CAAE;CAC/B,IAAIC,eAAyB,CAAE;CAC/B,MAAM,gBAAgB,IAAI;CAE1B,IAAI,WAAW;AACf,MAAK,OAAO,YAAY;AACtB,OAAK,MAAM,QAAQH,SAAO;AACxB,QAAK,KAAK,QACR;GAEF,MAAM,UAAU,KAAK,QAAQ,KAAK,KAAK;AACvC,cAAW,KAAK,KAAK,QAAQ,EAAE,aAAa;GAG5C,MAAM,UAAU,KAAK,KAAK,UAAU,YAAY,OAAO,OAAO,QAAQ;GACtE,MAAM,WAAW,KAAK,KAAK,UAAU,YAAY,OAAO,OAAO,KAAK,KAAK;AAEzE,SAAM,SAAG,MAAM,SAAS,EAAE,WAAW,KAAM,EAAC;AAC5C,SAAM,SAAG,UAAU,UAAU,KAAK,SAAS,QAAQ;EACpD;AAED,QAAM,SAAG,GAAG,KAAK,KAAK,QAAQ,KAAK,EAAE,eAAe,EAAE,UAAU;GAC9D,WAAW;GACX,QAAQ,UAAQ,IAAI,SAAS,SAAS;EACvC,EAAC;AACF,QAAM,SAAG,UAAU,KAAK,KAAK,UAAU,gBAAgB,GAAG;;;;;;;;;IAS1D,OAAO;CACR;AAED,MAAK,MAAM,QAAQA,SAAO;AACxB,OAAK,KAAK,QACR;EAGF,IAAI,WAAW,gBAAgB,MAAM,QAAQ;GAC3C,WAAW,aAAa,UAAU;GAClC,YAAY,iBACV,QAAM,IAAI,OAAK,EAAE,KAAK,EACtB,KAAK,KACN;EACF,EAAC;AAEF,OAAK,SACH;EAGF,MAAM,WAAW,SAAS,KAAK,KAAK;EACpC,MAAM,YAAY,KAAK,QAAQ,SAAS;AAExC,OAAK,OAAO,WACV,YAAW,SAAS,QAAQ,UAAU,WAAS,MAAM;EAGvD,MAAM,eAAe,WAAW,SAAS;EAGzC,MAAM,UAAU,MAAM,YAAU;GAC9B,UAAU,KAAK,KAAK,UAAU,YAAY,OAAO,OAAO,KAAK,KAAK;GAClE,KAAK,KAAK;GACV;GACA;GACA,UAAU,QAAQ;EACnB,EAAC;AAGF,MAAI,cAAc;GAChB,MAAM,sBAAsB,MAAM,SAAG,SAAS,UAAU,QAAQ;GAChE,MAAM,CAAC,oBAAoB,cAAc,GAAG,MAAM,QAAQ,IAAI,CAC5D,yBAAyB,oBAAoB,EAC7C,yBAAyB,QAAQ,AAClC,EAAC;AACF,OAAI,uBAAuB,eAAe;AACxC,iBAAa,KAAK,KAAK,SAAS,OAAO,cAAc,KAAK,SAAS,CAAC;AACpE;GACD;EACF;AAGD,MAAI,KAAK,SAAS,eAAe;GAC/B,MAAM,aAAa,SAAS,QAAQ,SAAS,CAAC;GAC9C,MAAM,iBAAiB,WAAW,QAAQ,SAAS,CAAC;AAEpD,QAAK,eACH,eAAc,IAAI,YAAY,MAAM;AAGtC,QAAK,cAAc,IAAI,WAAW,KAAK,QAAQ,WAAW;AACxD,wBAAoB,MAAM;IAC1B,MAAM,EAAE,WAAW,GAAG,MAAM,QAAQ;KAClC,MAAM;KACN,MAAM;KACN,UAAU,aAAa,YAAY,KAAK,WAAW,CAAC;KACpD,SAAS;IACV,EAAC;AACF,kBAAc,IAAI,aAAa,UAAU;AACzC,yBAAqB,OAAO;GAC7B;AAED,OAAI,cAAc,IAAI,WAAW,KAAK,MAAM;AAC1C,iBAAa,KAAK,KAAK,SAAS,OAAO,cAAc,KAAK,SAAS,CAAC;AACpE;GACD;EACF,WAEK,iBAAiB,QAAQ,WAAW;AACtC,uBAAoB,MAAM;AAC1B,OAAI,QAAQ,YACV,SAAQ,YAAY,MAAM;GAE5B,MAAM,EAAE,WAAW,GAAG,MAAM,QAAQ;IAClC,MAAM;IACN,MAAM;IACN,UAAU,WAAW,YAAY,KAC/B,SACD,CAAC;IACF,SAAS;GACV,EAAC;AAEF,QAAK,WAAW;AACd,iBAAa,KAAK,KAAK,SAAS,OAAO,cAAc,KAAK,SAAS,CAAC;AACpE,QAAI,QAAQ,YACV,SAAQ,YAAY,OAAO;AAE7B;GACD;AACD,wBAAqB,OAAO;AAC5B,OAAI,QAAQ,YACV,SAAQ,YAAY,OAAO;EAE9B;AAIH,OAAK,WAAW,UAAU,CACxB,OAAM,SAAG,MAAM,WAAW,EAAE,WAAW,KAAM,EAAC;AAGhD,QAAM,SAAG,UAAU,UAAU,SAAS,QAAQ;AAC9C,iBACI,aAAa,KAAK,KAAK,SAAS,OAAO,cAAc,KAAK,SAAS,CAAC,GACpE,aAAa,KAAK,KAAK,SAAS,OAAO,cAAc,KAAK,SAAS,CAAC;CACzE;CAED,MAAM,WAAW;EAAC,GAAG;EAAc,GAAG;EAAc,GAAG;CAAa;CACpE,MAAM,eAAe,MAAM,eAAe,UAAU,OAAO;AAG3D,cAAa,KAAK,GAAG,aAAa;AAGlC,gBAAe,aAAa,OAAO,WAAS,aAAa,SAAS,KAAK,CAAC;CAExE,MAAM,kBAAkB,aAAa,UAAU,aAAa;AAC5D,MAAK,oBAAoB,aAAa,OACpC,sBAAqB,KAAK,oBAAoB;AAIhD,gBAAe,MAAM,KAAK,IAAI,IAAI,cAAc;AAChD,gBAAe,MAAM,KAAK,IAAI,IAAI,cAAc;AAChD,gBAAe,MAAM,KAAK,IAAI,IAAI,cAAc;AAEhD,KAAI,aAAa,QAAQ;AACvB,uBAAqB,SAClB,UAAU,aAAa,OAAO,GAC7B,aAAa,WAAW,IAAI,SAAS,QACtC,GACF;AACD,OAAK,QAAQ,OACX,MAAK,MAAM,QAAQ,aACjB,QAAO,KAAK,MAAM,KAAK,EAAE;CAG9B,MAEC,sBAAqB,MAAM;AAG7B,KAAI,aAAa,QAAQ;AACvB,WACG,UAAU,aAAa,OAAO,GAC7B,aAAa,WAAW,IAAI,SAAS,QACtC,IACD,EACE,QAAQ,QAAQ,OACjB,EACF,EAAE,MAAM;AACT,OAAK,QAAQ,OACX,MAAK,MAAM,QAAQ,aACjB,QAAO,KAAK,MAAM,KAAK,EAAE;CAG9B;AAED,KAAI,aAAa,QAAQ;AACvB,WACG,UAAU,aAAa,OAAO,GAC7B,aAAa,WAAW,IAAI,SAAS,QACtC,6DACD,EACE,QAAQ,QAAQ,OACjB,EACF,EAAE,MAAM;AACT,OAAK,QAAQ,OACX,MAAK,MAAM,QAAQ,aACjB,QAAO,KAAK,MAAM,KAAK,EAAE;CAG9B;AAED,MAAK,QAAQ,OACX,QAAO,OAAO;AAGhB,QAAO;EACL;EACA;EACA;CACD;AACF;AAED,SAAgB,gBACdI,MACAN,QACAO,SAIA;AACA,KAAI,KAAK,QAAQ;AACf,MAAI,KAAK,OAAO,WAAW,KAAK,CAC9B,QAAO,KAAK,KAAK,OAAO,cAAc,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG,CAAC;EAG3E,IAAI,SAAS,KAAK;AAElB,MAAI,KAAK,SAAS,iBAAiB;AACjC,YAAS,kBAAkB,QAAQ,QAAQ,UAAU;AACrD,QAAK,OACH,QAAO;EAEV;AAED,SAAO,KAAK,KAAK,OAAO,cAAc,KAAK,OAAO,QAAQ,QAAQ,GAAG,CAAC;CACvE;CAED,MAAM,YAAY,2BAA2B,MAAM,OAAO;CAE1D,MAAM,eAAe,sBAAsB,KAAK,MAAM,UAAU;AAChE,QAAO,KAAK,KAAK,WAAW,aAAa;AAC1C;AAED,SAAS,2BACPD,MACAN,QACA;AACA,KAAI,KAAK,SAAS,cAChB,QAAO,OAAO,cAAc;AAG9B,KAAI,KAAK,SAAS,eAChB,QAAO,OAAO,cAAc;AAG9B,KAAI,KAAK,SAAS,oBAAoB,KAAK,SAAS,qBAClD,QAAO,OAAO,cAAc;AAG9B,KAAI,KAAK,SAAS,mBAAmB,KAAK,SAAS,sBACjD,QAAO,OAAO,cAAc;AAG9B,QAAO,OAAO,cAAc;AAC7B;AAED,SAAgBQ,iBAAeC,OAAiBC,QAAwB;CAEtE,MAAM,kBAAkB,MAAM,IAAI,OAAK,EAAE,QAAQ,OAAO,GAAG,CAAC;CAC5D,MAAM,mBAAmB,OAAO,QAAQ,OAAO,GAAG;CAGlD,MAAM,YAAY,iBAAiB,MAAM,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,KAAK,IAAI;AAGpE,MAAK,UACH,QAAO;CAIT,MAAM,iBAAiB,UAAU,MAAM,IAAI;AAG3C,MAAK,IAAI,IAAI,eAAe,QAAQ,IAAI,GAAG,KAAK;EAC9C,MAAM,WAAW,eAAe,MAAM,GAAG,EAAE,CAAC,KAAK,IAAI;EAErD,MAAM,kBAAkB,gBAAgB,KACtC,YAAQC,WAAS,oBAAoB,OAAK,YAAY,EAAE,SAAS,GAAG,CACrE;AACD,MAAI,gBACF,SAAQ,GAAG,SAAS;CAEvB;AAGD,SAAQ,GAAG,UAAU;AACtB;AAED,SAAgB,sBACdC,UACAC,WACQ;CAER,MAAM,qBAAqB,SAAS,QAAQ,YAAY,GAAG;CAC3D,MAAM,sBAAsB,UAAU,QAAQ,YAAY,GAAG;CAG7D,MAAM,eAAe,mBAAmB,MAAM,IAAI;CAClD,MAAM,iBAAiB,oBAAoB,MAAM,IAAI;CAGrD,MAAM,oBAAoB,eAAe,eAAe,SAAS;CACjE,MAAM,iBAAiB,aAAa,UAClC,aAAW,YAAY,kBACxB;AAED,KAAI,mBAAmB,GAErB,QAAO,aAAa,aAAa,SAAS;AAI5C,QAAO,aAAa,MAAM,iBAAiB,EAAE,CAAC,KAAK,IAAI;AACxD;AAED,eAAsB,yBAAyBC,SAAiB;AAC9D,QAAO,QAAQ,QAAQ,SAAS,KAAK,CAAC,MAAM;AAC7C;AAED,SAAgB,kBACdC,QACAC,WACA;AACA,MAAK,UACH,QAAO;AAGT,KAAI,cAAc,OAChB,QAAO;AAGT,KAAI,cAAc,WAAW;EAC3B,IAAI,SAAS,OAAO,QAAQ,UAAU,sBAAsB;AAC5D,WAAS,OAAO,QAAQ,sBAAsB,KAAK;AAEnD,SAAO;CACR;AAED,QAAO;AACR;AAGD,eAAe,eAAeC,WAAqBjB,QAAgB;CACjE,MAAM,cAAc,MAAM,eAAe,OAAO,cAAc,IAAI;CAClE,MAAM,WAAW,MAAM,YAAY,OAAO,cAAc,KAAK,aAAa,aAAa,kBAAkB,gBAAgB;CACzH,MAAM,eAAe,CAAE;AAEvB,MAAK,eAAe,aAAa,KAC/B,QAAO,CAAE;AAGX,MAAK,MAAM,YAAY,WAAW;EAChC,MAAM,eAAe,KAAK,QAAQ,OAAO,cAAc,KAAK,SAAS;AAGrE,OAAK,WAAW,aAAa,CAC3B;EAGF,MAAM,UAAU,MAAM,SAAG,SAAS,cAAc,QAAQ;AAExD,MAAI;GAEF,MAAM,4BAA4B,CAACkB,UAAe;IAChD,MAAM;IACN,UAAUC,MAAW;AAEnB,SAAI,KAAK,SAAS,uBAAuB,KAAK,QAAQ,OAAO;MAC3D,MAAM,kBAAkB,KAAK,OAAO;AAGpC,UACE,aAAa,gBACT,gBAAgB,YAAY,EAAE,YAAY,YAAY,GAAG,CAE7D;MAIF,MAAM,yBAAyB,kBAAkB,iBAAiB,SAAS;AAE3E,WAAK,uBACH;MAIF,MAAM,yBAAyB,4BAC7B,wBACA,WACA,OACD;AAED,WAAK,uBACH;MAIF,MAAM,YAAY,gBAChB,wBACA,QACA,YACD;AAED,WAAK,aAAa,cAAc,gBAC9B;AAIF,WAAK,OAAO,QAAQ;AACpB,WAAK,OAAO,OAAO,GAAG,UAAU;KACjC;IACF;GACF;GAGD,MAAM,SAAS,UAAc,SAAS,cAAc,CAElD,0BAA0B,CAAE,EAAC,AAC9B,EAAC;AAGF,OAAI,OAAO,SAAS,SAAS;AAC3B,UAAM,SAAG,UAAU,cAAc,OAAO,MAAM,QAAQ;AACtD,iBAAa,KAAK,SAAS;GAC5B;EACF,SACM,OAAO;AACZ,WAAQ,MAAM,iCAAiC,SAAS,IAAI,MAAM;EACnE;CACF;AAED,QAAO;AACR;AAGD,SAAS,kBAAkBC,iBAAyBC,UAA8B;AAChF,MAAK,UAAU,iBAAiB,MAC9B,QAAO;CAGT,MAAM,EAAE,UAAU,IAAI,OAAO,GAAG,SAAS;AAGzC,MAAK,MAAM,CAAC,OAAO,SAAS,IAAI,OAAO,QAAQ,MAAM,CACnD,YAAW,UAAU,YAAY,MAAM,QAAQ,SAAS,EAAE;EACxD,MAAM,eAAe,MAAM,QAAQ,MAAM,GAAG;AAC5C,MAAI,gBAAgB,WAAW,aAAa,EAAE;GAC5C,MAAM,eAAe,gBAAgB,QAAQ,cAAc,GAAG;GAC9D,MAAM,WAAW,SAAS,IAAI,QAAQ,MAAM,GAAG,IAAI;AACnD,UAAO,KAAK,QAAQ,SAAS,UAAU,aAAa;EACrD;CACF;AAGH,QAAO;AACR;;;;;;AAOD,SAAgB,4BACdC,wBACAC,SACAvB,QACAwB,aAAuB;CAAC;CAAQ;CAAO;CAAO;AAAO,GACrD;CACA,MAAM,MAAM,KAAK,UAAU,OAAO,cAAc,IAAI;CAGpD,MAAM,gBAAgB,QAAM,IAAI,OAAK,EAAE,MAAM,KAAK,IAAI,CAAC,KAAK,KAAK,MAAM,IAAI,CAAC;CAC5E,MAAM,UAAU,IAAI,IAAI;CAGxB,MAAM,YAAY,KAAK,QAAQ,uBAAuB;CACtD,MAAM,SAAS,cAAc;CAC7B,MAAM,UAAU,SACZ,uBAAuB,MAAM,IAAI,UAAU,OAAO,GAClD;CAGJ,MAAM,aAAa,KAAK,SAAS,KAAK,QAAQ;CAC9C,MAAM,UAAU,WAAW,MAAM,KAAK,IAAI,CAAC,KAAK,KAAK,MAAM,IAAI;CAG/D,MAAM,UAAU,SAAS,CAAC,SAAU,IAAG;CAGvC,MAAM,aAAa,IAAI;AAGvB,MAAK,MAAM,KAAK,SAAS;EACvB,MAAM,UAAU,UAAU;EAC1B,MAAM,UAAU,KAAK,MAAM,UAAU,KAAK,SAAS,KAAK,QAAQ,CAAC;AACjE,MAAI,QAAQ,IAAI,QAAQ,IAAI,WAAW,QAAQ,CAC7C,YAAW,IAAI,QAAQ;EAGzB,MAAM,SAAS,KAAK,KAAK,UAAU,OAAO,EAAE,EAAE;EAC9C,MAAM,SAAS,KAAK,MAAM,UAAU,KAAK,SAAS,KAAK,OAAO,CAAC;AAC/D,MAAI,QAAQ,IAAI,OAAO,IAAI,WAAW,OAAO,CAC3C,YAAW,IAAI,OAAO;CAEzB;CAGD,MAAMC,SAAO,KAAK,SAAS,QAAQ;AACnC,MAAK,MAAM,KAAK,cACd,KAAI,QAAQ,KAAK,OAAK,EAAE,UAAU,GAAGA,OAAK,EAAE,EAAE,EAAE,CAAC,CAC/C,YAAW,IAAI,EAAE;AAKrB,KAAI,WAAW,SAAS,EACtB,QAAO;CAGT,MAAM,SAAS,MAAM,KAAK,WAAW,CAAC,KAAK,CAAC,GAAG,MAAM;EAEnD,MAAM,OAAO,KAAK,MAAM,QAAQ,EAAE;EAClC,MAAM,OAAO,KAAK,MAAM,QAAQ,EAAE;EAClC,MAAM,MAAM,QAAQ,QAAQ,KAAK,GAAG,QAAQ,QAAQ,KAAK;AACzD,MAAI,QAAQ,EACV,QAAO;EAET,MAAM,UAAU,WAAW,EAAE,WAAW,QAAQ,GAAG,KAAK;EACxD,MAAM,UAAU,WAAW,EAAE,WAAW,QAAQ,GAAG,KAAK;AACxD,SAAO,UAAU;CAClB,EAAC;AAGF,QAAO,OAAO;AACf;AAED,SAAgB,gBACdb,UACAZ,QACA0B,aACe;CACf,MAAM,MAAM,KAAK,UAAU,KAAK,KAAK,OAAO,cAAc,KAAK,SAAS,CAAC;CAIzE,MAAM,UAAU,OAAO,QAAQ,OAAO,cAAc,CACjD,OACC,CAAC,GAAG,KAAK,KAAK,QAAQ,IAAI,WAAW,KAAK,UAAU,OAAO,KAAK,IAAI,CAAC,CACtE,CACA,KAAK,CAAC,GAAG,MAAM,EAAE,GAAG,SAAS,EAAE,GAAG,OAAO;AAE5C,KAAI,QAAQ,WAAW,EACrB,QAAO;CAET,MAAM,CAAC,UAAU,QAAQ,GAAG,QAAQ;CAGpC,IAAI,MAAM,KAAK,SAAS,SAAS,IAAI;AAErC,OAAM,IAAI,MAAM,KAAK,IAAI,CAAC,KAAK,IAAI;CAGnC,MAAM,MAAM,KAAK,MAAM,QAAQ,IAAI;CACnC,MAAM,WAAW;EAAC;EAAO;EAAQ;CAAM;CACvC,MAAM,UAAU,SAAS,SAAS,IAAI,GAAG,KAAK;CAC9C,IAAI,QAAQ,IAAI,MAAM,GAAG,IAAI,SAAS,IAAI,OAAO;AAGjD,KAAI,MAAM,SAAS,SAAS,CAC1B,SAAQ,MAAM,MAAM,GAAG,GAAiB;CAK1C,MAAM,YACF,aAAa,QACX,YAAY,cACZ,OAAO,QAAQ;AACrB,MAAK,UACH,QAAO;CAGT,IAAI,SAAS,UAAU,KAAK,MAAM,GAAG,MAAM;AAI3C,UAAS,OAAO,QAAQ,QAAQ,GAAG;AAInC,SAAQ,EAAE,UAAU,EAAE,OAAO,EAAE,QAAQ;AACxC;;;;AC9oBD,eAAsB,cACpBC,YACAC,QACAC,SAMA;AACA,WAAU;EACR,WAAW;EACX,QAAQ;EACR,cAAc;EACd,OAAO;EACP,GAAG;CACJ;CAED,MAAM,kBAAkB,MAAM,mBAAmB,OAAO;AACxD,KACE,mBACG,gBAAgB,MAChB,gBAAgB,GAAG,cAAc,QAAQ,OAAO,cAAc,IAEjE,QAAO,MAAM,uBAAuB,YAAY,QAAQ,iBAAiB;EACvE,GAAG;EACH,UACE,YAAY,WAAW,OAAO,WAAW,GAAG,MAAM,cAAc;CACnE,EAAC;AAGJ,QAAO,MAAM,qBAAqB,YAAY,QAAQ,QAAQ;AAC/D;AAED,eAAe,qBACbF,YACAG,QACAD,SAMA;CACA,MAAM,kBAAkB,SAAS,qBAAqB,EACpD,QAAQ,QAAQ,OACjB,EAAC,EAAE,OAAO;CACX,MAAM,OAAO,MAAM,yBAAyB,YAAY,OAAO;AAC/D,MAAK,MAAM;AACT,mBAAiB,MAAM;AACvB,SAAO,YAAY,IAAI,MAAM,6CAA6C;CAC3E;AACD,kBAAiB,SAAS;CAE1B,MAAM,kBAAkB,MAAM,oCAAoC,OAAO;AAEzE,OAAM,qBAAqB,KAAK,UAAU,QAAQ,QAAQ;EACxD,QAAQ,QAAQ;EAChB;CACD,EAAC;CAEF,MAAM,mBAAmB,MAAM,uBAAuB,YAAY,OAAO;AACzE,OAAM,cAAc,KAAK,SAAS,QAAQ;EACxC,0BAA0B,QAAQ;EAClC,QAAQ,QAAQ;EAChB;EACA,gBAAgB,KAAK,UAAU;EAC/B;EACA,WAAW,QAAQ,QAAQ,QAAQ,UAAU,UAAU;CACxD,EAAC;AAGF,OAAM,UAAU,KAAK,KAAK,QAAQ,EAChC,QAAQ,QAAQ,OACjB,EAAC;AAEF,OAAM,mBAAmB,KAAK,cAAc,QAAQ,EAClD,QAAQ,QAAQ,OACjB,EAAC;AACF,OAAM,YAAY,KAAK,OAAO,QAAQ;EACpC,WAAW,QAAQ;EACnB,QAAQ,QAAQ;CACjB,EAAC;AAEF,KAAI,KAAK,KACP,QAAO,KAAK,KAAK,KAAK;AAEzB;AAED,eAAe,uBACbF,YACAG,QACAC,iBACAC,SAOA;CACA,MAAM,kBAAkB,SAAS,qBAAqB,EACpD,QAAQ,QAAQ,OACjB,EAAC,EAAE,OAAO;CACX,IAAI,gBAAgB,MAAM,qBAAqB,YAAY,OAAO;CAClE,IAAI,SAAS,MAAM,cAAc,cAAc;CAC/C,MAAM,UAAU,EAAE,MAAM,mBAAmB,CAAC,MAAM,OAAO;AACzD,MAAK,SAAS;AACZ,mBAAiB,MAAM;AACvB,SAAO,YAAY,IAAI,MAAM,6CAA6C;CAC3E;AACD,kBAAiB,SAAS;CAE1B,MAAM,oBAAoB,qBAAqB,QAAQ;CACvD,MAAM,uBAAuB,yBAAyB;CAEtD,MAAMC,eAAyB,CAAE;CACjC,MAAMC,eAAyB,CAAE;CACjC,MAAMC,eAAyB,CAAE;CAEjC,MAAM,cAAc,SAAS,wBAAwB,EAAE,OAAO;AAE9D,MAAK,MAAM,aAAa,SAAS;EAC/B,MAAM,QAAQ,qBAAqB,IAAI,UAAU,KAAK;EACtD,MAAM,iBAAiB,kBAAkB,IAAI,UAAU,KAAK;AAG5D,OAAK,MACH;EAKF,IAAI,eACA,UAAU,SAAS,iBAAiB,gBAAgB,SAAS,gBAC3D,gBAAgB,KAChB;EAEN,MAAM,kBAAkB,MAAM,oCAC5B,aACD;EAED,MAAM,gBAAgB,eACpB,OAAO,cAAc,KACrB,aAAa,cAAc,GAC5B;EACD,MAAM,cACD,MAAM,gBAAgB,eAAe,aAAa,cAAc,IAAI,IAClE,aAAa,cAAc;AAGlC,MAAI,UAAU,UAAU,QAAQ;AAC9B,SAAM,qBAAqB,UAAU,UAAU,QAAQ,cAAc;IACnE,QAAQ;IACR;GACD,EAAC;AACF,gBAAa,KACX,KAAK,SAAS,eAAe,aAAa,cAAc,eAAe,CACxE;EACF;AAGD,MAAI,UAAU,SAAS;GACrB,MAAM,mBAAmB,MAAM,uBAAuB,YAAY,OAAO;AACzE,SAAM,cAAc,UAAU,SAAS,cAAc;IACnD,QAAQ;IACR;IACA,gBAAgB,UAAU,UAAU;IACpC;GACD,EAAC;AACF,gBAAa,KACX,KAAK,SAAS,eAAe,aAAa,cAAc,YAAY,CACrE;EACF;AAGD,MAAI,UAAU,KAAK;AACjB,SAAM,UAAU,UAAU,KAAK,cAAc,EAC3C,QAAQ,KACT,EAAC;AACF,gBAAa,KACX,KAAK,SAAS,eAAe,aAAa,cAAc,YAAY,CACrE;EACF;AAGD,QAAM,QAAQ,WAAW,CACvB,UAAU,gBAAgB,UAAU,aAAa,SAC7C,mBACE,UAAU,cACV,cACA,EAAE,QAAQ,KAAM,EACjB,GACD,QAAQ,SAAS,EACrB,UAAU,mBAAmB,UAAU,gBAAgB,SACnD,mBACE,UAAU,iBACV,cACA;GAAE,QAAQ;GAAM,KAAK;EAAM,EAC5B,GACD,QAAQ,SAAS,AACtB,EAAC;EAGF,MAAMC,UAAQ,MAAM,YAAY,UAAU,OAAO,cAAc;GAC7D,WAAW,QAAQ;GACnB,QAAQ;GACR;GACA,UAAU,QAAQ;EACnB,EAAC;AAEF,eAAa,KACX,GAAG,QAAM,aAAa,IAAI,UACxB,KAAK,SAAS,eAAe,KAAK,KAAK,aAAa,KAAK,CAAC,CAC3D,CACF;AACD,eAAa,KACX,GAAG,QAAM,aAAa,IAAI,UACxB,KAAK,SAAS,eAAe,KAAK,KAAK,aAAa,KAAK,CAAC,CAC3D,CACF;AACD,eAAa,KACX,GAAG,QAAM,aAAa,IAAI,UACxB,KAAK,SAAS,eAAe,KAAK,KAAK,aAAa,KAAK,CAAC,CAC3D,CACF;CACF;AAED,cAAa,SAAS;AAGtB,cAAa,MAAM;AACnB,cAAa,MAAM;AACnB,cAAa,MAAM;CAEnB,MAAM,kBAAkB,aAAa,UAAU,aAAa;AAC5D,MAAK,oBAAoB,aAAa,OACpC,UAAS,oBAAoB,EAC3B,QAAQ,QAAQ,OACjB,EAAC,EAAE,MAAM;AAGZ,KAAI,aAAa,QAAQ;AACvB,WACG,UAAU,aAAa,OAAO,GAC7B,aAAa,WAAW,IAAI,SAAS,QACtC,IACD,EACE,QAAQ,QAAQ,OACjB,EACF,EAAE,SAAS;AACZ,OAAK,MAAM,QAAQ,aACjB,QAAO,KAAK,MAAM,KAAK,EAAE;CAE5B;AAED,KAAI,aAAa,QAAQ;AACvB,WACG,UAAU,aAAa,OAAO,GAC7B,aAAa,WAAW,IAAI,SAAS,QACtC,IACD,EACE,QAAQ,QAAQ,OACjB,EACF,EAAE,MAAM;AACT,OAAK,MAAM,QAAQ,aACjB,QAAO,KAAK,MAAM,KAAK,EAAE;CAE5B;AAED,KAAI,aAAa,QAAQ;AACvB,WACG,UAAU,aAAa,OAAO,GAC7B,aAAa,WAAW,IAAI,SAAS,QACtC,mCACD,EACE,QAAQ,QAAQ,OACjB,EACF,EAAE,MAAM;AACT,OAAK,MAAM,QAAQ,aACjB,QAAO,KAAK,MAAM,KAAK,EAAE;CAE5B;AACF;AAED,eAAe,uBACbC,YACAP,QACA;CACA,MAAM,gBAAgB,MAAM,qBAAqB,YAAY,OAAO;CACpE,MAAM,SAAS,MAAM,cAAc,cAAc;CACjD,MAAM,UAAU,EAAE,MAAM,mBAAmB,CAAC,MAAM,OAAO;AAEzD,QAAO,QAAQ,KACb,eACE,UAAU,SAAS,oBAAoB,UAAU,SAAS,iBAC7D;AACF;;;;AC/SD,eAAsB,sBACpBQ,SACAC,QACAC,SAGA;AACA,MAAK,QACH;AAGF,WAAU;EACR,QAAQ;EACR,GAAG;CACJ;CAED,MAAM,2BAA2B,KAAK,SACpC,OAAO,cAAc,KACrB,OAAO,cAAc,eACtB;CACD,MAAM,kBAAkB,SACrB,WAAW,YAAY,KAAK,yBAAyB,CAAC,GACvD,EACE,QAAQ,QAAQ,OACjB,EACF,CAAC,OAAO;CACT,MAAM,MAAM,MAAM,SAAG,SAAS,OAAO,cAAc,gBAAgB,OAAO;CAC1E,MAAM,SAAS,MAAM,yBAAyB,KAAK,SAAS,OAAO;AACnE,OAAM,SAAG,UAAU,OAAO,cAAc,gBAAgB,QAAQ,OAAO;AACvE,kBAAiB,SAAS;AAC3B;AAED,eAAsB,yBACpBC,OACAH,SACAC,QACA;CACA,MAAM,aAAa,MAAM,kBAAkB,OAAO,OAAO;CAIzD,MAAM,eAAe,WAClB,qBAAqB,WAAW,wBAAwB,CACxD,KAAK,UACJ,KACG,eAAe,CACf,KACC,cACE,SAAS,OAAO,WAAW,mBAAmB,IAC3C,SAAS,SAAS,KAAK,UAC7B,CACJ;AAGH,MAAK,aACH,QAAO;AAGT,0BAAyB,cAAc,QAAQ;AAE/C,QAAO,WAAW,aAAa;AAChC;AAED,eAAe,yBACbG,cACAJ,SACA;CACA,MAAM,YAAY,cAAc,aAAa;CAE7C,MAAM,mBAAmB,aAAa,YAAY,UAAU;AAE5D,MAAK,kBAAkB;EACrB,MAAM,cAAc;GAClB,MAAM;GACN,cAAc,GAAG,UAAU,EAAE,QAAQ,MAClC,EAAE,UAAU,IAAI,UAAU,EAC5B,CAAC,EAAE,UAAU;EACf;AACD,eAAa,sBAAsB,YAAY;AAE/C,SAAO;CACR;AAED,KAAI,iBAAiB,OAAO,WAAW,mBAAmB,EAAE;EAC1D,MAAM,cAAc,iBAAiB,gBAAgB;AAGrD,MAAI,aAAa,OAAO,WAAW,uBAAuB,CACxD,MAAK,MAAM,eAAe,SAAS;GACjC,MAAM,YAAY,EAAE,UAAU,EAAE,YAAY,EAAE,UAAU;AAGxD,OACE,YACG,aAAa,CACb,IAAI,aAAW,QAAQ,SAAS,CAAC,CACjC,SAAS,SAAS,CAErB;AAGF,eAAY,WAAW,SAAS;EACjC;AAGH,SAAO;CACR;AAED,QAAO;AACR;;;;AC/FD,MAAa,oBAAoB,EAAE,OAAO;CACxC,KAAK,EAAE,QAAQ;CACf,YAAY,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,UAAU;CAC1C,KAAK,EAAE,SAAS;CAChB,UAAU,EAAE,SAAS;CACrB,OAAO,EAAE,SAAS;CAClB,QAAQ,EAAE,SAAS;CACnB,cAAc,EAAE,SAAS;CACzB,QAAQ,EAAE,SAAS,CAAC,UAAU;CAC9B,cAAc,EAAE,SAAS;CAazB,WAAW,EACR,QAAQ,CACR,UAAU,CACV,OACC,CAAC,QAAQ;AACP,MAAI,IACF,QAAO,YAAY,KAAK,WAAS,MAAM,SAAS,IAAI;AAGtD,SAAO;CACR,GACD,EACE,UAAU,kCAAkC,YAAY,IACtD,WAAS,MAAM,KAChB,CAAC,KAAK,OAAS,CAAC,GAClB,EACF;CACH,OAAO,EAAE,QAAQ;AAClB,EAAC;AAEF,MAAa,OAAO,IAAI,UACrB,KAAK,OAAO,CACZ,YAAY,mDAAmD,CAC/D,SACC,mBACA,mDACD,CACA,OAAO,aAAa,6BAA6B,KAAK,CACtD,OAAO,mBAAmB,8BAA8B,MAAM,CAC9D,OAAO,eAAe,8CAA8C,MAAM,CAC1E,OACC,mBACA,6DACA,QAAQ,KAAK,CACd,CACA,OAAO,gBAAgB,gBAAgB,MAAM,CAM7C,OAAO,mBAAmB,kCAAkC,KAAK,CACjE,OAAO,sBAAsB,wCAAwC,CACrE,OAAO,OAAO,YAAY,SAAS;AAClC,KAAI;EACF,MAAM,UAAU,kBAAkB,MAAM;GACtC,KAAK,KAAK,QAAQ,KAAK,IAAI;GAC3B,cAAc;GACd;GACA,OAAO;GACP,GAAG;EACJ,EAAC;AAKF,MAAI,WAAW,SAAS,KAAK,MAAM,WAAW,GAAG,EAAE;GACjD,MAAM,OAAO,MAAM,gBAAgB,WAAW,IAAI,GAAG;AAIrD,OAAI,MAAM,SAAS,kBAAkB;AACnC,YAAQ,YAAY;AACpB,YAAQ,QAAQ,KAAK,WAAW;GACjC;EACF;AAED,QAAM,QAAQ,QAAQ;AAEtB,SAAO,KACJ,EAAE,YAAY,QACb,WACD,CAAC,iEACH;AACD,SAAO,OAAO;CACf,SACM,OAAO;AACZ,SAAO,OAAO;AACd,cAAY,MAAM;CACnB;AACF,EAAC;AAEJ,eAAsB,QACpBK,SAGA;CACA,IAAI;AACJ,MAAK,QAAQ,eAAe;EAC1B,MAAM,YAAY,MAAM,cAAc,QAAQ;AAC9C,MAAI,UAAU,qCACZ,SAAQ,KAAK,EAAE;AAUjB,gBAAc,UAAU;CACzB,MAEC,eAAc,MAAM,eAAe,QAAQ,IAAI;CAGjD,MAAM,gBAAgB,MAAM,iBAAiB,QAAQ,KAAK,YAAY;CACtE,MAAM,SAAS,gBACX,MAAM,uBAAuB,eAAe,QAAQ,GACpD,MAAM,gBAAgB,MAAM,UAAU,QAAQ,IAAI,CAAC;AAEvD,MAAK,QAAQ,KAAK;EAChB,MAAM,EAAE,SAAS,GAAG,MAAM,QAAQ;GAChC,MAAM;GACN,MAAM;GACN,UAAU,yBAAyB,YAAY,KAC7C,kBACD,CAAC;GACF,SAAS;EACV,EAAC;AAEF,OAAK,QACH,SAAQ,KAAK,EAAE;CAElB;CAGD,MAAM,mBAAmB,SAAS,0BAA0B,CAAC,OAAO;CACpE,MAAM,aAAa,KAAK,QAAQ,QAAQ,KAAK,kBAAkB;AAC/D,OAAM,SAAG,UAAU,YAAY,KAAK,UAAU,QAAQ,MAAM,EAAE,EAAE,OAAO;AACvE,kBAAiB,SAAS;CAG1B,MAAM,aAAa,MAAM,mBAAmB,QAAQ,KAAK,OAAO;CAChE,MAAM,aAAa,CACjB,GAAI,QAAQ,UAAU,SAAS,CAAE,IAAG,CAAC,QAAQ,KAAM,GACnD,GAAI,QAAQ,cAAc,CAAE,CAC7B;AACD,OAAM,cAAc,YAAY,YAAY;EAE1C,WAAW;EACX,QAAQ,QAAQ;EAChB,OAAO,QAAQ;EACf,cACE,QAAQ,gBAAgB,aAAa,UAAU,SAAS;CAC3D,EAAC;AAIF,KAAI,QAAQ,gBAAgB,QAAQ,OAClC,OAAM,sBACJ,CAAC,gCAAiC,GAClC,YACA,EACE,QAAQ,QAAQ,OACjB,EACF;AAGH,QAAO;AACR;AAED,eAAe,gBAAgBC,gBAA+B,MAAM;CAClE,MAAM,CAAC,QAAQ,WAAW,GAAG,MAAM,QAAQ,IAAI,CAC7C,mBAAmB,EACnB,uBAAuB,AACxB,EAAC;AAEF,QAAO,KAAK,GAAG;CACf,MAAM,UAAU,MAAM,QAAQ;EAC5B;GACE,MAAM;GACN,MAAM;GACN,UAAU,wBAAwB,YAAY,KAC5C,aACD,CAAC;GACF,SAAS,eAAe,cAAc;GACtC,QAAQ;GACR,UAAU;EACX;EACD;GACE,MAAM;GACN,MAAM;GACN,UAAU,QAAQ,YAAY,KAAK,QAAQ,CAAC;GAC5C,SAAS,OAAO,IAAI,YAAU;IAC5B,OAAO,MAAM,SAAS,aAAa,2BAA2B,MAAM;IACpE,OAAO,MAAM;GACd,GAAE;EACJ;EACD;GACE,MAAM;GACN,MAAM;GACN,UAAU,2CAA2C,YAAY,KAC/D,aACD,CAAC;GACF,SAAS,WAAW,IAAI,YAAU;IAChC,OAAO,MAAM;IACb,OAAO,MAAM;GACd,GAAE;EACJ;EACD;GACE,MAAM;GACN,MAAM;GACN,UAAU,gBAAgB,YAAY,KAAK,aAAa,CAAC;GACzD,SAAS,eAAe,SAAS,OAAO;EACzC;EACD;GACE,MAAM;GACN,MAAM;GACN,UAAU,wBAAwB,YAAY,KAC5C,gBACD,CAAC;GACF,SAAS,eAAe,SAAS,gBAAgB;GACjD,QAAQ;GACR,UAAU;EACX;EACD;GACE,MAAM;GACN,MAAM;GACN,UAAU,yBAAyB,YAAY,KAC7C,0BACD,CAAC;GACF,SAAS;EACV;EACD;GACE,MAAM;GACN,MAAM;GACN,UAAU,gBAAgB,YAAY,KACpC,qBACD,CAAC;GACF,SAAS,eAAe,SAAS,UAAU;EAC5C;EACD;GACE,MAAM;GACN,MAAM;GACN,UAAU,iCAAiC,YAAY,KACrD,aACD,CAAC;GACF,SAAS,eAAe,QAAQ,cAAc;EAC/C;EACD;GACE,MAAM;GACN,MAAM;GACN,UAAU,iCAAiC,YAAY,KAAK,QAAQ,CAAC;GACrE,SAAS,eAAe,QAAQ,SAAS;EAC1C;CACF,EAAC;AAEF,QAAO,gBAAgB,MAAM;EAC3B,SAAS;EACT,OAAO,QAAQ;EACf,UAAU;GACR,QAAQ,QAAQ;GAChB,KAAK,QAAQ;GACb,WAAW,QAAQ;GACnB,cAAc,QAAQ;GACtB,QAAQ,QAAQ;EACjB;EACD,YAAY,QAAQ;EACpB,SAAS;GACP,OAAO,QAAQ;GACf,YAAY,QAAQ;GAEpB,KAAK,QAAQ,WAAW,QAAQ,iBAAiB,OAAO;GACxD,aAAa,QAAQ,WAAW,QAAQ,iBAAiB,eAAe;EACzE;CACF,EAAC;AACH;AAED,eAAe,uBACbC,eACAC,MACA;CACA,IAAI,QAAQ,cAAc;CAC1B,IAAI,YAAY,cAAc,SAAS;CACvC,IAAI,eAAe,cAAc,SAAS;AAE1C,MAAK,KAAK,UAAU;EAClB,MAAM,CAAC,QAAQ,YAAY,gBAAgB,GAAG,MAAM,QAAQ,IAAI;GAC9D,mBAAmB;GACnB,uBAAuB;GACvB,oCAAoC,cAAc;EACnD,EAAC;EAEF,MAAM,UAAU,MAAM,QAAQ,CAC5B;GACE,MAAM,oBAAoB,OAAO,OAAO;GACxC,MAAM;GACN,UAAU,QAAQ,YAAY,KAAK,QAAQ,CAAC;GAC5C,SAAS,OAAO,IAAI,cAAU;IAC5B,OAAOC,QAAM,SAAS,aAAa,2BAA2BA,QAAM;IACpE,OAAOA,QAAM;GACd,GAAE;GACH,SAAS;EACV,GACD;GACE,MAAM,KAAK,YAAY,OAAO;GAC9B,MAAM;GACN,UAAU,2CAA2C,YAAY,KAC/D,aACD,CAAC;GACF,SAAS,WAAW,IAAI,YAAU;IAChC,OAAO,MAAM;IACb,OAAO,MAAM;GACd,GAAE;EACJ,CACF,EAAC;AAEF,UAAQ,QAAQ,SAAS;AACzB,cAAY,QAAQ,qBAAqB;AACzC,iBAAe,KAAK;CACrB;AAED,QAAO,gBAAgB,MAAM;EAC3B,SAAS,eAAe;EACxB;EACA,UAAU;GACR,GAAG,eAAe;GAClB;GACA;EACD;EACD,YAAY,cAAc;EAC1B,SAAS,eAAe;EACxB,aAAa,eAAe;CAC7B,EAAC;AACH;;;;AC7WD,eAAsB,aAAaC,SAA2C;CAC5E,MAAMC,SAAkC,CAAE;AAI1C,MACG,GAAG,WAAW,QAAQ,IAAI,KACvB,GAAG,WAAW,KAAK,QAAQ,QAAQ,KAAK,eAAe,CAAC,EAC5D;AACA,yCAA8C;AAC9C,SAAO;GACL;GACA,QAAQ;EACT;CACF;AAGD,MAAK,GAAG,WAAW,KAAK,QAAQ,QAAQ,KAAK,kBAAkB,CAAC,EAAE;AAChE,2BAAgC;AAChC,SAAO;GACL;GACA,QAAQ;EACT;CACF;AAED,KAAI;EACF,MAAM,SAAS,MAAM,UAAU,QAAQ,IAAI;AAE3C,SAAO;GACL;GACQ;EACT;CACF,SACM,OAAO;AACZ,SAAO,OAAO;AACd,SAAO,OACJ,aAAa,YAAY,KACxB,kBACD,CAAC,qBAAqB,YAAY,KACjC,QAAQ,IACT,CAAC,4DAA4D,YAAY,KACxE,kBACD,CAAC,uBAAuB,YAAY,KAAK,OAAO,CAAC,WACnD;AACD,SAAO,OACJ,gBAAgB,YAAY,KAC3B,8CACD,CAAC,GACH;AACD,SAAO,OAAO;AACd,UAAQ,KAAK,EAAE;CAChB;AACF;;;;AC9CD,MAAM,wBAAwB,CAC5B;CACE,MAAM;CACN,cAAc;CACd,SACE;AACH,GACD;CACE,MAAM;CACN,cAAc;CACd,SACE;AACH,CACF;AAED,MAAa,mBAAmB,EAAE,OAAO;CACvC,YAAY,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,UAAU;CAC1C,KAAK,EAAE,SAAS;CAChB,WAAW,EAAE,SAAS;CACtB,KAAK,EAAE,QAAQ;CACf,KAAK,EAAE,SAAS;CAChB,MAAM,EAAE,QAAQ,CAAC,UAAU;CAC3B,QAAQ,EAAE,SAAS;CACnB,QAAQ,EAAE,SAAS,CAAC,UAAU;CAC9B,cAAc,EAAE,SAAS;AAC1B,EAAC;AAEF,MAAa,MAAM,IAAI,UACpB,KAAK,MAAM,CACX,YAAY,kCAAkC,CAC9C,SACC,mBACA,mDACD,CACA,OAAO,aAAa,6BAA6B,MAAM,CACvD,OAAO,mBAAmB,6BAA6B,MAAM,CAC7D,OACC,mBACA,6DACA,QAAQ,KAAK,CACd,CACA,OAAO,aAAa,gCAAgC,MAAM,CAC1D,OAAO,qBAAqB,oCAAoC,CAChE,OAAO,gBAAgB,gBAAgB,MAAM,CAU7C,OAAO,mBAAmB,kCAAkC,KAAK,CACjE,OAAO,sBAAsB,wCAAwC,CACrE,OAAO,OAAO,YAAY,SAAS;AAClC,KAAI;EACF,MAAM,UAAU,iBAAiB,MAAM;GACrC;GACA,KAAK,KAAK,QAAQ,KAAK,IAAI;GAC3B,GAAG;EACJ,EAAC;EAEF,IAAIC;AAEJ,MAAI,WAAW,SAAS,KAAK,MAAM,WAAW,GAAG,EAAE;GACjD,MAAM,OAAO,MAAM,gBAAgB,WAAW,IAAI,GAAG;AACrD,cAAW,MAAM;EAClB;AAED,OACG,QAAQ,QACL,aAAa,oBAAoB,aAAa,mBAClD;AACA,UAAO,OAAO;GACd,MAAM,EAAE,SAAS,GAAG,MAAM,QAAQ;IAChC,MAAM;IACN,MAAM;IACN,SAAS,YAAY,MAClB,iCAAiC,SAAS,QACzC,aACA,GACD,CAAC,0EACH;GACF,EAAC;AACF,QAAK,SAAS;AACZ,WAAO,OAAO;AACd,WAAO,KAAK,yBAAyB;AACrC,WAAO,OAAO;AACd,YAAQ,KAAK,EAAE;GAChB;EACF;AAED,OAAK,QAAQ,YAAY,OACvB,SAAQ,aAAa,MAAM,4BAA4B,QAAQ;EAGjE,MAAM,cAAc,MAAM,eAAe,QAAQ,IAAI;AACrD,MAAI,aAAa,oBAAoB,MAAM;GACzC,MAAM,uBAAuB,sBAAsB,OAAO,eACxD,QAAQ,YAAY,SAAS,UAAU,KAAK,CAC7C;AAED,OAAI,sBAAsB,QAAQ;AAChC,WAAO,OAAO;AACd,yBAAqB,QAAQ,CAAC,cAAc;AAC1C,YAAO,KAAK,YAAY,KAAK,UAAU,QAAQ,CAAC;IACjD,EAAC;AACF,WAAO,OAAO;AACd,YAAQ,KAAK,EAAE;GAChB;EACF;EAED,IAAI,EAAE,QAAQ,QAAQ,GAAG,MAAM,aAAa,QAAQ;AAGpD,MAAI,wBAA+B;GACjC,MAAM,EAAE,SAAS,GAAG,MAAM,QAAQ;IAChC,MAAM;IACN,MAAM;IACN,UAAU,uBAAuB,YAAY,KAC3C,kBACD,CAAC;IACF,SAAS;GACV,EAAC;AAEF,QAAK,SAAS;AACZ,WAAO,OAAO;AACd,YAAQ,KAAK,EAAE;GAChB;AAED,YAAS,MAAM,QAAQ;IACrB,KAAK,QAAQ;IACb,KAAK;IACL,OAAO;IACP,UAAU;IACV,eAAe;IACf,QAAQ;IACR,cAAc;IACd,QAAQ,QAAQ;IAChB,cAAc,QAAQ;IACtB,OAAO;GACR,EAAC;EACH;AAID,OAAK,OACH,OAAM,IAAI,OACP,2BAA2B,YAAY,KAAK,QAAQ,IAAI,CAAC;AAI9D,QAAM,cAAc,QAAQ,YAAY,QAAQ,QAAQ;CACzD,SACM,OAAO;AACZ,SAAO,OAAO;AACd,cAAY,MAAM;CACnB;AACF,EAAC;AAEJ,eAAe,4BACbC,SACA;CACA,MAAM,gBAAgB,MAAM,kBAAkB;AAE9C,MAAK,eAAe;AAClB,SAAO,OAAO;AACd,cAAY,IAAI,MAAM,mCAAmC;AACzD,SAAO,CAAE;CACV;AAED,KAAI,QAAQ,IACV,QAAO,cACJ,IAAI,WAAS,MAAM,KAAK,CACxB,OACC,gBAAc,sBAAsB,KAAK,OAAK,EAAE,SAAS,UAAU,CACpE;AAGL,KAAI,QAAQ,YAAY,OACtB,QAAO,QAAQ;CAGjB,MAAM,EAAE,YAAY,GAAG,MAAM,QAAQ;EACnC,MAAM;EACN,MAAM;EACN,SAAS;EACT,MAAM;EACN,cAAc;EACd,SAAS,cACN,OACC,WACE,MAAM,SAAS,kBACX,sBAAsB,KACxB,eAAa,UAAU,SAAS,MAAM,KACvC,CACJ,CACA,IAAI,YAAU;GACb,OAAO,MAAM;GACb,OAAO,MAAM;GACb,UAAU,QAAQ,MAAM,OAAO,QAAQ,YAAY,SAAS,MAAM,KAAK;EACxE,GAAE;CACN,EAAC;AAEF,MAAK,YAAY,QAAQ;AACvB,SAAO,KAAK,mCAAmC;AAC/C,SAAO,KAAK,GAAG;AACf,UAAQ,KAAK,EAAE;CAChB;CAED,MAAM,SAAS,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC,UAAU,WAAW;AACxD,MAAK,OAAO,SAAS;AACnB,SAAO,MAAM,GAAG;AAChB,cAAY,IAAI,MAAM,2CAA2C;AACjE,SAAO,CAAE;CACV;AACD,QAAO,OAAO;AACf;;;;ACjOD,eAAsB,eACpBC,SACA;CACA,MAAMC,SAAkC,CAAE;CAE1C,MAAM,eAAe;EACnB,KAAK,QAAQ;EACb,cAAc,KAAK,QAAQ,QAAQ,KAAK,QAAQ,aAAa;EAC7D,WAAW,KAAK,QAAQ,QAAQ,KAAK,QAAQ,UAAU;CACxD;AAGD,MAAK,GAAG,WAAW,aAAa,aAAa,CAC3C,uCAA6C;AAI/C,OAAM,GAAG,MAAM,aAAa,WAAW,EAAE,WAAW,KAAM,EAAC;AAE3D,KAAI,OAAO,KAAK,OAAO,CAAC,SAAS,GAAG;AAClC,MAAI,qCAA4C;AAC9C,UAAO,OAAO;AACd,UAAO,OACJ,WAAW,YAAY,KACtB,aAAa,aACd,CAAC,kBACH;EACF;AAED,SAAO,OAAO;AACd,UAAQ,KAAK,EAAE;CAChB;AAED,QAAO;EACL;EACA;CACD;AACF;;;;AClCD,MAAa,qBAAqB,EAAE,OAAO;CACzC,KAAK,EAAE,QAAQ;CACf,cAAc,EAAE,QAAQ;CACxB,WAAW,EAAE,QAAQ;AACtB,EAAC;AAEF,MAAa,QAAQ,IAAI,UACtB,KAAK,QAAQ,CACb,YAAY,yCAAyC,CACrD,SAAS,cAAc,8BAA8B,kBAAkB,CACvE,OACC,uBACA,wCACA,aACD,CACA,OACC,mBACA,6DACA,QAAQ,KAAK,CACd,CACA,OAAO,OAAOC,UAAkB,SAAS;AACxC,KAAI;EACF,MAAM,UAAU,mBAAmB,MAAM;GACvC,KAAK,OAAK,QAAQ,KAAK,IAAI;GAC3B,cAAc;GACd,WAAW,KAAK;EACjB,EAAC;EAEF,MAAM,EAAE,cAAc,GAAG,MAAM,eAAe,QAAQ;EACtD,MAAM,UAAU,MAAM,KAAG,SAAS,aAAa,cAAc,QAAQ;EAErE,MAAM,SAAS,eAAe,UAAU,KAAK,MAAM,QAAQ,CAAC;AAE5D,OAAK,OAAO,SAAS;AACnB,UAAO,OACJ,iCAAiC,YAAY,KAC5C,aAAa,aACd,CAAC,GACH;AACD,WAAQ,KAAK,EAAE;EAChB;EAED,MAAM,eAAe,QAAQ,uBAAuB;AACpD,OAAK,MAAM,gBAAgB,OAAO,KAAK,OAAO;AAC5C,QAAK,aAAa,MAChB;AAGF,gBAAa,OAAO,WAAW,aAAa,KAAK,KAAK;AAGtD,gBAAa,UACT;AAGJ,QAAK,MAAM,QAAQ,aAAa,MAC9B,MAAK,UAAU,MAAM,KAAG,SACtB,OAAK,QAAQ,aAAa,KAAK,KAAK,KAAK,EACzC,QACD;GAIH,MAAMC,WAAS,mBAAmB,UAAU,aAAa;AACzD,QAAKA,SAAO,SAAS;AACnB,WAAO,OACJ,kCAAkC,YAAY,KAC7C,aAAa,KACd,CAAC,GACH;AACD;GACD;AAGD,SAAM,KAAG,UACP,OAAK,QAAQ,aAAa,YAAY,EAAEA,SAAO,KAAK,KAAK,OAAO,EAChE,KAAK,UAAUA,SAAO,MAAM,MAAM,EAAE,CACrC;EACF;AAED,eAAa,QAAQ,qBAAqB;CAC3C,SACM,OAAO;AACZ,SAAO,OAAO;AACd,cAAY,MAAM;CACnB;AACF,EAAC;;;;AC9EJ,MAAM,sBAAsB,EAAE,OAAO;CACnC,WAAW,EAAE,QAAQ,CAAC,UAAU;CAChC,KAAK,EAAE,SAAS;CAChB,KAAK,EAAE,QAAQ;CACf,MAAM,EAAE,QAAQ,CAAC,UAAU;AAC5B,EAAC;AAEF,MAAa,OAAO,IAAI,UACrB,KAAK,OAAO,CACZ,YAAY,yCAAyC,CACrD,SAAS,eAAe,qBAAqB,CAC7C,OAAO,aAAa,6BAA6B,MAAM,CACvD,OACC,mBACA,6DACA,QAAQ,KAAK,CACd,CACA,OAAO,OAAOC,QAAM,SAAS;AAC5B,KAAI;EACF,MAAM,UAAU,oBAAoB,MAAM;GACxC,WAAWA;GACX,GAAG;EACJ,EAAC;EAEF,MAAM,MAAM,KAAK,QAAQ,QAAQ,IAAI;AAErC,OAAK,WAAW,IAAI,EAAE;AACpB,UAAO,OAAO,WAAW,IAAI,oCAAoC;AACjE,WAAQ,KAAK,EAAE;EAChB;EAED,MAAM,SAAS,MAAM,UAAU,IAAI;AACnC,OAAK,QAAQ;AACX,UAAO,MACJ,uCAAuC,YAAY,SACjD,MACF,CAAC,oCACH;AACD,WAAQ,KAAK,EAAE;EAChB;EAED,MAAM,gBAAgB,MAAM,kBAAkB;AAE9C,OAAK,eAAe;AAClB,eAAY,IAAI,MAAM,mCAAmC;AACzD,WAAQ,KAAK,EAAE;EAChB;AAED,OAAK,QAAQ,WAAW;GACtB,MAAM,YAAY,OAAO,cAAc;GAGvC,MAAM,oBAAoB,cAAc,OAAO,CAAC,SAAS;AACvD,SAAK,MAAM,QAAQ,KAAK,SAAS,CAAE,GAAE;KACnC,MAAM,WAAW,KAAK,QACpB,kBACO,SAAS,WAAW,OAAO,KAAK,KACxC;AACD,SAAI,WAAW,SAAS,CACtB,QAAO;IAEV;AAED,WAAO;GACR,EAAC;GAGF,MAAM,wBAAwB,CAAE;AAChC,QAAK,MAAMC,eAAa,mBAAmB;IACzC,MAAMC,YAAU,MAAM,cAAcD,aAAW,OAAO;AACtD,QAAIC,UAAQ,OACV,uBAAsB,KAAK;KACzB,MAAMD,YAAU;KAChB;IACD,EAAC;GAEL;AAED,QAAK,sBAAsB,QAAQ;AACjC,WAAO,KAAK,oBAAoB;AAChC,YAAQ,KAAK,EAAE;GAChB;AAED,UAAO,KAAK,mDAAmD;AAC/D,QAAK,MAAMA,eAAa,uBAAuB;AAC7C,WAAO,MAAM,IAAIA,YAAU,KAAK,EAAE;AAClC,SAAK,MAAM,UAAUA,YAAU,QAC7B,QAAO,MAAM,MAAM,OAAO,SAAS,EAAE;GAExC;AACD,UAAO,OAAO;AACd,UAAO,MACJ,MAAM,YAAY,SAAS,kBAAkB,CAAC,sBAChD;AACD,WAAQ,KAAK,EAAE;EAChB;EAGD,MAAM,YAAY,cAAc,KAC9B,UAAQ,KAAK,SAAS,QAAQ,UAC/B;AAED,OAAK,WAAW;AACd,UAAO,OACJ,gBAAgB,YAAY,QAC3B,QAAQ,UACT,CAAC,kBACH;AACD,WAAQ,KAAK,EAAE;EAChB;EAED,MAAM,UAAU,MAAM,cAAc,WAAW,OAAO;AAEtD,OAAK,QAAQ,QAAQ;AACnB,UAAO,MAAM,uBAAuB,QAAQ,UAAU,GAAG;AACzD,WAAQ,KAAK,EAAE;EAChB;AAED,OAAK,MAAM,UAAU,SAAS;AAC5B,UAAO,MAAM,IAAI,OAAO,SAAS,EAAE;AACnC,SAAM,UAAU,OAAO,MAAM;AAC7B,UAAO,KAAK,GAAG;EAChB;CACF,SACM,OAAO;AACZ,cAAY,MAAM;CACnB;AACF,EAAC;AAEJ,eAAe,cACbE,WACAC,QACA;CACA,MAAM,UAAU,MAAM,UAAU,OAAO,OAAO,CAAC,SAAU,EAAC;CAC1D,MAAM,YAAY,MAAM,qBAAqB,OAAO,SAAS,UAAU;AAEvE,MAAK,QACH,QAAO,CAAE;CAGX,MAAM,UAAU,CAAE;AAElB,MAAK,MAAM,QAAQ,SAAS;EAC1B,MAAM,YAAY,MAAM,kBAAkB,QAAQ,KAAK;AAEvD,OAAK,UACH;AAGF,OAAK,MAAM,QAAQ,KAAK,SAAS,CAAE,GAAE;GACnC,MAAM,WAAW,KAAK,QACpB,kBACO,SAAS,WAAW,OAAO,KAAK,KACxC;AAED,QAAK,WAAW,SAAS,CACvB;GAGF,MAAM,cAAc,MAAM,SAAG,SAAS,UAAU,OAAO;AAEvD,cAAW,SAAS,aAAa,KAAK,QACpC;GAGF,MAAM,kBAAkB,MAAM,YAAU;IACtC,UAAU,KAAK;IACf,KAAK,KAAK;IACV;IACA;GACD,EAAC;GAEF,MAAM,QAAQ,UAAU,iBAA2B,YAAY;AAC/D,OAAI,MAAM,SAAS,EACjB,SAAQ,KAAK;IACX;IACA;GACD,EAAC;EAEL;CACF;AAED,QAAO;AACR;AAED,eAAe,UAAUC,QAAgB;AACvC,QAAK,QAAQ,CAAC,SAAS;AACrB,MAAI,MAAM;AACR,OAAI,KAAK,MACP,QAAO,QAAQ,OAAO,MAAM,YAAY,QAAQ,KAAK,MAAM,CAAC;AAE9D,OAAI,KAAK,QACP,QAAO,QAAQ,OAAO,MAAM,YAAY,MAAM,KAAK,MAAM,CAAC;AAG5D,UAAO,QAAQ,OAAO,MAAM,KAAK,MAAM;EACxC;CACF,EAAC;AACH;;;;ACnND,MAAa,OAAO,IAAI,UACrB,KAAK,OAAO,CACZ,YAAY,qCAAqC,CACjD,OACC,mBACA,6DACA,QAAQ,KAAK,CACd,CACA,OAAO,OAAO,SAAS;AACtB,QAAO,KAAK,iBAAiB;AAC7B,SAAQ,IAAI,MAAM,eAAe,KAAK,IAAI,CAAC;AAC3C,QAAO,OAAO;AACd,QAAO,KAAK,oBAAoB;AAChC,SAAQ,IAAI,MAAM,UAAU,KAAK,IAAI,CAAC;AACvC,EAAC;;;;ACHJ,eAAsB,aAAaC,QAAgB;AACjD,MAAK,OAAO,cAAc,GACxB,OAAM,IAAI,MACR;CAIJ,MAAM,SAAS,OAAO,cAAc;CACpC,MAAM,CAACC,SAAO,cAAc,GAAG,MAAM,QAAQ,IAAI,CAC/C,KAAK,wBAAwB,EAC3B,KAAK,OACN,EAAC,EACF,kBAAkB,AACnB,EAAC;AAEF,KAAI,OAAO,KAAK,cAAc,CAAC,WAAW,EACxC,OAAM,IAAI,MAAM;CAGlB,MAAM,iBAAiB,OAAO,QAAQ,eAAe,CAAC,IACpD,CAAC,CAACC,QAAM,YAAY,MAAM;EACxB,OAAO,YAAY;EACnB,OAAOA;CACR,GACF;CAED,MAAM,iBAAiB,MAAM,QAAQ,CACnC;EACE,MAAM;EACN,MAAM;EACN,UAAU,uCAAuC,YAAY,KAC3D,eACD,CAAC;EACF,SAAS;CACV,GACD;EACE,MAAM;EACN,MAAM;EACN,UAAU,uCAAuC,YAAY,KAC3D,aACD,CAAC;EACF,SAAS;CACV,CACF,EAAC;AAEF,KAAI,eAAe,kBAAkB,eAAe,cAClD,OAAM,IAAI,MACR;AAIJ,OAEI,eAAe,iBAAiB,kBAC7B,eAAe,iBAAiB,gBAGrC,OAAM,IAAI,MAAM;CAGlB,MAAM,gBACF,eAAe,eAAe;CAClC,MAAM,gBACF,eAAe,eAAe;CAClC,MAAM,EAAE,SAAS,GAAG,MAAM,QAAQ;EAChC,MAAM;EACN,MAAM;EACN,SAAS;EACT,UAAU,kBAAkB,YAAY,KACtCD,QAAM,OACP,CAAC,YAAY,YAAY,MACvB,IAAI,KAAK,SAAS,OAAO,cAAc,KAAK,OAAO,CAAC,EACtD,CAAC,QAAQ,YAAY,KAAK,cAAc,KAAK,CAAC,MAAM,YAAY,KAC/D,cAAc,KACf,CAAC;CACH,EAAC;AAEF,MAAK,SAAS;AACZ,SAAO,KAAK,uBAAuB;AACnC,UAAQ,KAAK,EAAE;CAChB;AAED,KAAI,cAAc,QAChB,OAAM,mBAAmB,CAAC,cAAc,OAAQ,GAAE,QAAQ,EACxD,QAAQ,MACT,EAAC;CAGJ,MAAM,mBAAmB,SAAS,oBAAoB,EAAE,OAAO;AAE/D,OAAM,QAAQ,IACZ,QAAM,IAAI,OAAO,SAAS;AACxB,mBAAiB,QAAQ,YAAY,KAAK;EAE1C,MAAM,WAAW,KAAK,KAAK,QAAQ,KAAK;EACxC,MAAM,cAAc,MAAM,SAAG,SAAS,UAAU,QAAQ;EAExD,MAAM,UAAU,MAAM,iBACpB,aACA,eAAe,eACf,eAAe,eACf,cACD;AAED,QAAM,SAAG,UAAU,UAAU,QAAQ;CACtC,EAAC,CACH;AAED,kBAAiB,QAAQ,sBAAsB;AAChD;AAED,eAAsB,iBACpBE,SACAC,eACAC,eACAC,cACA;CACA,MAAM,sBAAsB,eAAe,gBAAgB;CAC3D,MAAM,sBAAsB,eAAe,gBAAgB;CAE3D,MAAM,MAAM,MAAM,SAAG,QAAQ,KAAK,KAAK,QAAQ,EAAE,UAAU,CAAC;CAC5D,MAAM,UAAU,IAAI,QAAQ,EAC1B,iBAAiB,CAAE,EACpB;CAED,MAAM,WAAW,KAAK,KACpB,MACC,eAAe,YAAY,EAAE,CAAC,SAAS,MAAM,CAAC,MAChD;CACD,MAAM,aAAa,QAAQ,iBAAiB,UAAU,SAAS,EAC7D,YAAY,WAAW,IACxB,EAAC;CAGF,MAAMC,gBAA0B,CAAE;AAClC,MAAK,MAAM,qBAAqB,WAAW,uBAAuB,IAAI,CAAE,GAAE;AACxE,MACE,kBAAkB,oBAAoB,EAAE,SAAS,MAC5C,GAAG,oBAAoB,GAE5B;AAGF,OAAK,MAAM,aAAa,kBAAkB,iBAAiB,IAAI,CAAE,GAAE;GACjE,MAAM,WAAW,UAAU,SAAS;GAGpC,MAAM,eAAe,OAAO,OAAO,aAAa,CAAC,KAC/C,UAAQ,KAAK,mBAAmB,SACjC,GAAG;AAEJ,QAAK,gBAAgB,cAAc,SAAS,aAAa,CACvD;AAGF,iBAAc,KAAK,aAAa;AAGhC,aAAU,QAAQ;AAGlB,cACG,qBAAqB,WAAW,sBAAsB,CACtD,OAAO,UAAQ,KAAK,gBAAgB,EAAE,SAAS,KAAK,SAAS,CAC7D,QAAQ,UAAQ,KAAK,gBAAgB,EAAE,gBAAgB,aAAa,CAAC;EACzE;AAGD,MAAI,kBAAkB,iBAAiB,EAAE,WAAW,EAClD,mBAAkB,QAAQ;CAE7B;AAED,KAAI,cAAc,SAAS,EACzB,YAAW,qBAAqB;EAC9B,iBAAiB;EACjB,cAAc,cAAc,IAAI,WAAS,EACvC,MAAM,KACP,GAAE;CACJ,EAAC;AAGJ,QAAO,MAAM,WAAW,SAAS;AAClC;;;;AC9LD,eAAsB,iBACpBC,SACA;CACA,MAAMC,SAAkC,CAAE;AAI1C,MACG,GAAG,WAAW,QAAQ,IAAI,KACvB,GAAG,WAAW,KAAK,QAAQ,QAAQ,KAAK,eAAe,CAAC,EAC5D;AACA,yCAA8C;AAC9C,SAAO;GACL;GACA,QAAQ;EACT;CACF;AAGD,MAAK,GAAG,WAAW,KAAK,QAAQ,QAAQ,KAAK,kBAAkB,CAAC,EAAE;AAChE,2BAAgC;AAChC,SAAO;GACL;GACA,QAAQ;EACT;CACF;AAED,KAAI;EACF,MAAM,SAAS,MAAM,UAAU,QAAQ,IAAI;AAE3C,SAAO;GACL;GACQ;EACT;CACF,SACM,OAAO;AACZ,SAAO,OAAO;AACd,SAAO,OACJ,aAAa,YAAY,KACxB,kBACD,CAAC,qBAAqB,YAAY,KACjC,QAAQ,IACT,CAAC,6DAA6D,YAAY,KACzE,kBACD,CAAC,uBAAuB,YAAY,KAAK,OAAO,CAAC,WACnD;AACD,SAAO,OACJ,gBAAgB,YAAY,KAC3B,8CACD,CAAC,GACH;AACD,SAAO,OAAO;AACd,UAAQ,KAAK,EAAE;CAChB;AACF;;;;ACvDD,MAAa,aAAa,CACxB;CACE,MAAM;CACN,aAAa;AACd,CACF;AAED,MAAa,uBAAuB,EAAE,OAAO;CAC3C,KAAK,EAAE,QAAQ;CACf,MAAM,EAAE,SAAS;CACjB,WAAW,EACR,QAAQ,CACR,OACC,WACE,SAAS,WAAW,KAAK,eAAa,UAAU,SAAS,MAAM,EACjE,EACE,SACE,+FACH,EACF,CACA,UAAU;AACd,EAAC;AAEF,MAAa,UAAU,IAAI,UACxB,KAAK,UAAU,CACf,YAAY,mBAAmB,CAC/B,SAAS,eAAe,wBAAwB,CAChD,OACC,mBACA,6DACA,QAAQ,KAAK,CACd,CACA,OAAO,cAAc,wBAAwB,MAAM,CACnD,OAAO,OAAO,WAAW,SAAS;AACjC,KAAI;EACF,MAAM,UAAU,qBAAqB,MAAM;GACzC,KAAK,KAAK,QAAQ,KAAK,IAAI;GAC3B;GACA,MAAM,KAAK;EACZ,EAAC;AAEF,MAAI,QAAQ,SAAS,QAAQ,WAAW;AACtC,WAAQ,KAAK,wBAAwB;AACrC,QAAK,MAAMC,eAAa,WACtB,SAAQ,MAAM,IAAIA,YAAU,KAAK,IAAIA,YAAU,YAAY,EAAE;AAE/D;EACD;AAED,OAAK,QAAQ,UACX,OAAM,IAAI,MACR;EAIJ,MAAM,EAAE,QAAQ,QAAQ,GAAG,MAAM,iBAAiB,QAAQ;AAE1D,MACE,wCACG,uBAEH,OAAM,IAAI,MACR;AAIJ,OAAK,OACH,OAAM,IAAI,MACR;AAIJ,MAAI,QAAQ,cAAc,QACxB,OAAM,aAAa,OAAO;CAE7B,SACM,OAAO;AACZ,cAAY,MAAM;CACnB;AACF,EAAC;;;;WCvFM;WACA;cACG;kBACI;oBACE,EACf,UAAU,SACX;cACU;iBACG;CACZ,QAAQ;CACR,OAAO;CACP,aAAa;AACd;eACW;CACV;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACD;cACU;CACT,KAAK;EACH,SAAS;EACT,WAAW;CACZ;CACD,cAAc;EACZ,SAAS;EACT,WAAW;CACZ;AACF;UACM;YACE,CACP,MACD;cACU;CACT,OAAO;CACP,SAAS;CACT,aAAa;CACb,SAAS;CACT,QAAQ;CACR,YAAY;CACZ,aAAa;CACb,SAAS;CACT,WAAW;CACX,YAAY;CACZ,YAAY;CACZ,eAAe;CACf,QAAQ;CACR,eAAe;CACf,WAAW;AACZ;mBACe;CACd,mBAAmB;CACnB,qBAAqB;CACrB,aAAa;CACb,WAAW;CACX,eAAe;CACf,aAAa;CACb,QAAQ;CACR,YAAY;CACZ,gBAAgB;CAChB,gBAAgB;CAChB,QAAQ;CACR,UAAU;CACV,OAAO;CACP,SAAS;CACT,WAAW;CACX,WAAW;CACX,WAAW;CACX,oBAAoB;CACpB,eAAe;CACf,YAAY;CACZ,cAAc;CACd,YAAY;CACZ,UAAU;CACV,iBAAiB;CACjB,OAAO;AACR;sBACkB;CACjB,eAAe;CACf,mBAAmB;CACnB,eAAe;CACf,kBAAkB;CAClB,2BAA2B;CAC3B,OAAO;CACP,UAAU;CACV,aAAa;CACb,cAAc;AACf;sBA9FH;;;;;;;;;;;;;;;AA+FC;;;;ACpFD,QAAQ,GAAG,UAAU,MAAM,QAAQ,KAAK,EAAE,CAAC;AAC3C,QAAQ,GAAG,WAAW,MAAM,QAAQ,KAAK,EAAE,CAAC;AAE5C,eAAe,OAAO;CACpB,MAAM,UAAU,IAAI,UACjB,KAAK,aAAa,CAClB,YAAY,kDAAkD,CAC9D,QACCC,gBAAY,WAAW,SACvB,iBACA,6BACD;AAEH,SACG,WAAW,KAAK,CAChB,WAAW,IAAI,CACf,WAAW,KAAK,CAChB,WAAW,QAAQ,CACnB,WAAW,KAAK,CAChB,WAAW,MAAM;AAEpB,SAAQ,OAAO;AAChB;AAED,MAAM"}